Module M_inssor
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none
Private
public :: inssor
interface inssor
  module procedure real64_inssor, real32_inssor, int32_inssor
end interface inssor
contains
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file inssor.3orderpack.man
NAME
   inssor(3f) - [orderpack:SORT] Sorts XDONT into increasing order
                (Insertion sort)
                (LICENSE:CC0-1.0)

SYNOPSIS
    Subroutine ${KIND}_inssor (XDONT)

            ${TYPE} (kind=${KIND}), Dimension (:), Intent (InOut) :: XDONT

   Where ${TYPE}(kind=${KIND}) may be

      o Real(kind=real32)
      o Real(kind=real64)
      o Integer(kind=int32)

DESCRIPTION
   Sorts XDONT into increasing order (Insertion sort)

   This subroutine uses insertion sort. It does not use any work array
   and is faster when XDONT is of very small size (< 20), or already
   almost sorted, but worst case behavior can happen fairly probably
   (initially inverse sorted).  In many cases, the quicksort or merge
   sort method is faster.

OPTIONS
    XDONT      array to sort

EXAMPLES
  Sample program:

   program demo_inssor
   use M_inssor, only : inssor
   implicit none
      !x!call inssor(yyyyyy)
   end program demo_inssor

  Results:

AUTHOR
    Michel Olagnon - Apr. 2000

    John Urban, 2022.04.16
    o added man-page and reduced to a template using the
      prep(1) preprocessor.

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL INSSOR
Subroutine ${KIND}_inssor (XDONT)
! __________________________________________________________
      ${TYPE} (kind=${KIND}), Dimension (:), Intent (InOut) :: XDONT
      ${TYPE} (Kind=${KIND}) :: XWRK, XMIN
! __________________________________________________________
      Integer :: ICRS, IDCR, NDON
!
      NDON = Size (XDONT)
!
! We first bring the minimum to the first location in the array.
! That way, we will have a "guard", and when looking for the
! right place to insert a value, no loop test is necessary.
!
      If (XDONT (1) < XDONT (NDON)) Then
          XMIN = XDONT (1)
      Else
          XMIN = XDONT (NDON)
          XDONT (NDON) = XDONT (1)
      Endif
      Do IDCR = NDON-1, 2, -1
         XWRK = XDONT(IDCR)
         IF (XWRK < XMIN) Then
            XDONT (IDCR) = XMIN
            XMIN = XWRK
         End If
      End Do
      XDONT (1) = XMIN
!
! The first value is now the minimum
! Loop over the array, and when a value is smaller than
! the previous one, loop down to insert it at its right place.
!
      Do ICRS = 3, NDON
         XWRK = XDONT (ICRS)
         IDCR = ICRS - 1
         If (XWRK < XDONT(IDCR)) Then
            XDONT (ICRS) = XDONT (IDCR)
            IDCR = IDCR - 1
            Do
               If (XWRK >= XDONT(IDCR)) Exit
               XDONT (IDCR+1) = XDONT (IDCR)
               IDCR = IDCR - 1
            End Do
            XDONT (IDCR+1) = XWRK
         End If
      End Do
!
      Return
!
End Subroutine ${KIND}_inssor
$ENDPARCEL
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$SET KIND real64
$SET TYPE Real
$POST inssor
$
$SET KIND real32
$SET TYPE Real
$POST inssor
$
$SET KIND int32
$SET TYPE Integer
$POST inssor
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
end module M_inssor

var tipuesearch = {"pages":[{"title":" orderpack ","text":"orderpack Name orderpack (3f) - general and specialized ranking and sorting routines Description This repository is a derivative of ORDERPACK 2.0 from Michel Olagnon\nthat additionally supports CHARACTER variables as well as numeric variables on many of\n   the procedures. has been restructured so as to be useable as an fpm(1) package. is placed in a git(1) repository for version control. had man-pages and working demonstration programs of each procedure\n   added. contains a growing set of unit tests. ORDERPACK 2.1 performs both conventional sorting and ranking as well as\nthe rarer specialized ordering tasks such as partial sorting, partial\nranking, unique sorting, unique ranking, inverse unique ranking, and\nmore. These partial sort and ranking routines can greatly accelerate\nmany computations when users need only the M largest or smallest elements\nout of a N-element vector. All the specialized procedures have a range over which they far outperform\na basic sort, and most have a range where they dramatically underperform.\nIf you are not limited by memory requirements or have no issues with\nruntimes the simplest solution may be just to use SORT(3f) and RANK(3f). Otherwise, your solution method may very well depend on the size of the\ninput arrays, whether the data is already close to the required order,\nor how costly it is to create work arrays or an index array. So, if you want the smallest value in an array call the intrinsic\nMINVAL(3f), not ORDERVAL(3f). Authors : Michel Olagnon date: 2000-2013 wrote the original ORDERPACK 2.0 John S. Urban, date: 2022 derived ORDERPACK 2.1 from ORDERPACK 2.0 LICENSE : CC0-1.0 Recent Events and Issues (See Also : CHANGELOG) 2022-04-18 There appear to be issues with the original code, but may have been introduced\n  (but are being looked at): UNIPAR returns non-unique values when less unique values in input than\n  requested in output with gfortran,nvfortran; OK with ifort Building the module using make This will compile the Fortran module and basic example programs that exercise the routines: git clone https://github.com/urbanjost/orderpack.git cd orderpack/src # change Makefile if not using one of the listed compilers # for gfortran make clean\n     make gfortran # for ifort make clean\n     make ifort # for nvfortran make clean\n     make nvfortran Build and test with Download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) git clone https://github.com/urbanjost/orderpack.git cd orderpack\n        fpm build or just list it as a dependency in your fpm.toml project file. [dependencies] orderpack = { git = \"https://github.com/urbanjost/orderpack.git\" } Documentation User routines are described in HTML form using the format of man-pages. There are man-pages in the repository download in the docs/ directory\n     that may be installed on ULS (Unix-Like Systems). manpages.zip manpages.tgz CHANGELOG provides a history of significant changes Developer ford(1) output . doxygen(1) output . github action status See also - parallel mrgrnk References ORDERPACK2.0 ORDERPACK2.0 sorting(Wikipedia) median(Rosetta Code) median(Wikipedia) quartile(Wikipedia) Developer Info Michel Olagnon","tags":"home","loc":"index.html"},{"title":"M_inssor.f90 – orderpack","text":"Contents Modules M_inssor Source Code M_inssor.f90 Source Code Module M_inssor use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: inssor interface inssor module procedure real64_inssor , real32_inssor , int32_inssor , f_char_inssor end interface inssor contains !> !!##NAME !!    sort_special(3f) - [orderpack:SORT] Sorts array into ascending order !!                 (Insertion sort, generally for small or nearly sorted !!                 arrays) !!##SYNOPSIS !! !!      Subroutine Sort_Special (INOUTVALS) !! !!       ${TYPE} (kind=${KIND}), Intent (InOut) :: INOUTVALS(:) !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Sorts INOUTVALS() into ascending order (Insertion sort). !! !!    If certain requirements are met and performance is important this !!    procedure can be far faster, but REFSOR(3f) and ranking routines !!    MRGRNK(3f) and MRGREF(3f) are recommended for the general case. !! !!    This subroutine uses an Insertion sort. It does not use any work array !!    and is faster when INOUTVALS() is of very small size (< 20), or already !!    almost sorted; but worst case behavior can be triggered by commonly !!    encountered data order (e.g. initially inverse sorted). Therefore, !!    in many cases the Quicksort or Mergesort method is faster. !! !!##OPTIONS !!     INOUTVALS      array to sort !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_sort_special !!    ! sort an array using insertion sort !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_orderpack, only : sort_special !!    implicit none !!    ! an insertion sort is very efficient for very small arrays !!    ! but generally slower than methods like quicksort and mergesort. !!    integer,parameter :: isz=2000 !!    real(kind=real64) :: dd(isz), hi, low !!    integer           :: i !!       ! make an array of random values !!       call random_seed() !!       call random_number(dd) !!       dd=dd*1000000.0-500000.0 !!       low= minval(dd) !!       hi = maxval(dd) !!       ! sort the data !!       call sort_special(dd) !!       ! cursory checks !!       if(any(dd(1:isz-1) .gt. dd(2:isz)))stop 'ERROR: array not sorted' !!       write(*,*)'check min:',dd(1).eq.low !!       write(*,*)'check max:',dd(isz).eq.hi !!       write(*,*)'PASSED: random array is now sorted' !!    end program demo_sort_special !! !!   Results: !! !!     check min: T !!     check max: T !!     PASSED: random array is now sorted !! !!##AUTHOR !!    Michel Olagnon - Apr. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_inssor ( INOUTVALS ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Real ( Kind = real64 ) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( INOUTVALS ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( INOUTVALS ( 1 ) < INOUTVALS ( NDON )) Then XMIN = INOUTVALS ( 1 ) Else XMIN = INOUTVALS ( NDON ) INOUTVALS ( NDON ) = INOUTVALS ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = INOUTVALS ( IDCR ) IF ( XWRK < XMIN ) Then INOUTVALS ( IDCR ) = XMIN XMIN = XWRK End If End Do INOUTVALS ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = INOUTVALS ( ICRS ) IDCR = ICRS - 1 If ( XWRK < INOUTVALS ( IDCR )) Then INOUTVALS ( ICRS ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 End Do INOUTVALS ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine real64_inssor Subroutine real32_inssor ( INOUTVALS ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Real ( Kind = real32 ) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( INOUTVALS ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( INOUTVALS ( 1 ) < INOUTVALS ( NDON )) Then XMIN = INOUTVALS ( 1 ) Else XMIN = INOUTVALS ( NDON ) INOUTVALS ( NDON ) = INOUTVALS ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = INOUTVALS ( IDCR ) IF ( XWRK < XMIN ) Then INOUTVALS ( IDCR ) = XMIN XMIN = XWRK End If End Do INOUTVALS ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = INOUTVALS ( ICRS ) IDCR = ICRS - 1 If ( XWRK < INOUTVALS ( IDCR )) Then INOUTVALS ( ICRS ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 End Do INOUTVALS ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine real32_inssor Subroutine int32_inssor ( INOUTVALS ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer ( Kind = int32 ) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( INOUTVALS ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( INOUTVALS ( 1 ) < INOUTVALS ( NDON )) Then XMIN = INOUTVALS ( 1 ) Else XMIN = INOUTVALS ( NDON ) INOUTVALS ( NDON ) = INOUTVALS ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = INOUTVALS ( IDCR ) IF ( XWRK < XMIN ) Then INOUTVALS ( IDCR ) = XMIN XMIN = XWRK End If End Do INOUTVALS ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = INOUTVALS ( ICRS ) IDCR = ICRS - 1 If ( XWRK < INOUTVALS ( IDCR )) Then INOUTVALS ( ICRS ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 End Do INOUTVALS ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine int32_inssor Subroutine f_char_inssor ( INOUTVALS ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: INOUTVALS character ( Kind = f_char , len = len ( INOUTVALS )) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( INOUTVALS ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( INOUTVALS ( 1 ) < INOUTVALS ( NDON )) Then XMIN = INOUTVALS ( 1 ) Else XMIN = INOUTVALS ( NDON ) INOUTVALS ( NDON ) = INOUTVALS ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = INOUTVALS ( IDCR ) IF ( XWRK < XMIN ) Then INOUTVALS ( IDCR ) = XMIN XMIN = XWRK End If End Do INOUTVALS ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = INOUTVALS ( ICRS ) IDCR = ICRS - 1 If ( XWRK < INOUTVALS ( IDCR )) Then INOUTVALS ( ICRS ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) IDCR = IDCR - 1 End Do INOUTVALS ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine f_char_inssor end module M_inssor","tags":"","loc":"sourcefile/m_inssor.f90.html"},{"title":"M_indnth.f90 – orderpack","text":"Contents Modules M_indnth Source Code M_indnth.f90 Source Code Module M_indnth use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: indnth interface indnth module procedure real64_indnth , real32_indnth , int32_indnth !, f_char_indnth end interface indnth contains !> !!##NAME !!    orderloc(3f) - [orderpack:FRACTILE] Return INDEX of Nth ordered value of !!                 array, or \"fractile of order N/SIZE(array)\" (QuickSort-like) !! !!##SYNOPSIS !! !!     Function OrderLoc (INVALS, NORD) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer                             :: orderloc !!       Integer, Intent (In)                :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    orderloc(3f) returns the index of NORDth value of INVALS, i.e. the !!    fractile of order NORD/SIZE(INVALS). !! !!    That is, the result is the same as sorting the array first and then !!    returning the value INVALS(NORD). !! !!    Internally orderloc(3f) uses a pivoting strategy such as the one !!    of finding the median based on the quicksort algorithm, but we skew !!    the pivot choice to try to bring it to NORD as fast as possible. It !!    uses two temporary arrays, where it stores the indices of the values !!    smaller than the pivot (ILOWT), and the indices of values larger than !!    the pivot that we might still need later on (IHIGT). It iterates !!    until it can bring the number of values in ILOWT to exactly NORD, !!    and then finds the maximum of this set. !! !!##OPTIONS !!     INVALS      array to search !!     NORD       indicates the Nth ordered value to search for !! !!##RETURNS !!     orderloc     the index of INVALS() that contains the requested value !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_orderloc !!    ! find Nth lowest ordered value in an array without sorting entire array !!    use M_orderpack, only : orderloc !!    use M_orderpack, only : medianloc !!    implicit none !!    integer,allocatable :: iarr(:) !!    character(len=*),parameter :: list= '(*(g0:,\", \"))',sp='(*(g0,1x))' !!    integer :: i !!    integer :: indx !!       iarr=[80,70,30,40,50,60,20,10,0,-100] !!       print list, 'ORIGINAL:',iarr !!       ! like minloc() and maxloc() !!       print sp,'minloc',orderloc(iarr,1),                minloc(iarr) !!       print sp,'maxloc',orderloc(iarr,size(iarr)),       maxloc(iarr) !!       ! can find median !!       call medianloc(iarr,indx) !!       print sp,'median',orderloc(iarr,(size(iarr)+1)/2), indx !!       ! but more general so can find location of the Nth lowest value ... !!       ! !!       ! sort the hard way, finding location of Nth value one at a time !!       do i=1,size(iarr) !!          write(*,sp,advance='no') iarr(orderloc(iarr,i)) !!       enddo !!       print * !!    contains !!    subroutine printme(n) !!    integer,intent(in) :: n !!    integer :: ii !!       ii=orderloc(iarr,n) !!       print sp,'nord=',n,' index=',ii,' fractile=',iarr(ii) !!    end subroutine printme !!    end program demo_orderloc !! !!   Results: !! !!    ORIGINAL:, 80, 70, 30, 40, 50, 60, 20, 10, 0, -100 !!    minloc 10 10 !!    maxloc 1 1 !!    median 3 3 !!    -100 0 10 20 30 40 50 60 70 80 !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Function real64_indnth ( INVALS , NORD ) Result ( INDNTH ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( In ) :: NORD Integer :: INDNTH ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( NORD ) :: IRNGT Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = NORD ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) INDNTH = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( 3 ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else IHIGT ( 3 ) = NDON End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) If ( INTH == 4 ) INDNTH = IHIGT ( 3 ) Return End If ! JLOW = 1 JHIG = 3 XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( 1 ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( 1 ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( 1 ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( 1 ) XMAX = INVALS ( ILOW ) Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = INVALS ( IWRK1 ) + 0.5 * ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! INDNTH = IHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK ILOW = ILOW + 1 End Do ! XWRK1 = INVALS ( IRNGT ( INTH )) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( INTH )) End If ILOW = ILOW + 1 End Do ! INDNTH = IRNGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( 1 )) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) ! !  One takes values > XPIV to IHIGT ! JHIG = 0 JLOW = 0 ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! IWRK1 = ILOWT ( 1 ) XWRK1 = INVALS ( IWRK1 ) Do ICRS = 1 + 1 , INTH IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) If ( XWRK > XWRK1 ) Then XWRK1 = XWRK IWRK1 = IWRK End If End Do INDNTH = IWRK1 Return ! ! End Function real64_indnth Function real32_indnth ( INVALS , NORD ) Result ( INDNTH ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( In ) :: NORD Integer :: INDNTH ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( NORD ) :: IRNGT Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = NORD ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) INDNTH = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( 3 ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else IHIGT ( 3 ) = NDON End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) If ( INTH == 4 ) INDNTH = IHIGT ( 3 ) Return End If ! JLOW = 1 JHIG = 3 XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( 1 ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( 1 ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( 1 ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( 1 ) XMAX = INVALS ( ILOW ) Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = INVALS ( IWRK1 ) + 0.5 * ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! INDNTH = IHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK ILOW = ILOW + 1 End Do ! XWRK1 = INVALS ( IRNGT ( INTH )) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( INTH )) End If ILOW = ILOW + 1 End Do ! INDNTH = IRNGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( 1 )) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) ! !  One takes values > XPIV to IHIGT ! JHIG = 0 JLOW = 0 ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! IWRK1 = ILOWT ( 1 ) XWRK1 = INVALS ( IWRK1 ) Do ICRS = 1 + 1 , INTH IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) If ( XWRK > XWRK1 ) Then XWRK1 = XWRK IWRK1 = IWRK End If End Do INDNTH = IWRK1 Return ! ! End Function real32_indnth Function int32_indnth ( INVALS , NORD ) Result ( INDNTH ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( In ) :: NORD Integer :: INDNTH ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( NORD ) :: IRNGT Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = NORD ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) INDNTH = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( 3 ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else IHIGT ( 3 ) = NDON End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) If ( INTH == 4 ) INDNTH = IHIGT ( 3 ) Return End If ! JLOW = 1 JHIG = 3 XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( 1 ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( 1 ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( 1 ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( 1 ) XMAX = INVALS ( ILOW ) Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = INVALS ( IWRK1 ) + 0.5 * ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! INDNTH = IHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK ILOW = ILOW + 1 End Do ! XWRK1 = INVALS ( IRNGT ( INTH )) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( INTH )) End If ILOW = ILOW + 1 End Do ! INDNTH = IRNGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( 1 )) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) ! !  One takes values > XPIV to IHIGT ! JHIG = 0 JLOW = 0 ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! IWRK1 = ILOWT ( 1 ) XWRK1 = INVALS ( IWRK1 ) Do ICRS = 1 + 1 , INTH IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) If ( XWRK > XWRK1 ) Then XWRK1 = XWRK IWRK1 = IWRK End If End Do INDNTH = IWRK1 Return ! ! End Function int32_indnth end module M_indnth","tags":"","loc":"sourcefile/m_indnth.f90.html"},{"title":"M_mulcnt.f90 – orderpack","text":"Contents Modules M_mulcnt Source Code M_mulcnt.f90 Source Code Module M_mulcnt use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 Use M_uniinv implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: mulcnt interface mulcnt module procedure real64_mulcnt , real32_mulcnt , int32_mulcnt , f_char_mulcnt end interface mulcnt contains !> !!##NAME !!    occurrences(3f) - [orderpack:MULTIPLICITY] Give the multiplicity for each !!                 array value (number of times that it appears in the array) !! !!##SYNOPSIS !! !!     Subroutine Occurrences (INVALS, IMULT) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IMULT(:) !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!     OCCURRENCES(3f) Gives, for each array value, its multiplicity (number of !!     times that it appears in the array). !! !!     Internally, the number of times that a value appears in the array !!     is computed by using inverse ranking, counting for each rank the !!     number of values that \"collide\" to this rank, and returning this sum !!     to the locations in the original set. It uses subroutine UNIINV(3f). !! !!##OPTIONS !!     INVALS      input array !!     IMULT      array containing how often the value in INVALS !!                appears in INVALS !! !!##EXAMPLES !! !! Sample program: !! !!      program demo_occurrences !!      use M_orderpack, only : occurrences !!      ! determine how many times each value appears in an input array !!      implicit none !!      character(len=*),parameter    :: g='(*(g0,1x))' !!      character(len=20),allocatable :: strings(:) !!      integer,allocatable           :: cindx(:) !!      integer                       :: csz !!      integer                       :: i !!         ! each name appears the number of times its name represents !!         strings= [ character(len=20) ::                           & !!         & 'two  ',  'four ', 'three', 'five',   'five',           & !!         & 'two  ',  'four ', 'three', 'five',   'five',           & !!         & 'four ',  'four ', 'three', 'one  ',  'five'] !!         csz=size(strings) !!         if(allocated(cindx))deallocate(cindx) !!         allocate(cindx(csz)) !!         call occurrences(strings,cindx) !!         write(*,g)(trim(strings(i)),i=1,csz) !!         write(*,g)cindx !!      end program demo_occurrences !! !! Results: !! !!  two four three five five two four three five five four four three one five !!  2   4    3     5    5    2   4    3     5    5    4    4    3     1   5 !! !!##AUTHOR !!    Michel Olagnon, Mar 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_mulcnt ( INVALS , IMULT ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( INVALS )) :: IWRKT Integer , Dimension ( Size ( INVALS )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INVALS , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( INVALS ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( INVALS ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine real64_mulcnt Subroutine real32_mulcnt ( INVALS , IMULT ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( INVALS )) :: IWRKT Integer , Dimension ( Size ( INVALS )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INVALS , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( INVALS ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( INVALS ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine real32_mulcnt Subroutine int32_mulcnt ( INVALS , IMULT ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( INVALS )) :: IWRKT Integer , Dimension ( Size ( INVALS )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INVALS , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( INVALS ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( INVALS ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine int32_mulcnt Subroutine f_char_mulcnt ( INVALS , IMULT ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( INVALS )) :: IWRKT Integer , Dimension ( Size ( INVALS )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INVALS , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( INVALS ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( INVALS ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine f_char_mulcnt end module M_mulcnt","tags":"","loc":"sourcefile/m_mulcnt.f90.html"},{"title":"M_unipar.f90 – orderpack","text":"Contents Modules M_unipar Source Code M_unipar.f90 Source Code Module M_unipar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: unipar interface unipar module procedure real64_unipar , real32_unipar , int32_unipar !, f_char_unipar end interface unipar contains !> !!##NAME !!    prank_unique(3f) - [orderpack:RANK:PARTIAL:UNIQUE] partially ranks !!                       an array removing duplicates !! !!##SYNOPSIS !! !!     Subroutine Prank_Unique (INVALS, IRNGT, NORD) !! !!      ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!      Integer, Intent (Out)               :: IRNGT(:) !!      Integer, Intent (InOut)             :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Partially rank INVALS() up to order NORD at most, removing duplicate !!    entries. !! !!    Internally, this routine uses a pivoting strategy such as the one of !!    finding the median based on the quicksort algorithm, but we skew the !!    pivot choice to try to bring it to NORD as quickly as possible. It !!    uses two temporary arrays, where it stores the indices of the values !!    smaller than the pivot (ILOWT), and the indices of values larger !!    than the pivot that we might still need later on (IHIGT). It iterates !!    until it can bring the number of values in ILOWT to exactly NORD, and !!    then uses an insertion sort to rank this set, since it is supposedly !!    small. At all times, the NORD first values in ILOWT correspond to !!    distinct values of the input array. !! !! !!##OPTIONS !!     INVALS      array to partially sort !!     IRNGT      indices returned that point to lowest values !!     NORD       number of sorted values to determine before !!                eliminating duplicates !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_prank_unique !!    ! ranks array, removing duplicates !!    use M_orderpack, only : prank_unique !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: INVALS(:) !!    integer,allocatable :: irngt(:) !!    integer :: nord !!    ! !!    write(*,g)'If enough values are unique, will return NORD indices' !!    if(allocated(irngt))deallocate(irngt) !!    INVALS=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!    allocate(irngt(nord)) !!    call printme() !!    ! !!    !BUG!write(*,g)'If not enough values are unique, will change NORD' !!    !BUG!INVALS=[-1,0,-1,0,-1,0,-1] !!    !BUG!nord=5 !!    !BUG!if(allocated(irngt))deallocate(irngt) !!    !BUG!allocate(irngt(nord)) !!    !BUG!call printme() !!    contains !!    subroutine printme() !!       write(*,g)'ORIGINAL:',INVALS !!       write(*,g)'NUMBER OF INDICES TO SORT:',nord !!       call prank_unique(INVALS,irngt,nord) !!       write(*,g)'NUMBER OF INDICES RETURNED:',nord !!       write(*,g)'RETURNED INDICES:',irngt(:nord) !!       write(*,g)nord,'SMALLEST UNIQUE VALUES:',INVALS(irngt(:nord)) !!    end subroutine !!    end program demo_prank_unique !! !!   Results: !! !!    If enough values are unique, will return NORD indices !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF INDICES TO SORT: 5 !!    NUMBER OF INDICES RETURNED: 5 !!    RETURNED INDICES: 11 5 2 7 3 !!    5 SMALLEST UNIQUE VALUES: 1 4 5 6 7 !!    If not enough values are unique, will change NORD !!    ORIGINAL: -1 0 -1 0 -1 0 -1 !!    NUMBER OF INDICES TO SORT: 5 !!    NUMBER OF INDICES RETURNED: 2 !!    RETURNED INDICES: 1 2 !!    2 SMALLEST UNIQUE VALUES: -1 0 !! !!##AUTHOR !!    Michel Olagnon - Feb. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_unipar ( INVALS , IRNGT , NORD ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( InOut ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XWRK , XWRK1 , XMIN , XMAX , XPIV0 ! __________________________________________________________ Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) Then NORD = 1 IRNGT ( 1 ) = 1 End If Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! Do ICRS = 2 , NDON If ( INVALS ( ICRS ) == INVALS ( 1 )) Then Cycle Else If ( INVALS ( ICRS ) < INVALS ( 1 )) Then ILOWT ( 1 ) = ICRS IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = ICRS End If Exit End Do ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , 2 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! ICRS = ICRS + 1 JHIG = 1 If ( INVALS ( ICRS ) < INVALS ( IHIGT ( 1 ))) Then If ( INVALS ( ICRS ) < INVALS ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = ICRS Else If ( INVALS ( ICRS ) > INVALS ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ICRS End If ElseIf ( INVALS ( ICRS ) > INVALS ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) < INVALS ( IHIGT ( 1 ))) Then If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON JHIG = JHIG + 1 ElseIf ( INVALS ( NDON ) > INVALS ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = NDON JHIG = JHIG + 1 End If ElseIf ( INVALS ( NDON ) > INVALS ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = NDON End If ! If ( NDON <= ICRS + 1 ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT, i.e. one more than !  strictly necessary so as to be able to come out of the !  case where JLOWT would be NORD distinct values followed !  by values that are exclusively duplicates of these. ! ! If ( INVALS ( NDON ) > XPIV ) Then lowloop1 : Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( INVALS ( ICRS ) == INVALS ( ILOWT ( ILOW ))) Cycle lowloop1 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop1 ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! lowloop2 : Do ICRS = ICRS + 1 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( INVALS ( ICRS ) == INVALS ( ILOWT ( ILOW ))) Cycle lowloop2 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop2 ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIG = 0 Do ICRS = 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) /= XMIN ) then IHIG = IHIG + 1 IHIGT ( IHIG ) = IHIGT ( ICRS ) End If End Do JHIG = IHIG Else ILOW = ILOWT ( JLOW ) XMAX = INVALS ( ILOW ) Do ICRS = 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. In order to make better pivot choices, we !   decrease NORD if we already know that we don't have that !   many distinct values as a whole. ! IF ( JLOW + JHIG < NORD ) NORD = JLOW + JHIG Select Case ( NORD - JLOW ) ! ______________________________ Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) ! !   Not enough values in high part either (too many duplicates) ! Case ( 0 ) NORD = JLOW ! Case ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) ElseIf ( INVALS ( IHIGT ( 1 )) == INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 1 JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JHIG = JHIG + 1 IF ( INVALS ( IHIGT ( JHIG )) /= INVALS ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If JHIG = JHIG + 1 IF ( INVALS ( IHIGT ( JHIG )) /= INVALS ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If NORD = Min ( JLOW , NORD ) Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 lowloop3 : Do ICRS = 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then Do ILOW = 1 , JLOW If ( INVALS ( IHIGT ( ICRS )) == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop3 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW > NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do lowloop3 ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! ______________________________ ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! ______________________________ ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! ______________________________ ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) insert1 : Do ICRS = NORD + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do ILOW = 1 , NORD - 1 If ( XWRK <= INVALS ( IRNGT ( ILOW ))) Then If ( XWRK == INVALS ( IRNGT ( ILOW ))) Cycle insert1 Exit End If End Do Do IDCR = NORD - 1 , ILOW , - 1 IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do insert1 ! Return ! ! ______________________________ ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = MIN (( JLOW + IDEB ) / 2 , NORD ) IFIN = MIN ( JLOW , NORD + 1 ) ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 IFIN = JLOW JLOW = JDEB ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB lowloop4 : Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else XWRK1 = INVALS ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop4 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop4 ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else lowloop5 : Do ICRS = IDEB , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else XWRK1 = INVALS ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop5 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop5 ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! ______________________________ ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real64_unipar Subroutine real32_unipar ( INVALS , IRNGT , NORD ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( InOut ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XWRK , XWRK1 , XMIN , XMAX , XPIV0 ! __________________________________________________________ Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) Then NORD = 1 IRNGT ( 1 ) = 1 End If Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! Do ICRS = 2 , NDON If ( INVALS ( ICRS ) == INVALS ( 1 )) Then Cycle Else If ( INVALS ( ICRS ) < INVALS ( 1 )) Then ILOWT ( 1 ) = ICRS IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = ICRS End If Exit End Do ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , 2 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! ICRS = ICRS + 1 JHIG = 1 If ( INVALS ( ICRS ) < INVALS ( IHIGT ( 1 ))) Then If ( INVALS ( ICRS ) < INVALS ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = ICRS Else If ( INVALS ( ICRS ) > INVALS ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ICRS End If ElseIf ( INVALS ( ICRS ) > INVALS ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) < INVALS ( IHIGT ( 1 ))) Then If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON JHIG = JHIG + 1 ElseIf ( INVALS ( NDON ) > INVALS ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = NDON JHIG = JHIG + 1 End If ElseIf ( INVALS ( NDON ) > INVALS ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = NDON End If ! If ( NDON <= ICRS + 1 ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT, i.e. one more than !  strictly necessary so as to be able to come out of the !  case where JLOWT would be NORD distinct values followed !  by values that are exclusively duplicates of these. ! ! If ( INVALS ( NDON ) > XPIV ) Then lowloop1 : Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( INVALS ( ICRS ) == INVALS ( ILOWT ( ILOW ))) Cycle lowloop1 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop1 ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! lowloop2 : Do ICRS = ICRS + 1 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( INVALS ( ICRS ) == INVALS ( ILOWT ( ILOW ))) Cycle lowloop2 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop2 ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIG = 0 Do ICRS = 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) /= XMIN ) then IHIG = IHIG + 1 IHIGT ( IHIG ) = IHIGT ( ICRS ) End If End Do JHIG = IHIG Else ILOW = ILOWT ( JLOW ) XMAX = INVALS ( ILOW ) Do ICRS = 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. In order to make better pivot choices, we !   decrease NORD if we already know that we don't have that !   many distinct values as a whole. ! IF ( JLOW + JHIG < NORD ) NORD = JLOW + JHIG Select Case ( NORD - JLOW ) ! ______________________________ Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) ! !   Not enough values in high part either (too many duplicates) ! Case ( 0 ) NORD = JLOW ! Case ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) ElseIf ( INVALS ( IHIGT ( 1 )) == INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 1 JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JHIG = JHIG + 1 IF ( INVALS ( IHIGT ( JHIG )) /= INVALS ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If JHIG = JHIG + 1 IF ( INVALS ( IHIGT ( JHIG )) /= INVALS ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If NORD = Min ( JLOW , NORD ) Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 lowloop3 : Do ICRS = 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then Do ILOW = 1 , JLOW If ( INVALS ( IHIGT ( ICRS )) == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop3 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW > NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do lowloop3 ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! ______________________________ ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! ______________________________ ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! ______________________________ ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) insert1 : Do ICRS = NORD + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do ILOW = 1 , NORD - 1 If ( XWRK <= INVALS ( IRNGT ( ILOW ))) Then If ( XWRK == INVALS ( IRNGT ( ILOW ))) Cycle insert1 Exit End If End Do Do IDCR = NORD - 1 , ILOW , - 1 IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do insert1 ! Return ! ! ______________________________ ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = MIN (( JLOW + IDEB ) / 2 , NORD ) IFIN = MIN ( JLOW , NORD + 1 ) ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 IFIN = JLOW JLOW = JDEB ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB lowloop4 : Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else XWRK1 = INVALS ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop4 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop4 ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else lowloop5 : Do ICRS = IDEB , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else XWRK1 = INVALS ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop5 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop5 ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! ______________________________ ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real32_unipar Subroutine int32_unipar ( INVALS , IRNGT , NORD ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( InOut ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XWRK , XWRK1 , XMIN , XMAX , XPIV0 ! __________________________________________________________ Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) Then NORD = 1 IRNGT ( 1 ) = 1 End If Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! Do ICRS = 2 , NDON If ( INVALS ( ICRS ) == INVALS ( 1 )) Then Cycle Else If ( INVALS ( ICRS ) < INVALS ( 1 )) Then ILOWT ( 1 ) = ICRS IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = ICRS End If Exit End Do ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , 2 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! ICRS = ICRS + 1 JHIG = 1 If ( INVALS ( ICRS ) < INVALS ( IHIGT ( 1 ))) Then If ( INVALS ( ICRS ) < INVALS ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = ICRS Else If ( INVALS ( ICRS ) > INVALS ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ICRS End If ElseIf ( INVALS ( ICRS ) > INVALS ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) < INVALS ( IHIGT ( 1 ))) Then If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON JHIG = JHIG + 1 ElseIf ( INVALS ( NDON ) > INVALS ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = NDON JHIG = JHIG + 1 End If ElseIf ( INVALS ( NDON ) > INVALS ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = NDON End If ! If ( NDON <= ICRS + 1 ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT, i.e. one more than !  strictly necessary so as to be able to come out of the !  case where JLOWT would be NORD distinct values followed !  by values that are exclusively duplicates of these. ! ! If ( INVALS ( NDON ) > XPIV ) Then lowloop1 : Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( INVALS ( ICRS ) == INVALS ( ILOWT ( ILOW ))) Cycle lowloop1 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop1 ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! lowloop2 : Do ICRS = ICRS + 1 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( INVALS ( ICRS ) == INVALS ( ILOWT ( ILOW ))) Cycle lowloop2 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop2 ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIG = 0 Do ICRS = 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) /= XMIN ) then IHIG = IHIG + 1 IHIGT ( IHIG ) = IHIGT ( ICRS ) End If End Do JHIG = IHIG Else ILOW = ILOWT ( JLOW ) XMAX = INVALS ( ILOW ) Do ICRS = 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. In order to make better pivot choices, we !   decrease NORD if we already know that we don't have that !   many distinct values as a whole. ! IF ( JLOW + JHIG < NORD ) NORD = JLOW + JHIG Select Case ( NORD - JLOW ) ! ______________________________ Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) ! !   Not enough values in high part either (too many duplicates) ! Case ( 0 ) NORD = JLOW ! Case ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) ElseIf ( INVALS ( IHIGT ( 1 )) == INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 1 JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JHIG = JHIG + 1 IF ( INVALS ( IHIGT ( JHIG )) /= INVALS ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If JHIG = JHIG + 1 IF ( INVALS ( IHIGT ( JHIG )) /= INVALS ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If NORD = Min ( JLOW , NORD ) Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 lowloop3 : Do ICRS = 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then Do ILOW = 1 , JLOW If ( INVALS ( IHIGT ( ICRS )) == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop3 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW > NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do lowloop3 ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! ______________________________ ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! ______________________________ ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! ______________________________ ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) insert1 : Do ICRS = NORD + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do ILOW = 1 , NORD - 1 If ( XWRK <= INVALS ( IRNGT ( ILOW ))) Then If ( XWRK == INVALS ( IRNGT ( ILOW ))) Cycle insert1 Exit End If End Do Do IDCR = NORD - 1 , ILOW , - 1 IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do insert1 ! Return ! ! ______________________________ ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = MIN (( JLOW + IDEB ) / 2 , NORD ) IFIN = MIN ( JLOW , NORD + 1 ) ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 IFIN = JLOW JLOW = JDEB ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB lowloop4 : Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else XWRK1 = INVALS ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop4 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop4 ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else lowloop5 : Do ICRS = IDEB , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else XWRK1 = INVALS ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == INVALS ( ILOWT ( ILOW ))) & Cycle lowloop5 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop5 ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! ______________________________ ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine int32_unipar end module M_unipar","tags":"","loc":"sourcefile/m_unipar.f90.html"},{"title":"M_median.f90 – orderpack","text":"Contents Modules M_median Source Code M_median.f90 Source Code Module M_median use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: median interface median module procedure real64_median , real32_median , int32_median end interface median contains !> !!##NAME !!    median(3f) - [orderpack:MEDIAN] Calculates median VALUE. If !!                 number of data is even, returns average of the two !!                 \"medians\". !! !!##SYNOPSIS !! !!     Function Median (INVALS) !! !!      ${TYPE} (Kind=${KIND}), Intent (In) :: INVALS(:) !!      ${TYPE} (Kind=${KIND})              :: MEDIAN !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    MEDIAN(3f) calculates the median value of the array INVALS(). !!    It is a modified version of VALMED() that provides the average between the !!    two middle values in the case Size(INVALS) is even. !! !!    This routine uses a pivoting strategy similar to the method  of finding !!    the median based on the Quick-sort algorithm, but we skew the pivot !!    choice to try to bring it to NORD as fast as possible. It uses two !!    temporary arrays, where it stores the indices of the values smaller !!    than the pivot (ILOWT), and the indices of values larger than the !!    pivot that we might still need later on (IHIGT). It iterates until !!    it can bring the number of values in ILOWT to exactly NORD, and then !!    finds the maximum of this set. !! !!##OPTIONS !!     INVALS      array to determine the median value of. !! !!##RETURNS !!     MEDIAN     median value. If INVALS contains an even number !!                of elements the value is the average of the !!                two \"medians\". !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_median !!    ! calculate median value !!    use M_orderpack, only : median !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !! !!       write(*,g) 'real   ',median(& !!       [80.0,70.0,20.0,10.0,1000.0] ) !! !!       write(*,g) 'integer',median(& !!       [11, 22, 33, 44, 55, 66, 77, 88] ) !! !!       write(*,g) 'double ',median(& !!       [11.0d0,22.0d0,33.0d0,66.0d0,77.0d0,88.0d0]) !! !!    end program demo_median !! !!   Results: !! !!    real    70.00000 !!    integer 49 !!    double  49.50000000000000 !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Function real64_median ( INVALS ) Result ( median ) Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Real ( Kind = real64 ) :: median ! __________________________________________________________ Real ( Kind = real64 ), Dimension ( SIZE ( INVALS )) :: XLOWT , XHIGT Real ( Kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX !! Logical :: IFODD Integer :: NDON , JHIG , JLOW , IHIG , NORD Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = NDON / 2 + 1 IFODD = ( 2 * INTH == NDON + 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 3 ) Then If ( NDON > 0 ) median = 0.5 * ( INVALS ( 1 ) + INVALS ( NDON )) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then XLOWT ( 1 ) = INVALS ( 2 ) XHIGT ( 1 ) = INVALS ( 1 ) Else XLOWT ( 1 ) = INVALS ( 1 ) XHIGT ( 1 ) = INVALS ( 2 ) End If ! ! If ( INVALS ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( 3 ) Else XHIGT ( 1 ) = INVALS ( 3 ) End If Else XHIGT ( 2 ) = INVALS ( 3 ) End If ! If ( NDON < 4 ) Then ! 3 values median = XHIGT ( 1 ) Return End If ! If ( INVALS ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( NDON ) Else XHIGT ( 1 ) = INVALS ( NDON ) End If Else If ( INVALS ( NDON ) < XHIGT ( 2 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = INVALS ( NDON ) Else XHIGT ( 3 ) = INVALS ( NDON ) End If End If ! If ( NDON < 5 ) Then ! 4 values median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 3 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 2 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 1 ) - XLOWT ( 1 )) / 3.0 End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst-case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XMIN Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IF ( IFODD ) THEN JHIG = JLOW - INTH + 1 Else JHIG = JLOW - INTH + 2 Endif XHIGT ( 1 ) = XLOWT ( 1 ) Do ICRS = 2 , JHIG XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK End Do ! Do ICRS = JHIG + 1 , JLOW If ( XLOWT ( ICRS ) > XHIGT ( 1 )) Then XWRK = XLOWT ( ICRS ) Do IDCR = 2 , JHIG If ( XWRK >= XHIGT ( IDCR )) Then XHIGT ( IDCR - 1 ) = XHIGT ( IDCR ) else exit endif End Do XHIGT ( IDCR - 1 ) = XWRK End If End Do ! IF ( IFODD ) THEN median = XHIGT ( 1 ) Else median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Endif Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! if ( IFODD ) then median = MAXVAL ( XLOWT ( 1 : INTH )) else XWRK = MAX ( XLOWT ( 1 ), XLOWT ( 2 )) XWRK1 = MIN ( XLOWT ( 1 ), XLOWT ( 2 )) DO ICRS = 3 , INTH IF ( XLOWT ( ICRS ) > XWRK1 ) THEN IF ( XLOWT ( ICRS ) > XWRK ) THEN XWRK1 = XWRK XWRK = XLOWT ( ICRS ) Else XWRK1 = XLOWT ( ICRS ) ENDIF ENDIF ENDDO median = 0.5 * ( XWRK + XWRK1 ) endif Return ! End Function real64_median Function real32_median ( INVALS ) Result ( median ) Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Real ( Kind = real32 ) :: median ! __________________________________________________________ Real ( Kind = real32 ), Dimension ( SIZE ( INVALS )) :: XLOWT , XHIGT Real ( Kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX !! Logical :: IFODD Integer :: NDON , JHIG , JLOW , IHIG , NORD Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = NDON / 2 + 1 IFODD = ( 2 * INTH == NDON + 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 3 ) Then If ( NDON > 0 ) median = 0.5 * ( INVALS ( 1 ) + INVALS ( NDON )) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then XLOWT ( 1 ) = INVALS ( 2 ) XHIGT ( 1 ) = INVALS ( 1 ) Else XLOWT ( 1 ) = INVALS ( 1 ) XHIGT ( 1 ) = INVALS ( 2 ) End If ! ! If ( INVALS ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( 3 ) Else XHIGT ( 1 ) = INVALS ( 3 ) End If Else XHIGT ( 2 ) = INVALS ( 3 ) End If ! If ( NDON < 4 ) Then ! 3 values median = XHIGT ( 1 ) Return End If ! If ( INVALS ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( NDON ) Else XHIGT ( 1 ) = INVALS ( NDON ) End If Else If ( INVALS ( NDON ) < XHIGT ( 2 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = INVALS ( NDON ) Else XHIGT ( 3 ) = INVALS ( NDON ) End If End If ! If ( NDON < 5 ) Then ! 4 values median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 3 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 2 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 1 ) - XLOWT ( 1 )) / 3.0 End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst-case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XMIN Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IF ( IFODD ) THEN JHIG = JLOW - INTH + 1 Else JHIG = JLOW - INTH + 2 Endif XHIGT ( 1 ) = XLOWT ( 1 ) Do ICRS = 2 , JHIG XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK End Do ! Do ICRS = JHIG + 1 , JLOW If ( XLOWT ( ICRS ) > XHIGT ( 1 )) Then XWRK = XLOWT ( ICRS ) Do IDCR = 2 , JHIG If ( XWRK >= XHIGT ( IDCR )) Then XHIGT ( IDCR - 1 ) = XHIGT ( IDCR ) else exit endif End Do XHIGT ( IDCR - 1 ) = XWRK End If End Do ! IF ( IFODD ) THEN median = XHIGT ( 1 ) Else median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Endif Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! if ( IFODD ) then median = MAXVAL ( XLOWT ( 1 : INTH )) else XWRK = MAX ( XLOWT ( 1 ), XLOWT ( 2 )) XWRK1 = MIN ( XLOWT ( 1 ), XLOWT ( 2 )) DO ICRS = 3 , INTH IF ( XLOWT ( ICRS ) > XWRK1 ) THEN IF ( XLOWT ( ICRS ) > XWRK ) THEN XWRK1 = XWRK XWRK = XLOWT ( ICRS ) Else XWRK1 = XLOWT ( ICRS ) ENDIF ENDIF ENDDO median = 0.5 * ( XWRK + XWRK1 ) endif Return ! End Function real32_median Function int32_median ( INVALS ) Result ( median ) Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer ( Kind = int32 ) :: median ! __________________________________________________________ Integer ( Kind = int32 ), Dimension ( SIZE ( INVALS )) :: XLOWT , XHIGT Integer ( Kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX !! Logical :: IFODD Integer :: NDON , JHIG , JLOW , IHIG , NORD Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = NDON / 2 + 1 IFODD = ( 2 * INTH == NDON + 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 3 ) Then If ( NDON > 0 ) median = 0.5 * ( INVALS ( 1 ) + INVALS ( NDON )) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then XLOWT ( 1 ) = INVALS ( 2 ) XHIGT ( 1 ) = INVALS ( 1 ) Else XLOWT ( 1 ) = INVALS ( 1 ) XHIGT ( 1 ) = INVALS ( 2 ) End If ! ! If ( INVALS ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( 3 ) Else XHIGT ( 1 ) = INVALS ( 3 ) End If Else XHIGT ( 2 ) = INVALS ( 3 ) End If ! If ( NDON < 4 ) Then ! 3 values median = XHIGT ( 1 ) Return End If ! If ( INVALS ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( NDON ) Else XHIGT ( 1 ) = INVALS ( NDON ) End If Else If ( INVALS ( NDON ) < XHIGT ( 2 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = INVALS ( NDON ) Else XHIGT ( 3 ) = INVALS ( NDON ) End If End If ! If ( NDON < 5 ) Then ! 4 values median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 3 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 2 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 1 ) - XLOWT ( 1 )) / 3.0 End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst-case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XMIN Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IF ( IFODD ) THEN JHIG = JLOW - INTH + 1 Else JHIG = JLOW - INTH + 2 Endif XHIGT ( 1 ) = XLOWT ( 1 ) Do ICRS = 2 , JHIG XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK End Do ! Do ICRS = JHIG + 1 , JLOW If ( XLOWT ( ICRS ) > XHIGT ( 1 )) Then XWRK = XLOWT ( ICRS ) Do IDCR = 2 , JHIG If ( XWRK >= XHIGT ( IDCR )) Then XHIGT ( IDCR - 1 ) = XHIGT ( IDCR ) else exit endif End Do XHIGT ( IDCR - 1 ) = XWRK End If End Do ! IF ( IFODD ) THEN median = XHIGT ( 1 ) Else median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Endif Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! if ( IFODD ) then median = MAXVAL ( XLOWT ( 1 : INTH )) else XWRK = MAX ( XLOWT ( 1 ), XLOWT ( 2 )) XWRK1 = MIN ( XLOWT ( 1 ), XLOWT ( 2 )) DO ICRS = 3 , INTH IF ( XLOWT ( ICRS ) > XWRK1 ) THEN IF ( XLOWT ( ICRS ) > XWRK ) THEN XWRK1 = XWRK XWRK = XLOWT ( ICRS ) Else XWRK1 = XLOWT ( ICRS ) ENDIF ENDIF ENDDO median = 0.5 * ( XWRK + XWRK1 ) endif Return ! End Function int32_median end module M_median","tags":"","loc":"sourcefile/m_median.f90.html"},{"title":"M_refsor.f90 – orderpack","text":"Contents Modules M_refsor Source Code M_refsor.f90 Source Code Module M_refsor use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: refsor private :: real64_inssor , real32_inssor , int32_inssor , f_char_inssor interface refsor module procedure real64_refsor , real32_refsor , int32_refsor , f_char_refsor end interface refsor contains !> !!##NAME !!    sort(3f) - [orderpack:SORT] Sorts array into ascending order !!                 (Quicksort) !! !!##SYNOPSIS !! !!     Subroutine Sort (INOUTVALS) !! !!       ${TYPE} (kind=${KIND}), Intent (InOut) :: INOUTVALS(:) !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Sorts INOUTVALS into ascending order (Quicksort) !! !!    This version is not optimized for performance, and is thus not as !!    difficult to read as some other ones. !! !!    Internally, This subroutine uses Quick-sort in a recursive !!    implementation, and insertion sort for the last steps with small !!    subsets.  It does not use any work array. !! !!    The Quick-sort !!    chooses a \"pivot\" in the set, and explores the array from !!    both ends, looking for a value > pivot with the increasing index, !!    for a value <= pivot with the decreasing index, and swapping them !!    when it has found one of each. The array is then subdivided in !!    two subsets: !! !!        { values <= pivot} {pivot} {values > pivot} !! !!    It then recursively the procedure to sort each subset.  When the !!    size of the subarray is small enough, it switches to an insertion !!    sort that is faster for very small sets. !! !!##OPTIONS !!     INOUTVALS      array to sort !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_sort !!    ! sort array in ascending order !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_orderpack, only : sort !!    implicit none !!    ! an insertion sort is very efficient for very small arrays !!    ! but generally slower than methods like quicksort and mergesort. !!    real(kind=real64) :: valsd(2000) !!    integer           :: i !!       call random_seed() !!       call random_number(valsd) !!       valsd=valsd*1000000.0-500000.0 !!       call sort(valsd) !!       do i=1,size(valsd)-1 !!          if (valsd(i+1).lt.valsd(i))then !!             write(*,*)'not sorted' !!             stop 3 !!          endif !!       enddo !!       write(*,*)'random arrays are now sorted' !!    end program demo_sort !! !!   Results: !! !!     random arrays are now sorted !! !!##AUTHOR !!    Michel Olagnon - Apr. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_refsor ( INOUTVALS ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Call real64_subsor ( INOUTVALS , 1 , Size ( INOUTVALS )) Call real64_inssor ( INOUTVALS ) End Subroutine real64_refsor Recursive Subroutine real64_subsor ( INOUTVALS , IDEB1 , IFIN1 ) !  Sorts INOUTVALS from IDEB1 to IFIN1 ! __________________________________________________________ Real ( kind = real64 ), dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If If ( INOUTVALS ( IMIL ) > INOUTVALS ( IFIN )) Then XWRK = INOUTVALS ( IFIN ) INOUTVALS ( IFIN ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If End If XPIV = INOUTVALS ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INOUTVALS (IFIN) > XPIV ! Exit ECH2 ! End If If ( INOUTVALS ( ICRS ) > XPIV ) Exit End Do Do If ( INOUTVALS ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = INOUTVALS ( IDCR ) INOUTVALS ( IDCR ) = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call real64_subsor ( INOUTVALS , IDEB1 , ICRS - 1 ) Call real64_subsor ( INOUTVALS , IDCR , IFIN1 ) End If End Subroutine real64_subsor Subroutine real64_inssor ( INOUTVALS ) !  Sorts INOUTVALS into increasing order (Insertion sort) ! __________________________________________________________ Real ( kind = real64 ), dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Integer :: ICRS , IDCR Real ( kind = real64 ) :: XWRK ! Do ICRS = 2 , Size ( INOUTVALS ) XWRK = INOUTVALS ( ICRS ) If ( XWRK >= INOUTVALS ( ICRS - 1 )) Cycle INOUTVALS ( ICRS ) = INOUTVALS ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! End Subroutine real64_inssor Subroutine real32_refsor ( INOUTVALS ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Call real32_subsor ( INOUTVALS , 1 , Size ( INOUTVALS )) Call real32_inssor ( INOUTVALS ) End Subroutine real32_refsor Recursive Subroutine real32_subsor ( INOUTVALS , IDEB1 , IFIN1 ) !  Sorts INOUTVALS from IDEB1 to IFIN1 ! __________________________________________________________ Real ( kind = real32 ), dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If If ( INOUTVALS ( IMIL ) > INOUTVALS ( IFIN )) Then XWRK = INOUTVALS ( IFIN ) INOUTVALS ( IFIN ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If End If XPIV = INOUTVALS ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INOUTVALS (IFIN) > XPIV ! Exit ECH2 ! End If If ( INOUTVALS ( ICRS ) > XPIV ) Exit End Do Do If ( INOUTVALS ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = INOUTVALS ( IDCR ) INOUTVALS ( IDCR ) = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call real32_subsor ( INOUTVALS , IDEB1 , ICRS - 1 ) Call real32_subsor ( INOUTVALS , IDCR , IFIN1 ) End If End Subroutine real32_subsor Subroutine real32_inssor ( INOUTVALS ) !  Sorts INOUTVALS into increasing order (Insertion sort) ! __________________________________________________________ Real ( kind = real32 ), dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Integer :: ICRS , IDCR Real ( kind = real32 ) :: XWRK ! Do ICRS = 2 , Size ( INOUTVALS ) XWRK = INOUTVALS ( ICRS ) If ( XWRK >= INOUTVALS ( ICRS - 1 )) Cycle INOUTVALS ( ICRS ) = INOUTVALS ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! End Subroutine real32_inssor Subroutine int32_refsor ( INOUTVALS ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Call int32_subsor ( INOUTVALS , 1 , Size ( INOUTVALS )) Call int32_inssor ( INOUTVALS ) End Subroutine int32_refsor Recursive Subroutine int32_subsor ( INOUTVALS , IDEB1 , IFIN1 ) !  Sorts INOUTVALS from IDEB1 to IFIN1 ! __________________________________________________________ Integer ( kind = int32 ), dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If If ( INOUTVALS ( IMIL ) > INOUTVALS ( IFIN )) Then XWRK = INOUTVALS ( IFIN ) INOUTVALS ( IFIN ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If End If XPIV = INOUTVALS ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INOUTVALS (IFIN) > XPIV ! Exit ECH2 ! End If If ( INOUTVALS ( ICRS ) > XPIV ) Exit End Do Do If ( INOUTVALS ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = INOUTVALS ( IDCR ) INOUTVALS ( IDCR ) = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call int32_subsor ( INOUTVALS , IDEB1 , ICRS - 1 ) Call int32_subsor ( INOUTVALS , IDCR , IFIN1 ) End If End Subroutine int32_subsor Subroutine int32_inssor ( INOUTVALS ) !  Sorts INOUTVALS into increasing order (Insertion sort) ! __________________________________________________________ Integer ( kind = int32 ), dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Integer :: ICRS , IDCR Integer ( kind = int32 ) :: XWRK ! Do ICRS = 2 , Size ( INOUTVALS ) XWRK = INOUTVALS ( ICRS ) If ( XWRK >= INOUTVALS ( ICRS - 1 )) Cycle INOUTVALS ( ICRS ) = INOUTVALS ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! End Subroutine int32_inssor Subroutine f_char_refsor ( INOUTVALS ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Call f_char_subsor ( INOUTVALS , 1 , Size ( INOUTVALS )) Call f_char_inssor ( INOUTVALS ) End Subroutine f_char_refsor Recursive Subroutine f_char_subsor ( INOUTVALS , IDEB1 , IFIN1 ) !  Sorts INOUTVALS from IDEB1 to IFIN1 ! __________________________________________________________ character ( kind = f_char , len =* ), dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ character ( kind = f_char , len = len ( INOUTVALS )) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If If ( INOUTVALS ( IMIL ) > INOUTVALS ( IFIN )) Then XWRK = INOUTVALS ( IFIN ) INOUTVALS ( IFIN ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK If ( INOUTVALS ( IMIL ) < INOUTVALS ( IDEB )) Then XWRK = INOUTVALS ( IDEB ) INOUTVALS ( IDEB ) = INOUTVALS ( IMIL ) INOUTVALS ( IMIL ) = XWRK End If End If XPIV = INOUTVALS ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INOUTVALS (IFIN) > XPIV ! Exit ECH2 ! End If If ( INOUTVALS ( ICRS ) > XPIV ) Exit End Do Do If ( INOUTVALS ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = INOUTVALS ( IDCR ) INOUTVALS ( IDCR ) = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call f_char_subsor ( INOUTVALS , IDEB1 , ICRS - 1 ) Call f_char_subsor ( INOUTVALS , IDCR , IFIN1 ) End If End Subroutine f_char_subsor Subroutine f_char_inssor ( INOUTVALS ) !  Sorts INOUTVALS into increasing order (Insertion sort) ! __________________________________________________________ character ( kind = f_char , len =* ), dimension (:), Intent ( InOut ) :: INOUTVALS ! __________________________________________________________ Integer :: ICRS , IDCR character ( kind = f_char , len = len ( INOUTVALS )) :: XWRK ! Do ICRS = 2 , Size ( INOUTVALS ) XWRK = INOUTVALS ( ICRS ) If ( XWRK >= INOUTVALS ( ICRS - 1 )) Cycle INOUTVALS ( ICRS ) = INOUTVALS ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! End Subroutine f_char_inssor end module M_refsor","tags":"","loc":"sourcefile/m_refsor.f90.html"},{"title":"M_indmed.f90 – orderpack","text":"Contents Modules M_indmed Source Code M_indmed.f90 Source Code Module M_indmed use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: indmed Integer , Allocatable , Dimension (:), Private , Save :: IDONT interface indmed module procedure real64_indmed , real32_indmed , int32_indmed , f_char_indmed end interface indmed contains !> !!##NAME !!    medianloc(3f) - [orderpack:MEDIAN] Returns median value's INDEX. !! !!##SYNOPSIS !! !!     Subroutine MedianLoc (INVALS, OUTORD) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: OUTORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    MEDIANLOC(3f) Returns the index of the median (((Size(INVALS)+1))/2&#94;th value). !! !! !!    Internally, MEDIANLOC(3f) Finds the index of the median of the array !!    INVALS() using the recursive procedure described in Knuth, The Art of !!    Computer Programming, vol. 3, 5.3.3. !! !!    This procedure is linear in time, and does not require to be able !!    to interpolate in the set as the one used in INDNTH(3f), which can !!    also be used to calculate a median. It also has better worst-case !!    behavior than INDNTH(3f), but is about 10% slower on average for !!    random uniformly distributed values. !! !!##OPTIONS !!     INVALS     array to find the median value of. !!     OUTORD     index of the median value. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_medianloc !!    ! return index of median value !!    use M_orderpack, only : medianloc !!    implicit none !!    real,allocatable :: INVALS(:) !!    character(len=:),allocatable :: cdont(:) !!    character(len=*),parameter :: fmt='(i5,t11,g0)' !!    integer :: ii !!       write(*,*) 'location  median' !! !!       INVALS=[80.0,70.0,20.0,10.0,1000.0] !!       call medianloc(INVALS,ii) !!       write(*,fmt) ii,INVALS(ii) !!       ! !!       INVALS=[11, 22, 33, 44, 55, 66, 77, 88] !!       call medianloc(INVALS,ii) !!       write(*,fmt) ii,INVALS(ii) !!       ! !!       INVALS=[11.0d0,77.0d0,22.0d0,66.0d0,33.0d0,88.0d0] !!       call medianloc(INVALS,ii) !!       write(*,fmt) ii,INVALS(ii) !!       ! !!       cdont=[character(len=20) :: 'apple','bee','cherry','duck',& !!               'elephant','finger','goose','h','insect','j'] !!       call medianloc(cdont,ii) !!       write(*,fmt) ii,cdont(ii) !!       ! !!    end program demo_medianloc !! !!   Results: !! !!     location  median !!        2     70.00000 !!        4     44.00000 !!        5     33.00000 !!        5     elephant !! !!##AUTHOR !!    Michel Olagnon, 2000-2012 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_indmed ( INVALS , OUTORD ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( Out ) :: OUTORD ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( INVALS ))) Do IDON = 1 , SIZE ( INVALS ) IDONT ( IDON ) = IDON End Do ! Call real64_med ( INVALS , IDONT , OUTORD ) ! Deallocate ( IDONT ) End Subroutine real64_indmed Recursive Subroutine real64_med ( XDATT , IDATT , ires_med ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! Real ( kind = real64 ), Parameter :: XHUGE = - HUGE ( XDATT ) Real ( kind = real64 ) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call real64_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine real64_med Subroutine real32_indmed ( INVALS , OUTORD ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( Out ) :: OUTORD ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( INVALS ))) Do IDON = 1 , SIZE ( INVALS ) IDONT ( IDON ) = IDON End Do ! Call real32_med ( INVALS , IDONT , OUTORD ) ! Deallocate ( IDONT ) End Subroutine real32_indmed Recursive Subroutine real32_med ( XDATT , IDATT , ires_med ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! Real ( kind = real32 ), Parameter :: XHUGE = - HUGE ( XDATT ) Real ( kind = real32 ) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call real32_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine real32_med Subroutine int32_indmed ( INVALS , OUTORD ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( Out ) :: OUTORD ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( INVALS ))) Do IDON = 1 , SIZE ( INVALS ) IDONT ( IDON ) = IDON End Do ! Call int32_med ( INVALS , IDONT , OUTORD ) ! Deallocate ( IDONT ) End Subroutine int32_indmed Recursive Subroutine int32_med ( XDATT , IDATT , ires_med ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! Integer ( kind = int32 ), Parameter :: XHUGE = - HUGE ( XDATT ) Integer ( kind = int32 ) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call int32_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine int32_med Subroutine f_char_indmed ( INVALS , OUTORD ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Intent ( Out ) :: OUTORD ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( INVALS ))) Do IDON = 1 , SIZE ( INVALS ) IDONT ( IDON ) = IDON End Do ! Call f_char_med ( INVALS , IDONT , OUTORD ) ! Deallocate ( IDONT ) End Subroutine f_char_indmed Recursive Subroutine f_char_med ( XDATT , IDATT , ires_med ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! character ( kind = f_char , len = len ( XDATT )) :: XHUGE character ( kind = f_char , len = len ( XDATT )) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! XHUGE = repeat ( char ( 0 ), len ( xdatt )) NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call f_char_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine f_char_med end module M_indmed","tags":"","loc":"sourcefile/m_indmed.f90.html"},{"title":"M_mrgrnk.f90 – orderpack","text":"Contents Modules M_mrgrnk Source Code M_mrgrnk.f90 Source Code Module M_mrgrnk use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: mrgrnk interface mrgrnk module procedure real64_mrgrnk , real32_mrgrnk , int32_mrgrnk , f_char_mrgrnk end interface mrgrnk contains !> !!##NAME !!    rank(3f) - [orderpack:RANK] produces an INDEX that sorts an input !!               array (optimized merge-sort) !! !!##SYNOPSIS !! !!     Subroutine Rank (INVALS, IRNGT) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IRNGT(:) !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!     RANK(3f) ranks an input array; i.e. it produces an index of the input !!     array elements that can order the input array in ascending order. !! !!     The ranks can be used to sort the input array, or other associated arrays !!     or components of user types. !! !!     Internally, it uses an optimized and modified version of merge-sort. !!     For performance reasons, the first two passes are taken out of the !!     standard loop, and use dedicated coding. !! !!##OPTIONS !!     INVALS      The array to sort !!     IRNGT      The rank index returned !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rank !!    ! create an index that can order an array in ascending order !!    use M_orderpack, only : rank !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,parameter             :: dp=kind(0.0d0) !!    integer,parameter             :: isz=10000 !!    real(kind=dp)                 :: dd(isz) !!    real(kind=dp)                 :: pp !!    integer                       :: indx(isz) !!    integer                       :: i,j,k !!    character(len=:),allocatable  :: strings(:) !!    integer,allocatable           :: cindx(:) !!       ! make some random numbers !!       call random_seed() !!       call random_number(dd) !!       dd=dd-0.50_dp !!       k=int(log(huge(0.0_dp))/log(2.0_dp))-1 !!       do i=1,isz !!          call random_number(pp) !!          j=floor((k+1)*pp) !!          dd(i)=dd(i)*(2.0_dp**j) !!       enddo !!       ! rank the numeric data !!       call rank(dd,indx) !!       ! check order !!       do i=1,isz-1 !!          if(dd(indx(i)).gt.dd(indx(i+1)))then !!             write(*,g)'ERROR: data not sorted i=',i,'index=',indx(i), & !!             & 'values ',dd(indx(i)),dd(indx(i+1)) !!             stop 1 !!          endif !!       enddo !!       ! sort data using rank values !!       dd=dd(indx) !!       write(*,g)'sorted ',isz,'values' !!       write(*,g)'from',dd(1),'to',dd(isz) !!       write(*,*)minval(dd).eq.dd(1) !!       write(*,*)maxval(dd).eq.dd(isz) !!       write(*,*)minloc(dd).eq.1 !!       write(*,*)maxloc(dd).eq.isz !!       ! do a character sort !!       strings= [ character(len=20) ::                               & !!       & 'red',    'green', 'blue', 'yellow', 'orange',   'black', & !!       & 'white',  'brown', 'gray', 'cyan',   'magenta',           & !!       & 'purple'] !!       if(allocated(cindx))deallocate(cindx);allocate(cindx(size(strings))) !! !!       write(*,'(a,8(a:,\",\"))')'BEFORE ',& !!               & (trim(strings(i)),i=1,size(strings)) !! !!       call rank(strings,cindx) !! !!       write(*,'(a,8(a:,\",\"))')'SORTED ',& !!               & (trim(strings(cindx(i))),i=1,size(strings)) !! !!       strings=strings(cindx) ! sort the array using the rank index !! !!       do i=1,size(strings)-1 !!          if(strings(i).gt.strings(i+1))then !!             write(*,*)'Error in sorting strings a-z' !!          endif !!       enddo !!    end program demo_rank !! !!   Results: !! !!    sorted  10000 values !!    from -.4206770472235745E+308 to .3500810518521505E+308 !!     T !!     T !!     T !!     T !!    BEFORE red,green,blue,yellow,orange,black,white,brown, !!    gray,cyan,magenta,purple !!    SORTED black,blue,brown,cyan,gray,green,magenta,orange, !!    purple,red,white,yellow !! !!##AUTHOR !!    Michel Olagnon, 2000-2012 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_mrgrnk ( INVALS , IRNGT ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Real ( kind = real64 ) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) <= INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (INVALS(IRNGT(JINDA)) <= INVALS(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine real64_mrgrnk Subroutine real32_mrgrnk ( INVALS , IRNGT ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Real ( kind = real32 ) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) <= INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (INVALS(IRNGT(JINDA)) <= INVALS(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine real32_mrgrnk Subroutine int32_mrgrnk ( INVALS , IRNGT ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Integer ( kind = int32 ) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) <= INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (INVALS(IRNGT(JINDA)) <= INVALS(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine int32_mrgrnk Subroutine f_char_mrgrnk ( INVALS , IRNGT ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ character ( kind = f_char , len = len ( INVALS )) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) <= INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (INVALS(IRNGT(JINDA)) <= INVALS(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine f_char_mrgrnk end module M_mrgrnk","tags":"","loc":"sourcefile/m_mrgrnk.f90.html"},{"title":"M_valmed.f90 – orderpack","text":"Contents Modules M_valmed Source Code M_valmed.f90 Source Code Module M_valmed use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: valmed interface valmed module procedure real64_valmed , real32_valmed , int32_valmed end interface valmed contains !> !!##NAME !!    medianval(3f) - [orderpack:MEDIAN] Returns median VALUE. !! !!##SYNOPSIS !! !!     Recursive Function MedianVal (INVALS) Result (RES_MED) !! !!       ${TYPE} (kind=${KIND}),  Intent (In) :: INVALS(:) !!       ${TYPE} (kind=${KIND})               :: RES_MED !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !! !!    Finds out and returns the median (((Size(INVALS)+1))/2&#94;th value) !!    of INVALS. !! !!    Internally, it uses the recursive procedure described in Knuth, !!    The Art of Computer Programming, vol. 3, 5.3.3 . !! !!    The procedure is linear in time, and does not require to be able !!    to interpolate in the set as the one used in VALNTH/INDNTH. It also !!    has better worst case behavior than VALNTH/INDNTH, and is about 20% !!    faster in average for random uniformly distributed values. !! !!##OPTIONS !!     INVALS      input array !! !!##RETURNS !!     RES_MED    the median value of the array INVALS !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_medianval !!    ! return median value !!    use M_orderpack, only : medianval !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!       write(*,g)'real   ',& !!       medianval( [80.0,70.0,20.0,10.0,1000.0] ) !!       write(*,g)'integer',& !!       medianval( [11, 22, 33, 44, 55, 66, 77, 88] ) !!       write(*,g)'double ',& !!       medianval( [11.0d0, 22.0d0, 33.0d0, 66.0d0, 77.0d0, 88.0d0] ) !!    end program demo_medianval !! !!   Results: !! !!    real    70.00000 !!    integer 44 !!    double  33.00000000000000 !! !!##AUTHOR !!    Michel Olagnon, 2000-2012 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Recursive Function real64_valmed ( INVALS ) Result ( res_med ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Real ( kind = real64 ) :: res_med ! __________________________________________________________ Real ( kind = real64 ), Parameter :: XHUGE = HUGE ( INVALS ) Real ( kind = real64 ), Dimension ( SIZE ( INVALS ) + 6 ) :: XWRKT Real ( kind = real64 ) :: XWRK , XWRK1 , XMED7 ! Integer , Dimension (( SIZE ( INVALS ) + 6 ) / 7 ) :: ISTRT , IENDT , IMEDT Integer :: NDON , NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , IWRK , IDCR , ICRS , ICRS1 , ICRS2 , IMED1 ! NDON = SIZE ( INVALS ) NMED = ( NDON + 1 ) / 2 !      write(unit=*,fmt=*) NMED, NDON ! !  If the number of values is small, then use insertion sort ! If ( NDON < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDON If ( INVALS ( 1 ) < INVALS ( NDON )) Then XWRK = INVALS ( 1 ) XWRKT ( IDCR ) = INVALS ( IDCR ) Else XWRK = INVALS ( IDCR ) XWRKT ( IDCR ) = INVALS ( 1 ) Endif Do IWRK = 1 , NDON - 2 IDCR = IDCR - 1 XWRK1 = INVALS ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( 1 ) = XWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! !  Insert any value less than the current median in the first half ! Do ICRS = NMED + 1 , NDON XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( NMED )) Then IDCR = NMED - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End If End Do res_med = XWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  remove the loop test in the insertion loop. ! DO IDEB = 1 , NDON - 6 , 7 IDCR = IDEB + 6 If ( INVALS ( IDEB ) < INVALS ( IDCR )) Then XWRK = INVALS ( IDEB ) XWRKT ( IDCR ) = INVALS ( IDCR ) Else XWRK = INVALS ( IDCR ) XWRKT ( IDCR ) = INVALS ( IDEB ) Endif Do IWRK = 1 , 5 IDCR = IDCR - 1 XWRK1 = INVALS ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( IDEB ) = XWRK Do ICRS = IDEB + 2 , IDEB + 6 XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( ICRS - 1 )) Then XWRKT ( ICRS ) = XWRKT ( ICRS - 1 ) IDCR = ICRS - 1 XWRK1 = XWRKT ( IDCR - 1 ) Do If ( XWRK >= XWRK1 ) Exit XWRKT ( IDCR ) = XWRK1 IDCR = IDCR - 1 XWRK1 = XWRKT ( IDCR - 1 ) End Do XWRKT ( IDCR ) = XWRK EndIf End Do End Do ! !  Add-up alternatively + and - HUGE values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDON / 7 ) NTRI = NDON If ( IDEB < NDON ) Then ! XWRK1 = XHUGE Do ICRS = IDEB + 1 , IDEB + 7 If ( ICRS <= NDON ) Then XWRKT ( ICRS ) = INVALS ( ICRS ) Else If ( XWRK1 /= XHUGE ) NMED = NMED + 1 XWRKT ( ICRS ) = XWRK1 XWRK1 = - XWRK1 Endif End Do ! Do ICRS = IDEB + 2 , IDEB + 7 XWRK = XWRKT ( ICRS ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IDON + 3 End Do ! !  Find XMED7, the median of the medians ! XMED7 = real64_valmed ( XWRKT ( IMEDT )) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XWRKT ( IMED ) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XWRKT ( IMED ) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XWRKT (IMED) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values XWRK1 = XHUGE NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) < XWRK1 ) Then XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) >= XWRK1 ) Exit XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) End Do End If End Do res_med = XWRK1 Return Else res_med = XMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = - XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else Exit End If End Do Endif End Do ! res_med = XWRK1 Return End If ! End Function real64_valmed Recursive Function real32_valmed ( INVALS ) Result ( res_med ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Real ( kind = real32 ) :: res_med ! __________________________________________________________ Real ( kind = real32 ), Parameter :: XHUGE = HUGE ( INVALS ) Real ( kind = real32 ), Dimension ( SIZE ( INVALS ) + 6 ) :: XWRKT Real ( kind = real32 ) :: XWRK , XWRK1 , XMED7 ! Integer , Dimension (( SIZE ( INVALS ) + 6 ) / 7 ) :: ISTRT , IENDT , IMEDT Integer :: NDON , NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , IWRK , IDCR , ICRS , ICRS1 , ICRS2 , IMED1 ! NDON = SIZE ( INVALS ) NMED = ( NDON + 1 ) / 2 !      write(unit=*,fmt=*) NMED, NDON ! !  If the number of values is small, then use insertion sort ! If ( NDON < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDON If ( INVALS ( 1 ) < INVALS ( NDON )) Then XWRK = INVALS ( 1 ) XWRKT ( IDCR ) = INVALS ( IDCR ) Else XWRK = INVALS ( IDCR ) XWRKT ( IDCR ) = INVALS ( 1 ) Endif Do IWRK = 1 , NDON - 2 IDCR = IDCR - 1 XWRK1 = INVALS ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( 1 ) = XWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! !  Insert any value less than the current median in the first half ! Do ICRS = NMED + 1 , NDON XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( NMED )) Then IDCR = NMED - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End If End Do res_med = XWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  remove the loop test in the insertion loop. ! DO IDEB = 1 , NDON - 6 , 7 IDCR = IDEB + 6 If ( INVALS ( IDEB ) < INVALS ( IDCR )) Then XWRK = INVALS ( IDEB ) XWRKT ( IDCR ) = INVALS ( IDCR ) Else XWRK = INVALS ( IDCR ) XWRKT ( IDCR ) = INVALS ( IDEB ) Endif Do IWRK = 1 , 5 IDCR = IDCR - 1 XWRK1 = INVALS ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( IDEB ) = XWRK Do ICRS = IDEB + 2 , IDEB + 6 XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( ICRS - 1 )) Then XWRKT ( ICRS ) = XWRKT ( ICRS - 1 ) IDCR = ICRS - 1 XWRK1 = XWRKT ( IDCR - 1 ) Do If ( XWRK >= XWRK1 ) Exit XWRKT ( IDCR ) = XWRK1 IDCR = IDCR - 1 XWRK1 = XWRKT ( IDCR - 1 ) End Do XWRKT ( IDCR ) = XWRK EndIf End Do End Do ! !  Add-up alternatively + and - HUGE values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDON / 7 ) NTRI = NDON If ( IDEB < NDON ) Then ! XWRK1 = XHUGE Do ICRS = IDEB + 1 , IDEB + 7 If ( ICRS <= NDON ) Then XWRKT ( ICRS ) = INVALS ( ICRS ) Else If ( XWRK1 /= XHUGE ) NMED = NMED + 1 XWRKT ( ICRS ) = XWRK1 XWRK1 = - XWRK1 Endif End Do ! Do ICRS = IDEB + 2 , IDEB + 7 XWRK = XWRKT ( ICRS ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IDON + 3 End Do ! !  Find XMED7, the median of the medians ! XMED7 = real32_valmed ( XWRKT ( IMEDT )) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XWRKT ( IMED ) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XWRKT ( IMED ) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XWRKT (IMED) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values XWRK1 = XHUGE NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) < XWRK1 ) Then XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) >= XWRK1 ) Exit XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) End Do End If End Do res_med = XWRK1 Return Else res_med = XMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = - XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else Exit End If End Do Endif End Do ! res_med = XWRK1 Return End If ! End Function real32_valmed Recursive Function int32_valmed ( INVALS ) Result ( res_med ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer ( kind = int32 ) :: res_med ! __________________________________________________________ Integer ( kind = int32 ), Parameter :: XHUGE = HUGE ( INVALS ) Integer ( kind = int32 ), Dimension ( SIZE ( INVALS ) + 6 ) :: XWRKT Integer ( kind = int32 ) :: XWRK , XWRK1 , XMED7 ! Integer , Dimension (( SIZE ( INVALS ) + 6 ) / 7 ) :: ISTRT , IENDT , IMEDT Integer :: NDON , NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , IWRK , IDCR , ICRS , ICRS1 , ICRS2 , IMED1 ! NDON = SIZE ( INVALS ) NMED = ( NDON + 1 ) / 2 !      write(unit=*,fmt=*) NMED, NDON ! !  If the number of values is small, then use insertion sort ! If ( NDON < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDON If ( INVALS ( 1 ) < INVALS ( NDON )) Then XWRK = INVALS ( 1 ) XWRKT ( IDCR ) = INVALS ( IDCR ) Else XWRK = INVALS ( IDCR ) XWRKT ( IDCR ) = INVALS ( 1 ) Endif Do IWRK = 1 , NDON - 2 IDCR = IDCR - 1 XWRK1 = INVALS ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( 1 ) = XWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! !  Insert any value less than the current median in the first half ! Do ICRS = NMED + 1 , NDON XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( NMED )) Then IDCR = NMED - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End If End Do res_med = XWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  remove the loop test in the insertion loop. ! DO IDEB = 1 , NDON - 6 , 7 IDCR = IDEB + 6 If ( INVALS ( IDEB ) < INVALS ( IDCR )) Then XWRK = INVALS ( IDEB ) XWRKT ( IDCR ) = INVALS ( IDCR ) Else XWRK = INVALS ( IDCR ) XWRKT ( IDCR ) = INVALS ( IDEB ) Endif Do IWRK = 1 , 5 IDCR = IDCR - 1 XWRK1 = INVALS ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( IDEB ) = XWRK Do ICRS = IDEB + 2 , IDEB + 6 XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( ICRS - 1 )) Then XWRKT ( ICRS ) = XWRKT ( ICRS - 1 ) IDCR = ICRS - 1 XWRK1 = XWRKT ( IDCR - 1 ) Do If ( XWRK >= XWRK1 ) Exit XWRKT ( IDCR ) = XWRK1 IDCR = IDCR - 1 XWRK1 = XWRKT ( IDCR - 1 ) End Do XWRKT ( IDCR ) = XWRK EndIf End Do End Do ! !  Add-up alternatively + and - HUGE values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDON / 7 ) NTRI = NDON If ( IDEB < NDON ) Then ! XWRK1 = XHUGE Do ICRS = IDEB + 1 , IDEB + 7 If ( ICRS <= NDON ) Then XWRKT ( ICRS ) = INVALS ( ICRS ) Else If ( XWRK1 /= XHUGE ) NMED = NMED + 1 XWRKT ( ICRS ) = XWRK1 XWRK1 = - XWRK1 Endif End Do ! Do ICRS = IDEB + 2 , IDEB + 7 XWRK = XWRKT ( ICRS ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IDON + 3 End Do ! !  Find XMED7, the median of the medians ! XMED7 = int32_valmed ( XWRKT ( IMEDT )) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XWRKT ( IMED ) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XWRKT ( IMED ) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XWRKT (IMED) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values XWRK1 = XHUGE NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) < XWRK1 ) Then XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) >= XWRK1 ) Exit XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) End Do End If End Do res_med = XWRK1 Return Else res_med = XMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = - XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else Exit End If End Do Endif End Do ! res_med = XWRK1 Return End If ! End Function int32_valmed end module M_valmed","tags":"","loc":"sourcefile/m_valmed.f90.html"},{"title":"M_orderpack.f90 – orderpack","text":"NAME M_orderpack(3f) - [orderpack::INTRO]General and Specialized Ranking and Sorting Routines SYNOPSIS Proc edure names and syntax : use M_orderpack , only : & Sort , & ! Subroutine Sort ( INOUTVALS ) Sort_Special , & ! Subroutine Sort_Special ( INOUTVALS ) Psort , & ! Subroutine Psort ( INOUTVALS , nord ) Rank , & ! Subroutine Rank ( INVALS , imult ) Rank_Basic , & ! Subroutine Rank_Basic ( INVALS , irngt ) Rank_Decreasing , & ! Subroutine Rank_Decreasing ( INVALS , igoest ) Rank_Unique , & ! Subroutine Rank_Unique ( INVALS , irngt , nuni ) Prank , & ! Subroutine Prank ( INVALS , irngt , nord ) Prank_Basic , & ! Subroutine Prank_Basic ( INVALS , irngt , nord ) Prank_Decreasing , & ! Subroutine Prank_Decreasing ( INVALS , irngt , nord ) Prank_Special , & ! Subroutine Prank_Special , ( INVALS , irngt , nord ) Prank_Unique , & ! Subroutine Prank_Unique ( INVALS , irngt , nord ) Median , & ! Function Median ( INVALS ) MedianVal , & ! Function MedianVal ( INVALS ) MedianLoc , & ! Subroutine MedianLoc ( INVALS , indm ) Orderval , & ! Function OrderVal ( INVALS , nord ) OrderLoc , & ! Integer Function OrderLoc ( INVALS , nord ) Orderval_Special , & ! Function OrderVal_Special ( INVALS , nord ) Occurrences , & ! Subroutine Occurrences ( INVALS , imult ) Unique , & ! Subroutine Unique ( INOUTVALS , nuni ) Perturb ! Subroutine Perturb ( INOUTVALS , CL OSENESS ) The procedures may be accessed via their original names in ORDERPACK2.0 as well , one per module : ! previous ORDERPACK2.0 name ! ORDERPACK 2.1 name use M_refsor , only : refsor ! Sort use M_inssor , only : inssor ! Sort_special use M_inspar , only : inspar ! psort use M_mrgrnk , only : mrgrnk ! rank use M_mrgref , only : mrgref ! rank_basic use M_uniinv , only : uniinv ! rank_decreasing use M_unirnk , only : unirnk ! rank_unique use M_rnkpar , only : rnkpar ! prank use M_refpar , only : refpar ! prank_basic use M_rapknr , only : rapknr ! prank_decreasing use M_rinpar , only : rinpar ! prank_special use M_unipar , only : unipar ! prank_unique use M_median , only : median ! median use M_valmed , only : valmed ! medianval use M_indmed , only : indmed ! medianloc use M_valnth , only : valnth ! orderval use M_indnth , only : indnth ! orderloc use M_fndnth , only : fndnth ! orderval_special use M_mulcnt , only : mulcnt ! occurrences use M_unista , only : unista ! unique use M_ctrper , only : ctrper ! perturb DESCRIPTION ORDERPACK 2.1 - Unconditional, Unique and Partial Ranking, Sorting,\n                and Permutation\n\nORDERPACK 2.1 performs both conventional sorting and ranking as well as\nthe rarer specialized ordering tasks such as partial sorting, partial\nranking, unique sorting, unique ranking, inverse unique ranking, and\nmore. These partial sort and ranking routines can greatly accelerate\nmany computations when users need only the M largest or smallest\nelements out of a N-element vector. SORTING FULL SORTING Sort Sorts array into ascending order ( Quicksort ) Sort_Special Sorts array into ascending order ( Insertion sort , generally for small or nearly sorted arrays ) PARTIAL SORTING Psort partially sorts an array Orderval_Special Return Nth lowest value of an array ( Insert - sort , generally for small or nearly sorted arrays )) Orderval Return VALUE of Nth lowest value of array ( QuickSort ) MedianVal finds the median of an array Median Return median value of array . If number of elements is even , return average of the two \" medians \" RANKING UNCONDITIONAL RANKING Rank ranks array ( optimized merge - sort ) Rank_Basic ranks array ( basic merge - sort ) PARTIAL RANKING Prank partially ranks array ( Optimized QuickSort ) Prank_Basic partially ranks array Prank_Decreasing partially ranks array in DECREASING order Prank_Special partially ranks array ( Basic Insert - Sort ) Orderloc Return INDEX of Nth value of array ( QuickSort - like ) MedianLoc Returns INDEX of median value of an array . UNIQUE RANKING Rank_Unique performs a MergeSort ranking of an array , with removal of duplicate entries . Rank_Decreasing an inverse ranking of an array , with duplicate entries assigned the same rank . Prank_Unique partially rank an array removing duplicates UNIQUE Unique        Removes duplicates from an array\n                  otherwise retaining original order MULTIPLICITY Occurrances Give the multiplicity for each array value PERMUTATION Perturb a random permutation of an array , optionally leaving elements close to initial locations RATIONALE While Fortran 90 and later variants have made life much easier for scientific programmers than Fortran 77 , the language still lacks depth in public domain utilities . The following package , ORDERPACK 2.1 , provides important but uncommon routines needed to complete the Fortran programming environment . INTRODUCTION The existing fortran code base provides many conventional ranking or sorting routines , but very few specialized ranking or sorting routines . Specifically , we know of no other Fortran code which sorts or ranks only a small proportion of an array ( partial ordering ) . Such partial ranking routines have applications in statistics for rapidly computing extreme order statistics , finding nearest neighbors , and other clustering operations . In addition , many applications need to work with only the unique values in an array ( unique ordering ) . Such unique ranking routines allow users to isolate individual cases out of a mass of discrete data . Many times the frequency of the unique values proves interesting ( e . g ., empirical distributions ) . ORDERPACK handles all of these ordering needs . Also , ORDERPACK contains a partial unique ranking routine . Such a routine would prove useful in finding a limited number of unique values in an array . Inversion of orderings becomes difficult when duplicates exist ( not a one - to - one relation ) . The ORDERPACK inverse ranking routine handles this difficult case . As an added bonus ORDERPACK provides an unusual routine which allows user controllable partial random permutation of arrays . ORDERPACK of course contains conventional or unconditional sorting routines as well . Finally , many Fortran sorting or ranking routines do not take advantage of available memory and cache to maximize performance . The routines in ORDERPACK have been designed to take advantage of modern machines . RANKING VERSUS SORTING Ranking consists in finding , for each element of a set , its order ( rank ) in the sorted set , without effectively changing the initial order ( or disorder ! ) of the set . In many instances , it better suits the actual need of the user than sorting , as the ranks can then be used to order other related sets or components of a user type . Ranking is especially needed when the sizes of the elements are large , and therefore moving them around is resource - consuming . RANKING In some instances, one is not actually interested in modifying the\norder of the elements in a set, but only in knowing how to access them\nin increasing -- or decreasing -- order. Ranking, as it is called,\nprovides the index array I(:) such as the set S(I(:)) is ordered. One\nof the advantages of carrying out ranking rather than sorting is that\nthe index array can be computed without the performance penalty of\nmoving the elements around when they are of large sizes. A similar\npoint is that the index array can be used to index other data. OPTIMIZATION CHOICES We tried to take into account the recent trends in computing to make our compromise choices . Of course , no two problems are the same , and for some of them the following decisions may happen to be wrong . We just hope that for most cases , they will be right . * Make extensive use of work arrays : Memory can be extended , time cannot . * Try to reduce the number of operations in the inner loops , even if it increases code size . * Assume that cache size is relatively small , and try to maximize cache hits . INTERFACE Robust routines make their interface known to the calling program . There are three main ways to implement this in Fortran : * Explicit interfaces , either included in the body of the calling routine , or gathered in an 'interface module' . An example of including an interface block in the calling program can be found in the sample program sort7 . f90 . * Embedding the routine of interest as a \"contained routine\" into the calling procedure . An example of such way can be found in the follow . f90 program , that rebuilds a curve from a set of X , Y coordinates . * Embedding the routine of interest into a MODULE , and USEing that module in the procedure that calls the routine . This creates order dependencies when compiling code , generally resulting in requiring such tools as Makefiles but has many other benefits , such as most easily allowing for generic versions of the routines , This is the way we used here . An example of use is provided as the test program tstvalnth . f90 . A WORD OF APOLOGY When one looks at the description of a sorting algorithm , the process seems pretty simple , and can usually be held in 10 to 20 lines of pseudo - code . But if one wants an optimized program , one takes this simple implementation , and looks for redundant operations , investigates runs with sample data sets with a profiling tool , and is led to duplicate code with slight modifications rather than use tests in inner loops , to process differently the first and the last iterations , or to take into account some special cases that are only special in that they can be done faster . In the end , the number of lines of source code may be multiplied tenfold , and the readability decreased in a similar proportion . Unfortunately , this is the price to pay for speed of execution . It was that way when I started programming more than 20 years ago , and I have forsaken any hope that it might become otherwise before I return to dust . So please accept my apologies that this code is often complex and difficult to read . AUTHORS Michel Olagnon IFREMER Brest / Michel . Olagnon@ifremer . fr 2000 - 2013 / 11 / 06 MAINTAINERS John S. Urban, 2022-04-16 LICENSE CC0-1.0 Contents Modules M_orderpack Source Code M_orderpack.f90 Source Code module M_orderpack use M_refsor , only : sort => refsor ! [SORT] Sorts array (Quicksort) use M_inssor , only : sort_special => inssor ! [SORT] Sorts array (Insertion sort, generally for small or nearly sorted arrays) use M_inspar , only : psort => inspar ! [SORT:PARTIAL] partially sorts an array use M_mrgrnk , only : rank => mrgrnk ! [RANK] ranks array (optimized merge-sort) use M_mrgref , only : rank_basic => mrgref ! [RANK] ranks array (basic merge-sort) use M_uniinv , only : rank_decreasing => uniinv ! [RANK:UNIQUE] inverse ranks an array, use M_unirnk , only : rank_unique => unirnk ! [RANK:UNIQUE] ranks an array, with removal of duplicate entries.(MergSort) ! with duplicate entries assigned the same rank.(MergSort-like) use M_rnkpar , only : prank => rnkpar ! [RANK:PARTIAL] partially ranks array (Optimized Quick-Sort) use M_refpar , only : prank_basic => refpar ! [RANK:PARTIAL] partially ranks array (Quick-Sort) use M_rinpar , only : prank_special => rinpar ! [RANK:PARTIAL] partially ranks array ! PRANK_DECREASING_UNIQUE use M_rapknr , only : prank_decreasing => rapknr ! [RANK:PARTIAL] partially rank array in DECREASING order and equal ranks for a value use M_unipar , only : prank_unique => unipar ! [RANK:PARTIAL:UNIQUE] partially rank an array removing duplicates use M_median , only : median ! [MEDIAN] Calculate median value. If number of elements is even, return average !          of the central values use M_valmed , only : medianval => valmed ! [MEDIAN] Find VALUE of median element. use M_indmed , only : medianloc => indmed ! [MEDIAN] Find INDEX of median element. use M_indnth , only : orderloc => indnth ! [FRACTILE] Return INDEX of Nth ordered element , !            i.e fractile of order N/SIZE(array) (QuickSort-like) use M_valnth , only : orderval => valnth ! [FRACTILE] Return VALUE of Nth element of array, !            i.e fractile of order N/SIZE(array) (QuickSort-like) use M_fndnth , only : orderval_special => fndnth ! [FRACTILE] Return VALUE of Nth ordered elements , !            i.e. fractile of order N/SIZE(array) (Insert-like) use M_unista , only : unique => unista ! [UNIQUE] Removes duplicates from an array otherwise retaining original order use M_mulcnt , only : occurrences => mulcnt ! [MULTIPLICITY] gives number of times that each value appears in the input use M_ctrper , only : perturb => ctrper ! [PERMUTATION] perturbs an array leaving elements close to initial locations !> !!##NAME !!    M_orderpack(3f) - [orderpack::INTRO]General and Specialized Ranking and Sorting Routines !!##SYNOPSIS !! !!    Procedure names and syntax: !! !!     use M_orderpack, only : & !!      Sort,             & ! Subroutine Sort             (INOUTVALS) !!      Sort_Special,     & ! Subroutine Sort_Special     (INOUTVALS) !!      Psort,            & ! Subroutine Psort            (INOUTVALS, nord) !! !!      Rank,             & ! Subroutine Rank             (INVALS, imult) !!      Rank_Basic,       & ! Subroutine Rank_Basic       (INVALS, irngt) !!      Rank_Decreasing,  & ! Subroutine Rank_Decreasing  (INVALS, igoest) !!      Rank_Unique,      & ! Subroutine Rank_Unique      (INVALS, irngt, nuni) !! !!      Prank,            & ! Subroutine Prank            (INVALS, irngt, nord) !!      Prank_Basic,      & ! Subroutine Prank_Basic      (INVALS, irngt, nord) !!      Prank_Decreasing, & ! Subroutine Prank_Decreasing (INVALS, irngt, nord) !!      Prank_Special,    & ! Subroutine Prank_Special,   (INVALS, irngt, nord) !!      Prank_Unique,     & ! Subroutine Prank_Unique     (INVALS, irngt, nord) !! !!      Median,           & ! Function Median             (INVALS) !!      MedianVal,        & ! Function MedianVal          (INVALS) !!      MedianLoc,        & ! Subroutine MedianLoc        (INVALS, indm) !! !!      Orderval,         & ! Function OrderVal           (INVALS, nord) !!      OrderLoc,         & ! Integer Function OrderLoc   (INVALS, nord) !!      Orderval_Special, & ! Function OrderVal_Special   (INVALS, nord) !! !!      Occurrences,      & ! Subroutine Occurrences      (INVALS, imult) !!      Unique,           & ! Subroutine Unique           (INOUTVALS, nuni) !!      Perturb             ! Subroutine Perturb          (INOUTVALS, CLOSENESS) !! !!    The procedures may be accessed via their original names in ORDERPACK2.0 !!    as well, one per module: !! !!     ! previous ORDERPACK2.0 name ! ORDERPACK 2.1 name !!     use M_refsor, only : refsor  ! Sort !!     use M_inssor, only : inssor  ! Sort_special !!     use M_inspar, only : inspar  ! psort !!     use M_mrgrnk, only : mrgrnk  ! rank !!     use M_mrgref, only : mrgref  ! rank_basic !!     use M_uniinv, only : uniinv  ! rank_decreasing !!     use M_unirnk, only : unirnk  ! rank_unique !!     use M_rnkpar, only : rnkpar  ! prank !!     use M_refpar, only : refpar  ! prank_basic !!     use M_rapknr, only : rapknr  ! prank_decreasing !!     use M_rinpar, only : rinpar  ! prank_special !!     use M_unipar, only : unipar  ! prank_unique !!     use M_median, only : median  ! median !!     use M_valmed, only : valmed  ! medianval !!     use M_indmed, only : indmed  ! medianloc !!     use M_valnth, only : valnth  ! orderval !!     use M_indnth, only : indnth  ! orderloc !!     use M_fndnth, only : fndnth  ! orderval_special !!     use M_mulcnt, only : mulcnt  ! occurrences !!     use M_unista, only : unista  ! unique !!     use M_ctrper, only : ctrper  ! perturb !! !!##DESCRIPTION !!    ORDERPACK 2.1 - Unconditional, Unique and Partial Ranking, Sorting, !!                    and Permutation !! !!    ORDERPACK 2.1 performs both conventional sorting and ranking as well as !!    the rarer specialized ordering tasks such as partial sorting, partial !!    ranking, unique sorting, unique ranking, inverse unique ranking, and !!    more. These partial sort and ranking routines can greatly accelerate !!    many computations when users need only the M largest or smallest !!    elements out of a N-element vector. !! !!##SORTING !!     FULL SORTING !!        Sort          Sorts array into ascending order (Quicksort) !!        Sort_Special  Sorts array into ascending order (Insertion sort, !!                      generally for small or nearly sorted arrays) !!     PARTIAL SORTING !!        Psort             partially sorts an array !!        Orderval_Special  Return Nth lowest value of an array !!                          (Insert-sort, generally for small or nearly !!                          sorted arrays)) !!        Orderval          Return VALUE of Nth lowest value of array !!                          (QuickSort) !!        MedianVal         finds the median of an array !!        Median            Return median value of array. If number of elements !!                          is even, return average of the two \"medians\" !!##RANKING !!     UNCONDITIONAL RANKING !!        Rank        ranks array (optimized merge-sort) !!        Rank_Basic  ranks array (basic merge-sort) !!     PARTIAL RANKING !!        Prank             partially ranks array (Optimized QuickSort) !!        Prank_Basic       partially ranks array !!        Prank_Decreasing  partially ranks array in DECREASING order !!        Prank_Special     partially ranks array (Basic Insert-Sort) !!        Orderloc          Return INDEX of Nth value of array (QuickSort-like) !!        MedianLoc         Returns INDEX of median value of an array. !!     UNIQUE RANKING !!        Rank_Unique       performs a MergeSort ranking of an array, !!                          with removal of duplicate entries. !!        Rank_Decreasing   an inverse ranking of an array, !!                          with duplicate entries assigned the same rank. !!        Prank_Unique      partially rank an array removing duplicates !!##UNIQUE !!        Unique        Removes duplicates from an array !!                      otherwise retaining original order !!##MULTIPLICITY !!        Occurrances   Give the multiplicity for each array value !!##PERMUTATION !!        Perturb  a random permutation of an array, optionally leaving !!                 elements close to initial locations !! !!##RATIONALE !! !!    While Fortran 90 and later variants have made life much easier for !!    scientific programmers than Fortran 77, the language still lacks !!    depth in public domain utilities. The following package, ORDERPACK !!    2.1, provides important but uncommon routines needed to complete the !!    Fortran programming environment. !! !!##INTRODUCTION !! !!    The existing fortran code base provides many conventional ranking !!    or sorting routines, but very few specialized ranking or sorting !!    routines. Specifically, we know of no other Fortran code which sorts !!    or ranks only a small proportion of an array (partial ordering). Such !!    partial ranking routines have applications in statistics for rapidly !!    computing extreme order statistics, finding nearest neighbors, and !!    other clustering operations. In addition, many applications need to !!    work with only the unique values in an array (unique ordering). Such !!    unique ranking routines allow users to isolate individual cases out !!    of a mass of discrete data. Many times the frequency of the unique !!    values proves interesting (e.g., empirical distributions). !! !!    ORDERPACK handles all of these ordering needs. !! !!    Also, ORDERPACK contains a partial unique ranking routine. Such a !!    routine would prove useful in finding a limited number of unique !!    values in an array. !! !!    Inversion of orderings becomes difficult when duplicates exist (not !!    a one-to-one relation). The ORDERPACK inverse ranking routine handles !!    this difficult case. !! !!    As an added bonus ORDERPACK provides an unusual routine which allows !!    user controllable partial random permutation of arrays. !! !!    ORDERPACK of course contains conventional or unconditional sorting !!    routines as well. !! !!    Finally, many Fortran sorting or ranking routines do not take advantage !!    of available memory and cache to maximize performance. The routines !!    in ORDERPACK have been designed to take advantage of modern machines. !! !!##RANKING VERSUS SORTING !! !!    Ranking consists in finding, for each element of a set, its order !!    (rank) in the sorted set, without effectively changing the initial !!    order (or disorder! ) of the set. In many instances, it better suits !!    the actual need of the user than sorting, as the ranks can then be !!    used to order other related sets or components of a user type. !! !!    Ranking is especially needed when the sizes of the elements are large, !!    and therefore moving them around is resource-consuming. !! !!##RANKING !! !!    In some instances, one is not actually interested in modifying the !!    order of the elements in a set, but only in knowing how to access them !!    in increasing -- or decreasing -- order. Ranking, as it is called, !!    provides the index array I(:) such as the set S(I(:)) is ordered. One !!    of the advantages of carrying out ranking rather than sorting is that !!    the index array can be computed without the performance penalty of !!    moving the elements around when they are of large sizes. A similar !!    point is that the index array can be used to index other data. !! !!##OPTIMIZATION CHOICES !! !!    We tried to take into account the recent trends in computing to make !!    our compromise choices. Of course, no two problems are the same, and !!    for some of them the following decisions may happen to be wrong. We !!    just hope that for most cases, they will be right. !! !!      * Make extensive use of work arrays: Memory can be extended, !!        time cannot. !!      * Try to reduce the number of operations in the inner loops, even !!        if it increases code size. !!      * Assume that cache size is relatively small, and try to maximize !!        cache hits. !! !!##INTERFACE !! !!    Robust routines make their interface known to the calling !!    program. There are three main ways to implement this in Fortran: !! !!      * Explicit interfaces, either included in the body of the calling !!        routine, or gathered in an 'interface module'. An example of !!        including an interface block in the calling program can be found !!        in the sample program sort7.f90. !!      * Embedding the routine of interest as a \"contained routine\" into !!        the calling procedure. An example of such way can be found in !!        the follow.f90 program, that rebuilds a curve from a set of X, !!        Y coordinates. !!      * Embedding the routine of interest into a MODULE, and USEing that !!        module in the procedure that calls the routine. This creates !!        order dependencies when compiling code, generally resulting in !!        requiring such tools as Makefiles but has many other benefits, !!        such as most easily allowing for generic versions of the routines, !!        This is the way we used here. An example of use is provided as !!        the test program tstvalnth.f90. !! !!##A WORD OF APOLOGY !! !!    When one looks at the description of a sorting algorithm, the !!    process seems pretty simple, and can usually be held in 10 to 20 !!    lines of pseudo-code. But if one wants an optimized program, one !!    takes this simple implementation, and looks for redundant operations, !!    investigates runs with sample data sets with a profiling tool, and !!    is led to duplicate code with slight modifications rather than use !!    tests in inner loops, to process differently the first and the last !!    iterations, or to take into account some special cases that are only !!    special in that they can be done faster. !! !!    In the end, the number of lines of source code may be !!    multiplied tenfold, and the readability decreased in a similar !!    proportion. Unfortunately, this is the price to pay for speed of !!    execution. It was that way when I started programming more than 20 !!    years ago, and I have forsaken any hope that it might become otherwise !!    before I return to dust. So please accept my apologies that this code !!    is often complex and difficult to read. !! !!##AUTHORS !!    Michel Olagnon IFREMER Brest / Michel.Olagnon@ifremer.fr !! !!    2000- 2013/11/06 !!##MAINTAINERS !!    John S. Urban, 2022-04-16 !! !!##LICENSE !!    CC0-1.0 end module M_orderpack","tags":"","loc":"sourcefile/m_orderpack.f90.html"},{"title":"M_uniinv.f90 – orderpack","text":"Contents Modules M_uniinv Source Code M_uniinv.f90 Source Code Module M_uniinv use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: uniinv interface uniinv module procedure real64_uniinv , real32_uniinv , int32_uniinv , f_char_uniinv end interface uniinv interface nearless module procedure real64_nearless , real32_nearless , int32_nearless , f_char_nearless end interface nearless contains !> !!##NAME !!    Rank_Decreasing(3f) - [orderpack:RANK:UNIQUE] ranks an array !!    in decreasing order, with duplicate entries assigned the same !!    rank(MergeSort) !! !!##SYNOPSIS !! !!     Subroutine Rank_Decreasing (INVALS, IGOEST) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IGOEST(:) !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !! !!    RANK_DECREASING(3f) generates an inverse ranking of an array, but !!    with duplicate entries assigned the same rank. !! !!    Internally, the routine is similar to pure merge-sort ranking, but on !!    the last pass, it sets indices in IGOEST to the rank of the original !!    value in an ordered set with duplicates removed. For performance !!    reasons, the first two passes are taken out of the standard loop, !!    and use dedicated coding. !! !!##OPTIONS !!     INVALS     array to rank !!     IGOEST     returned rank array !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rank_decreasing !!    ! rank input array ranking duplicates the same !!    use M_orderpack, only : rank_decreasing !!    implicit none !!    character(len=*),parameter :: fmt='(a,*(g3.3,1x))' !!    integer,allocatable,dimension(:) :: INVALS, igoest, distinct, count !!    integer :: imx, i !!       ! create an input array !!       INVALS=[11, 11, 22, 11, 33, 33, 22, 33, 33] !!       ! make an index array of the same size !!       if(allocated(igoest))deallocate(igoest) !!       allocate(igoest(size(INVALS))) !!       print fmt, 'Original:                 ',INVALS !!       print fmt, 'Number of indices to sort:',size(INVALS) !!       ! rank input array ranking duplicates the same !!       call rank_decreasing(INVALS,igoest) !!       print fmt, 'Returned Indices:         ',igoest(:) !!       ! !!       ! interrogate the results !!       ! !!       imx=maxval(igoest) !!       print fmt, 'Number of unique indices :',imx !!       ! squeeze it down to just IMX unique values !!       count=[(0,i=1,imx)] ! count how many times a value occurs !!       distinct=count      ! array to set of unique values !!       do i=1,size(INVALS) !!          distinct(igoest(i))=INVALS(i) !!          count(igoest(i))= count(igoest(i))+1 !!       enddo !!       print fmt, 'Sorted unique values:     ',distinct !!       print fmt, 'count of occurrences:     ',count !!    end program demo_rank_decreasing !! !!   Results: !! !!    Original:                  11  11  22  11  33  33  22  33  33 !!    Number of indices to sort:  9 !!    Returned Indices:           1   1   2   1   3   3   2   3   3 !!    Number of unique indices :  3 !!    Sorted unique values:      11  22  33 !!    count of occurrences:       3   2   4 !! !!##AUTHOR !!    Michel Olagnon, 2000-2012 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_uniinv ( INVALS , IGOEST ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ Real ( kind = real64 ) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = INVALS ( JWRKT ( IINDA )) XDONB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( 1 )) < INVALS ( IRNGT ( IINDB )) ) Then XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Else XTST = NEARLESS ( INVALS ( IRNGT ( IINDB ))) Endif Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! End Subroutine real64_uniinv Function real64_nearless ( XVAL ) result ( real64_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real64 ), Intent ( In ) :: XVAL Real ( kind = real64 ) :: real64_nl ! __________________________________________________________ real64_nl = nearest ( XVAL , - 1.0_real64 ) ! End Function real64_nearless Subroutine real32_uniinv ( INVALS , IGOEST ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ Real ( kind = real32 ) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = INVALS ( JWRKT ( IINDA )) XDONB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( 1 )) < INVALS ( IRNGT ( IINDB )) ) Then XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Else XTST = NEARLESS ( INVALS ( IRNGT ( IINDB ))) Endif Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! End Subroutine real32_uniinv Function real32_nearless ( XVAL ) result ( real32_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real32 ), Intent ( In ) :: XVAL Real ( kind = real32 ) :: real32_nl ! __________________________________________________________ real32_nl = nearest ( XVAL , - 1.0_real32 ) ! End Function real32_nearless Subroutine int32_uniinv ( INVALS , IGOEST ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ Integer ( kind = int32 ) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = INVALS ( JWRKT ( IINDA )) XDONB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( 1 )) < INVALS ( IRNGT ( IINDB )) ) Then XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Else XTST = NEARLESS ( INVALS ( IRNGT ( IINDB ))) Endif Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! End Subroutine int32_uniinv Function int32_nearless ( XVAL ) result ( int32_nl ) !! Nearest value less than given value ! __________________________________________________________ Integer ( kind = int32 ), Intent ( In ) :: XVAL Integer ( kind = int32 ) :: int32_nl ! __________________________________________________________ int32_nl = XVAL - 1_int32 ! End Function int32_nearless Subroutine f_char_uniinv ( INVALS , IGOEST ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ character ( kind = f_char , len = len ( INVALS )) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = INVALS ( JWRKT ( IINDA )) XDONB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( 1 )) < INVALS ( IRNGT ( IINDB )) ) Then XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Else XTST = NEARLESS ( INVALS ( IRNGT ( IINDB ))) Endif Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! IGOEST = IGOEST + 1 ! End Subroutine f_char_uniinv Function f_char_nearless ( XVAL ) result ( f_char_nl ) !! Nearest value less than given value ! __________________________________________________________ character ( kind = f_char , len =* ), Intent ( In ) :: XVAL character ( kind = f_char , len = len ( XVAL )) :: f_char_nl ! __________________________________________________________ f_char_nl = XVAL ! End Function f_char_nearless end module M_uniinv","tags":"","loc":"sourcefile/m_uniinv.f90.html"},{"title":"M_ctrper.f90 – orderpack","text":"Contents Modules M_ctrper Source Code M_ctrper.f90 Source Code Module M_ctrper use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 Use M_mrgrnk implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: ctrper interface ctrper module procedure real64_ctrper , real32_ctrper , int32_ctrper , f_char_ctrper end interface ctrper contains !> !!##NAME !!    perturb(3f) - [orderpack:PERMUTATION] generate a random permutation !!                  of an array leaving elements close to initial locations !! !!##SYNOPSIS !! !!     Subroutine Perturb (INOUTVALS, CLOSENESS) !! !!      ${TYPE} (kind=${KIND}), Intent (InOut) :: INOUTVALS(:) !!      Real, Intent (In)                      :: CLOSENESS !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!   Shuffle the array INOUTVALS randomly, leaving elements close to their !!   initial locations. !! !!   Nearbyness is controlled by CLOSENESS. The relative proportion of !!   initial order and random order is defined as 1-CLOSENESS / CLOSENESS, !!   thus when CLOSENESS = 0, there is no change in the order whereas the !!   new order is fully random when CLOSENESS = 1. !! !!   Note this differs from adding random noise to the values. The original !!   values remain unchanged, their order is just perturbed. !! !!   Internally, the routine creates a real array of the indices of !!   INOUTVALS() perturbed by random values that are based on the size !!   of CLOSENESS. The new array is then ranked using MRGRNK(3f) and the !!   resulting index is used to permute the input array. !! !!##OPTIONS !!     INOUTVALS   Array of values to perturb. !!     CLOSENESS   Proportion of closeness, constrained to the range 0.0(no !!                 change) to 1.0(fully random). !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_perturb !!    ! generate a random perturbation of an array !!    use M_orderpack, only : perturb !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    character(len=*),parameter :: list= '(*(g0:,\", \"))' !!    integer,allocatable :: xout(:,:) !!    integer          :: isz, i, j !!    isz=200 !!       ! randomly perturb location of values !!       ! !!       ! make an array with three initially identical rows of !!       ! values perturbed by different amounts !!       if(allocated(xout))deallocate(xout) !!       allocate(xout(3,isz)) !!       xout(1,:)=[(i,i=isz,1,-1)]*10 !!       xout(2,:)=xout(1,:) !!       xout(3,:)=xout(1,:) !!       ! perturb each row a different amount !!       call perturb(xout(1,:),0.0) !!       call perturb(xout(2,:),0.1) !!       call perturb(xout(3,:),1.0) !!       ! show values !!       write(*,'(a)')'count    unchanged  perturbed  random' !!       do i=1,size(xout,dim=2) !!          write(*,'(*(i8,1x))')i,xout(:,i) !!       enddo !!    char: block !!    character(len=:),allocatable :: cdont(:) !!       cdont=[character(len=20) :: 'a', 'be', 'car', 'dam','fan','gas','egg'] !!       isz=size(cdont) !!       write(*,g)'Original.................:',(trim(cdont(i)),i=1,isz) !!       call perturb(cdont,1.0) !!       write(*,g)'Perturbed ...............:',(trim(cdont(i)),i=1,isz) !!       write(*,g) !!    endblock char !! !!    end program demo_perturb !! !!   Results: !! !!    count    unchanged  perturbed  random !!           1     2000     1980       80 !!           2     1990     1990      580 !!           3     1980     1890     1690 !!           4     1970     1900     1340 !!           5     1960     1920     1260 !!           6     1950     1950     1220 !!           7     1940     1880      160 !!           8     1930     1960     1620 !!           9     1920     1860      540 !!          10     1910     1930     1300 !!          11     1900     1940     1190 !!           .        .        .        . !!           .        .        .        . !!           .        .        .        . !!           .        .        .        . !!         189      120       80     1200 !!         190      110      150      800 !!         191      100      120     1430 !!         192       90      170     1410 !!         193       80      140      370 !!         194       70       90     1720 !!         195       60       10      830 !!         196       50      100     1670 !!         197       40       20      470 !!         198       30       70     1020 !!         199       20       60     1540 !!         200       10       30     1810 !!    Original.................: a be car dam fan gas egg !!    Perturbed ...............: a be gas dam fan car egg !! !!##AUTHOR !!    Michel Olagnon, 2000-2012 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_CTRPER ( INOUTVALS , CLOSENESS ) ! _________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Real , Intent ( In ) :: CLOSENESS ! __________________________________________________________ ! Real , Dimension ( Size ( INOUTVALS )) :: XINDT Integer , Dimension ( Size ( INOUTVALS )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , CLOSENESS ), 1.0 ) XINDT = Real ( Size ( INOUTVALS )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( INOUTVALS )) ] Call MRGRNK ( XINDT , JWRKT ) INOUTVALS = INOUTVALS ( JWRKT ) ! End Subroutine real64_CTRPER Subroutine real32_CTRPER ( INOUTVALS , CLOSENESS ) ! _________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Real , Intent ( In ) :: CLOSENESS ! __________________________________________________________ ! Real , Dimension ( Size ( INOUTVALS )) :: XINDT Integer , Dimension ( Size ( INOUTVALS )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , CLOSENESS ), 1.0 ) XINDT = Real ( Size ( INOUTVALS )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( INOUTVALS )) ] Call MRGRNK ( XINDT , JWRKT ) INOUTVALS = INOUTVALS ( JWRKT ) ! End Subroutine real32_CTRPER Subroutine int32_CTRPER ( INOUTVALS , CLOSENESS ) ! _________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Real , Intent ( In ) :: CLOSENESS ! __________________________________________________________ ! Real , Dimension ( Size ( INOUTVALS )) :: XINDT Integer , Dimension ( Size ( INOUTVALS )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , CLOSENESS ), 1.0 ) XINDT = Real ( Size ( INOUTVALS )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( INOUTVALS )) ] Call MRGRNK ( XINDT , JWRKT ) INOUTVALS = INOUTVALS ( JWRKT ) ! End Subroutine int32_CTRPER Subroutine f_char_CTRPER ( INOUTVALS , CLOSENESS ) ! _________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: INOUTVALS Real , Intent ( In ) :: CLOSENESS ! __________________________________________________________ ! Real , Dimension ( Size ( INOUTVALS )) :: XINDT Integer , Dimension ( Size ( INOUTVALS )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , CLOSENESS ), 1.0 ) XINDT = Real ( Size ( INOUTVALS )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( INOUTVALS )) ] Call MRGRNK ( XINDT , JWRKT ) INOUTVALS = INOUTVALS ( JWRKT ) ! End Subroutine f_char_CTRPER end module M_ctrper","tags":"","loc":"sourcefile/m_ctrper.f90.html"},{"title":"M_valnth.f90 – orderpack","text":"Contents Modules M_valnth Source Code M_valnth.f90 Source Code Module M_valnth use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: valnth interface valnth module procedure real64_valnth , real32_valnth , int32_valnth !, f_char_valnth end interface valnth contains !> !!##NAME !!    orderval(3f) - [orderpack:FRACTILE] Return VALUE of Nth ordered value of !!                 array, or \"fractile of order N/SIZE(array)\". (QuickSort-like) !! !!##SYNOPSIS !! !!     Function OrderVal (INVALS, NORD) !! !!      ${TYPE} (Kind=${KIND}), Intent (In) :: INVALS(:) !!      ${TYPE} (Kind=${KIND})              :: orderval !!      Integer, Intent (In)                :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!   ORDERVAL(3f) returns the  NORDth (ascending order) value of INVALS, !!   i.e. the fractile of order NORD/SIZE(INVALS). !! !!   Internally, this subroutine simply calls INDNTH(3f). !! !!   This routine uses a pivoting strategy such as the one of finding the !!   median based on the QuickSort algorithm, but we skew the pivot choice !!   to try to bring it to NORD as fast as possible. It uses two temporary !!   arrays, where it stores the indices of the values smaller than the !!   pivot (ILOWT), and the indices of values larger than the pivot that we !!   might still need later on (IHIGT). It iterates until it can bring the !!   number of values in ILOWT to exactly NORD, and then finds the maximum !!   of this set. !! !!##OPTIONS !!     INVALS    array to search !!     NORD     Nth lowest value to find !!##RETURNS !!     orderval   Nth lowest value !!##EXAMPLES !! !!   Sample program: !! !!    program demo_orderval !!    !  Return value of Nth lowest value of array !!    use M_orderpack, only : orderval !!    implicit none !!    character(len=*),parameter :: list= '(*(g0:,\", \"))' !!    character(len=*),parameter :: sp='(*(g0,1x))' !!    real,parameter ::  INVALS(*)=[1.1,20.20,3.3,10.10,5.5,4.4,2.2] !!    integer :: i !!    integer :: imiddle !!       write(*,list) 'ORIGINAL:',INVALS !!       ! can return the same values as intrinsics minval() and maxval() !!       print sp, 'minval',orderval(INVALS,1),          minval(INVALS) !!       print sp, 'maxval',orderval(INVALS,size(INVALS)), maxval(INVALS) !!       ! but more generally it can return the Nth lowest value. !!       print sp,'nord=',4, ' fractile=',orderval(INVALS,4) !!       ! so a value at the middle would be !!       imiddle=(size(INVALS)+1)/2 !!       print sp,'median',orderval(INVALS,imiddle) !!       ! sorting the hard way !!       do i=1,size(INVALS) !!          write(*,list)i,orderval(INVALS,i) !!       enddo !!    end program demo_orderval !! !!   Results: !! !!    ORIGINAL:, 1.1000, 20.200, 3.300, 10.100, 5.500, 4.400, 2.200 !!    minval 1.100 1.100 !!    maxval 20.200 20.200 !!    nord= 4  fractile= 4.400 !!    median 4.400 !!    1, 1.100 !!    2, 2.200 !!    3, 3.300 !!    4, 4.400 !!    5, 5.500 !!    6, 10.100 !!    7, 20.200 !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Function real64_valnth ( INVALS , NORD ) Result ( valnth ) ! __________________________________________________________ Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Real ( Kind = real64 ) :: valnth Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( Kind = real64 ), Dimension ( SIZE ( INVALS )) :: XLOWT , XHIGT Real ( Kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX ! Integer :: NDON , JHIG , JLOW , IHIG Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = MAX ( MIN ( NORD , NDON ), 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) VALNTH = INVALS ( 1 ) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then XLOWT ( 1 ) = INVALS ( 2 ) XHIGT ( 1 ) = INVALS ( 1 ) Else XLOWT ( 1 ) = INVALS ( 1 ) XHIGT ( 1 ) = INVALS ( 2 ) End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) VALNTH = XLOWT ( 1 ) If ( INTH == 2 ) VALNTH = XHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( 3 ) Else XHIGT ( 1 ) = INVALS ( 3 ) End If Else XHIGT ( 2 ) = INVALS ( 3 ) End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! If ( INVALS ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( NDON ) Else XHIGT ( 1 ) = INVALS ( NDON ) End If Else XHIGT ( 3 ) = INVALS ( NDON ) End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * ( XHIGT ( 3 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 2 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) & XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 1 ) - XLOWT ( 1 )) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! VALNTH = XHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! XHIGT ( 1 ) = XLOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK ILOW = ILOW + 1 End Do ! XWRK1 = XHIGT ( INTH ) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XLOWT ( ICRS ) < XWRK1 ) Then XWRK = XLOWT ( ICRS ) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XHIGT ( IDCR )) Exit XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) End Do XHIGT ( IDCR + 1 ) = XLOWT ( ICRS ) XWRK1 = XHIGT ( INTH ) End If ILOW = ILOW + 1 End Do ! VALNTH = XHIGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! VALNTH = MAXVAL ( XLOWT ( 1 : INTH )) ! End Function real64_valnth Function real32_valnth ( INVALS , NORD ) Result ( valnth ) ! __________________________________________________________ Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Real ( Kind = real32 ) :: valnth Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( Kind = real32 ), Dimension ( SIZE ( INVALS )) :: XLOWT , XHIGT Real ( Kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX ! Integer :: NDON , JHIG , JLOW , IHIG Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = MAX ( MIN ( NORD , NDON ), 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) VALNTH = INVALS ( 1 ) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then XLOWT ( 1 ) = INVALS ( 2 ) XHIGT ( 1 ) = INVALS ( 1 ) Else XLOWT ( 1 ) = INVALS ( 1 ) XHIGT ( 1 ) = INVALS ( 2 ) End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) VALNTH = XLOWT ( 1 ) If ( INTH == 2 ) VALNTH = XHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( 3 ) Else XHIGT ( 1 ) = INVALS ( 3 ) End If Else XHIGT ( 2 ) = INVALS ( 3 ) End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! If ( INVALS ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( NDON ) Else XHIGT ( 1 ) = INVALS ( NDON ) End If Else XHIGT ( 3 ) = INVALS ( NDON ) End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * ( XHIGT ( 3 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 2 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) & XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 1 ) - XLOWT ( 1 )) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! VALNTH = XHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! XHIGT ( 1 ) = XLOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK ILOW = ILOW + 1 End Do ! XWRK1 = XHIGT ( INTH ) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XLOWT ( ICRS ) < XWRK1 ) Then XWRK = XLOWT ( ICRS ) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XHIGT ( IDCR )) Exit XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) End Do XHIGT ( IDCR + 1 ) = XLOWT ( ICRS ) XWRK1 = XHIGT ( INTH ) End If ILOW = ILOW + 1 End Do ! VALNTH = XHIGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! VALNTH = MAXVAL ( XLOWT ( 1 : INTH )) ! End Function real32_valnth Function int32_valnth ( INVALS , NORD ) Result ( valnth ) ! __________________________________________________________ Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer ( Kind = int32 ) :: valnth Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( Kind = int32 ), Dimension ( SIZE ( INVALS )) :: XLOWT , XHIGT Integer ( Kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX ! Integer :: NDON , JHIG , JLOW , IHIG Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( INVALS ) INTH = MAX ( MIN ( NORD , NDON ), 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) VALNTH = INVALS ( 1 ) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then XLOWT ( 1 ) = INVALS ( 2 ) XHIGT ( 1 ) = INVALS ( 1 ) Else XLOWT ( 1 ) = INVALS ( 1 ) XHIGT ( 1 ) = INVALS ( 2 ) End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) VALNTH = XLOWT ( 1 ) If ( INTH == 2 ) VALNTH = XHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( 3 ) Else XHIGT ( 1 ) = INVALS ( 3 ) End If Else XHIGT ( 2 ) = INVALS ( 3 ) End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! If ( INVALS ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( INVALS ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = INVALS ( NDON ) Else XHIGT ( 1 ) = INVALS ( NDON ) End If Else XHIGT ( 3 ) = INVALS ( NDON ) End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * ( XHIGT ( 3 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 2 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) & XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 1 ) - XLOWT ( 1 )) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = INVALS ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = INVALS ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! VALNTH = XHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! XHIGT ( 1 ) = XLOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK ILOW = ILOW + 1 End Do ! XWRK1 = XHIGT ( INTH ) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XLOWT ( ICRS ) < XWRK1 ) Then XWRK = XLOWT ( ICRS ) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XHIGT ( IDCR )) Exit XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) End Do XHIGT ( IDCR + 1 ) = XLOWT ( ICRS ) XWRK1 = XHIGT ( INTH ) End If ILOW = ILOW + 1 End Do ! VALNTH = XHIGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! VALNTH = MAXVAL ( XLOWT ( 1 : INTH )) ! End Function int32_valnth end module M_valnth","tags":"","loc":"sourcefile/m_valnth.f90.html"},{"title":"M_inspar.f90 – orderpack","text":"Contents Modules M_inspar Source Code M_inspar.f90 Source Code Module M_inspar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: inspar interface inspar module procedure real64_inspar , real32_inspar , int32_inspar , f_char_inspar end interface inspar contains !> !!##NAME !!    psort(3f) - [orderpack:SORT:PARTIAL] partially sorts an array !!                (Insertion Sort, generally for small or nearly sorted !!                arrays) !! !!##SYNOPSIS !! !!     Subroutine Psort (INOUTVALS, NORD) !! !!      ${TYPE} (kind=${KIND}), Intent (InOut) :: INOUTVALS(:) !!      Integer, Intent (In)                   :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    PSORT(3f) partially sorts INOUTVALS, bringing the NORD lowest values !!    to the beginning of the array. !! !!    Internally, this subroutine uses an insertion sort, limiting insertion !!    to the first NORD values. It does not use any work array and is faster !!    when NORD is very small (2-5), but worst case behavior can happen !!    fairly probably (initially inverse sorted). Therefore, in many cases, !!    the refined quicksort method is faster. !! !!##OPTIONS !!     INOUTVALS      The array to partially sort !!     NORD       number of sorted values to return. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_psort !!    ! partially sort an array !!    use M_orderpack, only : psort !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer :: nord !! !!    int: block !!       integer,allocatable :: ia(:) !!       ia=[10,5,7,1,4,5,6,8,9,10,1] !!       nord=5 !!       write(*,g)'Original.................:',ia !!       call psort(ia,nord) !!       write(*,g)'Number of indices to sort:',nord !!       write(*,g)nord,'Lowest values..........:',ia(:nord) !!       write(*,g)'Entire array.............:',ia !!       write(*,g) !!    endblock int !!    char: block !!       character(len=:),allocatable :: ca(:) !!       integer :: i !!       ca=[character(len=20) :: 'fan','a','car','be','egg','dam','gas'] !!       nord=3 !!       write(*,g)'Original.................:',(trim(ca(i)),i=1,size(ca)) !!       call psort(ca,nord) !!       write(*,g)'Number of indices to sort:',nord !!       write(*,g)nord,'Lowest values..........:',(trim(ca(i)),i=1,nord) !!       write(*,g)'Entire array.............:',(trim(ca(i)),i=1,size(ca)) !!       write(*,g) !!    endblock char !! !!    end program demo_psort !! !!   Results: !! !!    Original.................: 10 5 7 1 4 5 6 8 9 10 1 !!    Number of indices to sort: 5 !!    5 Lowest values..........: 1 1 4 5 5 !!    Entire array.............: 1 1 4 5 5 10 7 8 9 10 6 !! !!    Original.................: fan a car be egg dam gas !!    Number of indices to sort: 3 !!    3 Lowest values..........: a be car !!    Entire array.............: a be car fan egg dam gas !! !!##AUTHOR !!    Michel Olagnon - Feb. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_inspar ( INOUTVALS , NORD ) Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = INOUTVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! XWRK1 = INOUTVALS ( NORD ) Do ICRS = NORD + 1 , SIZE ( INOUTVALS ) If ( INOUTVALS ( ICRS ) < XWRK1 ) Then XWRK = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK XWRK1 = INOUTVALS ( NORD ) End If End Do ! End Subroutine real64_inspar Subroutine real32_inspar ( INOUTVALS , NORD ) Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = INOUTVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! XWRK1 = INOUTVALS ( NORD ) Do ICRS = NORD + 1 , SIZE ( INOUTVALS ) If ( INOUTVALS ( ICRS ) < XWRK1 ) Then XWRK = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK XWRK1 = INOUTVALS ( NORD ) End If End Do ! End Subroutine real32_inspar Subroutine int32_inspar ( INOUTVALS , NORD ) Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = INOUTVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! XWRK1 = INOUTVALS ( NORD ) Do ICRS = NORD + 1 , SIZE ( INOUTVALS ) If ( INOUTVALS ( ICRS ) < XWRK1 ) Then XWRK = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK XWRK1 = INOUTVALS ( NORD ) End If End Do ! End Subroutine int32_inspar Subroutine f_char_inspar ( INOUTVALS , NORD ) character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( In ) :: NORD ! __________________________________________________________ character ( kind = f_char , len = len ( INOUTVALS )) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = INOUTVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK End Do ! XWRK1 = INOUTVALS ( NORD ) Do ICRS = NORD + 1 , SIZE ( INOUTVALS ) If ( INOUTVALS ( ICRS ) < XWRK1 ) Then XWRK = INOUTVALS ( ICRS ) INOUTVALS ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INOUTVALS ( IDCR )) Exit INOUTVALS ( IDCR + 1 ) = INOUTVALS ( IDCR ) End Do INOUTVALS ( IDCR + 1 ) = XWRK XWRK1 = INOUTVALS ( NORD ) End If End Do ! End Subroutine f_char_inspar end module M_inspar","tags":"","loc":"sourcefile/m_inspar.f90.html"},{"title":"M_rapknr.f90 – orderpack","text":"Contents Modules M_rapknr Source Code M_rapknr.f90 Source Code Module M_rapknr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: rapknr interface rapknr module procedure real64_rapknr , real32_rapknr , int32_rapknr !, f_char_rapknr end interface rapknr contains !> !!##NAME !!    prank_decreasing(3f) - [orderpack:RANK:PARTIAL] partially ranks an !!                          array in DECREASING order. !! !!##SYNOPSIS !! !!     Subroutine Prank_Decreasing (INVALS, IRNGT, NORD) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IRNGT(:) !!       Integer, Intent (In)                :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Same as PRANK(3f), but in decreasing order. !! !!    PRANK_DECREASING(3f) partially ranks input array INVALS() in decreasing !!    order up to order NORD, placing the indices pointing to the selected !!    values into IRNGT(). !! !!    Internally this routine uses a pivoting strategy such as the one of !!    finding the median based on the quicksort algorithm, but we skew the !!    pivot choice to try to bring it to NORD as fast as possible. It uses !!    two temporary arrays, where it stores the indices of the values larger !!    than the pivot (IHIGT), and the indices of values smaller than the !!    pivot that we might still need later on (ILOWT). It iterates until !!    it can bring the number of values in IHIGT to exactly NORD, and then !!    uses an insertion sort to rank this set, since it is supposedly small. !! !!##OPTIONS !!     INVALS      Array to rank !!     IRNGT      returned rank array, indicating order of values in !!                INVALS from largest to smallest !!     NORD       number of values to return in IRNGT !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_prank_decreasing !!    ! create index to lowest N values in input array in decreasing order !!    use M_orderpack, only : prank_decreasing !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: INVALS(:) !!    integer,allocatable :: irngt(:) !!    integer :: nord !!    INVALS=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!    allocate(irngt(nord)) !!       write(*,g)'ORIGINAL:',INVALS !!       call prank_decreasing(INVALS,irngt,nord) !!       write(*,g)'NUMBER OF INDICES TO RETURN:',nord !!       write(*,g)'RETURNED INDICES:',irngt !!       write(*,g)nord,'MAXIMUM VALUES:',INVALS(irngt(:nord)) !!    end program demo_prank_decreasing !! !!   Results: !! !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF INDICES TO RETURN: 5 !!    RETURNED INDICES: 1 10 9 8 7 !!    5 MAXIMUM VALUES: 10 10 9 8 6 !! !!##AUTHOR !!    Michel Olagnon - Feb. 2011 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_rapknr ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of high values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) Return End If ! --- If ( INVALS ( 3 ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) If ( INVALS ( 3 ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = 3 Else ILOWT ( 1 ) = 3 End If Else ILOWT ( 2 ) = 3 End If ! --- If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) Return End If ! If ( INVALS ( NDON ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = ILOWT ( 1 ) If ( INVALS ( NDON ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = NDON Else ILOWT ( 1 ) = NDON End If Else if ( INVALS ( NDON ) > INVALS ( ILOWT ( 2 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = NDON else ILOWT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = ILOWT ( 3 ) Return End If ! --- JDEB = 0 IDEB = JDEB + 1 JHIG = IDEB JLOW = 3 XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 3 )) - INVALS ( IHIGT ( IDEB ))) If ( XPIV >= INVALS ( ILOWT ( 1 ))) Then XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 2 )) - INVALS ( IHIGT ( IDEB ))) If ( XPIV >= INVALS ( ILOWT ( 1 ))) & XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 1 )) - INVALS ( IHIGT ( IDEB ))) End If XPIV0 = XPIV ! --- !  One puts values < pivot in the end and those >= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the ILOWT array as soon as we have more !  than enough values in IHIGT. ! ! If ( INVALS ( NDON ) < XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) < XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more low values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! --- Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) >= XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If End Do End If End If ! --- JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JHIG == NORD ) Exit If ( JHM2 == JHIG . And . JLM2 == JLOW ) Then ! !   We are oscillating. Perturbate by bringing JHIG closer by one !   to NORD ! If ( NORD > JHIG ) Then XMAX = INVALS ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then XMAX = INVALS ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) ILOWT ( ILOW ) = ILOWT ( JLOW ) JLOW = JLOW - 1 Else IHIG = IHIGT ( JHIG ) XMIN = INVALS ( IHIG ) Do ICRS = 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then IWRK = IHIGT ( ICRS ) XMIN = INVALS ( IWRK ) IHIGT ( ICRS ) = IHIG IHIG = IWRK End If End Do JHIG = JHIG - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! --- !   We try to bring the number of values in the high values set !   closer to NORD. ! Select Case ( NORD - JHIG ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JLOW ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the low values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( ILOWT ( 1 )) >= INVALS ( ILOWT ( 2 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) End If Exit ! --- Case ( 3 ) ! ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( 3 ) If ( INVALS ( IWRK2 ) > INVALS ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) < INVALS ( IWRK3 )) Then ILOWT ( 3 ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If JLOW = 0 Do ICRS = JHIG + 1 , NORD JLOW = JLOW + 1 IHIGT ( ICRS ) = ILOWT ( JLOW ) End Do JHIG = NORD Exit ! --- Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JLOW ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( IFIN ) If ( INVALS ( IWRK2 ) > INVALS ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) < INVALS ( IWRK3 )) Then ILOWT ( IFIN ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If ! JDEB = JHIG NWRK = NORD - JHIG IWRK1 = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = IWRK1 XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values >= pivot to IHIGT !  Again, 2 parts, one where we take care of the remaining !  low values because we might still need them, and the !  other when we know that we will have more than enough !  high values in the end. ! --- JLOW = 0 Do ICRS = 2 , IFIN If ( INVALS ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( JHIG >= NORD ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) End If End Do End Select ! --- ! Case ( 1 ) ! !  Only 1 value is missing in high part ! XMAX = INVALS ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then XMAX = INVALS ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! --- ! Case ( - 5 : - 1 ) ! !  Only few values too many in high part ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) > XWRK1 ) Then XWRK = INVALS ( IHIGT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK <= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = IHIGT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in high part ! --- IDEB = JDEB + 1 IMIL = ( JHIG + IDEB ) / 2 IFIN = JHIG ! --- !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( IHIGT ( IMIL )) > INVALS ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If If ( INVALS ( IHIGT ( IMIL )) < INVALS ( IHIGT ( IFIN ))) Then IWRK = IHIGT ( IFIN ) IHIGT ( IFIN ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK If ( INVALS ( IHIGT ( IMIL )) > INVALS ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! --- XPIV = INVALS ( IHIGT ( 1 )) + REAL ( NORD ) / REAL ( JHIG + NORD ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IHIGT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JHIG + NORD ) * & ( INVALS ( IHIGT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values < XPIV to ILOWT !  However, we do not process the first values if we have been !  through the case when we did not have enough high values ! --- JLOW = 0 JHIG = JDEB ! --- If ( INVALS ( IHIGT ( IFIN )) < XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( INVALS ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! --- If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( INVALS ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do End If ! End Select ! End Do ! --- !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! End Subroutine real64_rapknr Subroutine real32_rapknr ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of high values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) Return End If ! --- If ( INVALS ( 3 ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) If ( INVALS ( 3 ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = 3 Else ILOWT ( 1 ) = 3 End If Else ILOWT ( 2 ) = 3 End If ! --- If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) Return End If ! If ( INVALS ( NDON ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = ILOWT ( 1 ) If ( INVALS ( NDON ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = NDON Else ILOWT ( 1 ) = NDON End If Else if ( INVALS ( NDON ) > INVALS ( ILOWT ( 2 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = NDON else ILOWT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = ILOWT ( 3 ) Return End If ! --- JDEB = 0 IDEB = JDEB + 1 JHIG = IDEB JLOW = 3 XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 3 )) - INVALS ( IHIGT ( IDEB ))) If ( XPIV >= INVALS ( ILOWT ( 1 ))) Then XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 2 )) - INVALS ( IHIGT ( IDEB ))) If ( XPIV >= INVALS ( ILOWT ( 1 ))) & XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 1 )) - INVALS ( IHIGT ( IDEB ))) End If XPIV0 = XPIV ! --- !  One puts values < pivot in the end and those >= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the ILOWT array as soon as we have more !  than enough values in IHIGT. ! ! If ( INVALS ( NDON ) < XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) < XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more low values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! --- Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) >= XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If End Do End If End If ! --- JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JHIG == NORD ) Exit If ( JHM2 == JHIG . And . JLM2 == JLOW ) Then ! !   We are oscillating. Perturbate by bringing JHIG closer by one !   to NORD ! If ( NORD > JHIG ) Then XMAX = INVALS ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then XMAX = INVALS ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) ILOWT ( ILOW ) = ILOWT ( JLOW ) JLOW = JLOW - 1 Else IHIG = IHIGT ( JHIG ) XMIN = INVALS ( IHIG ) Do ICRS = 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then IWRK = IHIGT ( ICRS ) XMIN = INVALS ( IWRK ) IHIGT ( ICRS ) = IHIG IHIG = IWRK End If End Do JHIG = JHIG - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! --- !   We try to bring the number of values in the high values set !   closer to NORD. ! Select Case ( NORD - JHIG ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JLOW ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the low values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( ILOWT ( 1 )) >= INVALS ( ILOWT ( 2 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) End If Exit ! --- Case ( 3 ) ! ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( 3 ) If ( INVALS ( IWRK2 ) > INVALS ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) < INVALS ( IWRK3 )) Then ILOWT ( 3 ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If JLOW = 0 Do ICRS = JHIG + 1 , NORD JLOW = JLOW + 1 IHIGT ( ICRS ) = ILOWT ( JLOW ) End Do JHIG = NORD Exit ! --- Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JLOW ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( IFIN ) If ( INVALS ( IWRK2 ) > INVALS ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) < INVALS ( IWRK3 )) Then ILOWT ( IFIN ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If ! JDEB = JHIG NWRK = NORD - JHIG IWRK1 = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = IWRK1 XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values >= pivot to IHIGT !  Again, 2 parts, one where we take care of the remaining !  low values because we might still need them, and the !  other when we know that we will have more than enough !  high values in the end. ! --- JLOW = 0 Do ICRS = 2 , IFIN If ( INVALS ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( JHIG >= NORD ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) End If End Do End Select ! --- ! Case ( 1 ) ! !  Only 1 value is missing in high part ! XMAX = INVALS ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then XMAX = INVALS ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! --- ! Case ( - 5 : - 1 ) ! !  Only few values too many in high part ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) > XWRK1 ) Then XWRK = INVALS ( IHIGT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK <= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = IHIGT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in high part ! --- IDEB = JDEB + 1 IMIL = ( JHIG + IDEB ) / 2 IFIN = JHIG ! --- !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( IHIGT ( IMIL )) > INVALS ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If If ( INVALS ( IHIGT ( IMIL )) < INVALS ( IHIGT ( IFIN ))) Then IWRK = IHIGT ( IFIN ) IHIGT ( IFIN ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK If ( INVALS ( IHIGT ( IMIL )) > INVALS ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! --- XPIV = INVALS ( IHIGT ( 1 )) + REAL ( NORD ) / REAL ( JHIG + NORD ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IHIGT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JHIG + NORD ) * & ( INVALS ( IHIGT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values < XPIV to ILOWT !  However, we do not process the first values if we have been !  through the case when we did not have enough high values ! --- JLOW = 0 JHIG = JDEB ! --- If ( INVALS ( IHIGT ( IFIN )) < XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( INVALS ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! --- If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( INVALS ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do End If ! End Select ! End Do ! --- !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! End Subroutine real32_rapknr Subroutine int32_rapknr ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of high values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) Return End If ! --- If ( INVALS ( 3 ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) If ( INVALS ( 3 ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = 3 Else ILOWT ( 1 ) = 3 End If Else ILOWT ( 2 ) = 3 End If ! --- If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) Return End If ! If ( INVALS ( NDON ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = ILOWT ( 1 ) If ( INVALS ( NDON ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = NDON Else ILOWT ( 1 ) = NDON End If Else if ( INVALS ( NDON ) > INVALS ( ILOWT ( 2 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = NDON else ILOWT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = ILOWT ( 3 ) Return End If ! --- JDEB = 0 IDEB = JDEB + 1 JHIG = IDEB JLOW = 3 XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 3 )) - INVALS ( IHIGT ( IDEB ))) If ( XPIV >= INVALS ( ILOWT ( 1 ))) Then XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 2 )) - INVALS ( IHIGT ( IDEB ))) If ( XPIV >= INVALS ( ILOWT ( 1 ))) & XPIV = INVALS ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( ILOWT ( 1 )) - INVALS ( IHIGT ( IDEB ))) End If XPIV0 = XPIV ! --- !  One puts values < pivot in the end and those >= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the ILOWT array as soon as we have more !  than enough values in IHIGT. ! ! If ( INVALS ( NDON ) < XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) < XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more low values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! --- Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) >= XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If End Do End If End If ! --- JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JHIG == NORD ) Exit If ( JHM2 == JHIG . And . JLM2 == JLOW ) Then ! !   We are oscillating. Perturbate by bringing JHIG closer by one !   to NORD ! If ( NORD > JHIG ) Then XMAX = INVALS ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then XMAX = INVALS ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) ILOWT ( ILOW ) = ILOWT ( JLOW ) JLOW = JLOW - 1 Else IHIG = IHIGT ( JHIG ) XMIN = INVALS ( IHIG ) Do ICRS = 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then IWRK = IHIGT ( ICRS ) XMIN = INVALS ( IWRK ) IHIGT ( ICRS ) = IHIG IHIG = IWRK End If End Do JHIG = JHIG - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! --- !   We try to bring the number of values in the high values set !   closer to NORD. ! Select Case ( NORD - JHIG ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JLOW ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the low values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( ILOWT ( 1 )) >= INVALS ( ILOWT ( 2 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) End If Exit ! --- Case ( 3 ) ! ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( 3 ) If ( INVALS ( IWRK2 ) > INVALS ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) < INVALS ( IWRK3 )) Then ILOWT ( 3 ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) > INVALS ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If JLOW = 0 Do ICRS = JHIG + 1 , NORD JLOW = JLOW + 1 IHIGT ( ICRS ) = ILOWT ( JLOW ) End Do JHIG = NORD Exit ! --- Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JLOW ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( IFIN ) If ( INVALS ( IWRK2 ) > INVALS ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) < INVALS ( IWRK3 )) Then ILOWT ( IFIN ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) > INVALS ( IHIGT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If ! JDEB = JHIG NWRK = NORD - JHIG IWRK1 = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = IWRK1 XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values >= pivot to IHIGT !  Again, 2 parts, one where we take care of the remaining !  low values because we might still need them, and the !  other when we know that we will have more than enough !  high values in the end. ! --- JLOW = 0 Do ICRS = 2 , IFIN If ( INVALS ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( JHIG >= NORD ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) End If End Do End Select ! --- ! Case ( 1 ) ! !  Only 1 value is missing in high part ! XMAX = INVALS ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then XMAX = INVALS ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! --- ! Case ( - 5 : - 1 ) ! !  Only few values too many in high part ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JHIG If ( INVALS ( IHIGT ( ICRS )) > XWRK1 ) Then XWRK = INVALS ( IHIGT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK <= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = IHIGT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in high part ! --- IDEB = JDEB + 1 IMIL = ( JHIG + IDEB ) / 2 IFIN = JHIG ! --- !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( IHIGT ( IMIL )) > INVALS ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If If ( INVALS ( IHIGT ( IMIL )) < INVALS ( IHIGT ( IFIN ))) Then IWRK = IHIGT ( IFIN ) IHIGT ( IFIN ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK If ( INVALS ( IHIGT ( IMIL )) > INVALS ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! --- XPIV = INVALS ( IHIGT ( 1 )) + REAL ( NORD ) / REAL ( JHIG + NORD ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IHIGT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JHIG + NORD ) * & ( INVALS ( IHIGT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values < XPIV to ILOWT !  However, we do not process the first values if we have been !  through the case when we did not have enough high values ! --- JLOW = 0 JHIG = JDEB ! --- If ( INVALS ( IHIGT ( IFIN )) < XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( INVALS ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! --- If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( INVALS ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do End If ! End Select ! End Do ! --- !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! End Subroutine int32_rapknr end module M_rapknr","tags":"","loc":"sourcefile/m_rapknr.f90.html"},{"title":"M_mrgref.f90 – orderpack","text":"Contents Modules M_mrgref Source Code M_mrgref.f90 Source Code Module M_mrgref use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: mrgref interface mrgref module procedure real64_mrgref , real32_mrgref , int32_mrgref , f_char_mrgref end interface mrgref contains !> !!##NAME !!    rank_basic(3f) - [orderpack:RANK] create an INDEX that defines the !!                     order of array sorted in ascending order (basic !!                     merge-sort) !! !!##SYNOPSIS !! !!     Subroutine Rank_Basic (INVALS, IRNGT) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IRNGT(:) !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Ranks array INVALS, filling array IRNGT with sorted indices. !! !!    It uses a basic merge-sort. !! !!    This version is not optimized for performance, and is thus !!    not as difficult to read as some other ones. !! !!    It uses Merge-sort. !! !!##OPTIONS !!     INVALS      input array to rank !!     IRNGT      returned rank array !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rank_basic !!    ! create an index that can order an array in ascending order !!    use M_orderpack, only : rank_basic !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,parameter             :: dp=kind(0.0d0) !!    integer,parameter             :: isz=10000 !!    real(kind=dp)                 :: dd(isz) !!    real(kind=dp)                 :: pp !!    integer                       :: indx(isz) !!    integer                       :: i,j,k !!    character(len=:),allocatable  :: strings(:) !!    integer,allocatable           :: cindx(:) !!       ! make some random numbers !!       call random_seed() !!       call random_number(dd) !!       dd=dd-0.50_dp !!       k=int(log(huge(0.0_dp))/log(2.0_dp))-1 !!       do i=1,isz !!          call random_number(pp) !!          j=floor((k+1)*pp) !!          dd(i)=dd(i)*(2.0_dp**j) !!       enddo !!       ! rank the numeric data !!       call rank_basic(dd,indx) !!       ! check order !!       do i=1,isz-1 !!          if(dd(indx(i)).gt.dd(indx(i+1)))then !!             write(*,g)'ERROR: data not sorted i=',i,'index=',indx(i), & !!             & 'values ',dd(indx(i)),dd(indx(i+1)) !!             stop 1 !!          endif !!       enddo !!       ! sort data using rank values !!       dd=dd(indx) !!       write(*,g)'sorted ',isz,'values' !!       write(*,g)'from',dd(1),'to',dd(isz) !!       write(*,*)minval(dd).eq.dd(1) !!       write(*,*)maxval(dd).eq.dd(isz) !!       write(*,*)minloc(dd).eq.1 !!       write(*,*)maxloc(dd).eq.isz !!       ! do a character sort !!       strings= [ character(len=20) ::                               & !!       & 'red',    'green', 'blue', 'yellow', 'orange',   'black', & !!       & 'white',  'brown', 'gray', 'cyan',   'magenta',           & !!       & 'purple'] !!       if(allocated(cindx))deallocate(cindx) !!       allocate(cindx(size(strings))) !! !!       write(*,'(a,8(a:,\",\"))')'BEFORE ',& !!               & (trim(strings(i)),i=1,size(strings)) !! !!       call rank_basic(strings,cindx) !! !!       write(*,'(a,8(a:,\",\"))')'SORTED ',& !!               & (trim(strings(cindx(i))),i=1,size(strings)) !! !!       strings=strings(cindx) ! sort the array using the rank index !! !!       do i=1,size(strings)-1 !!          if(strings(i).gt.strings(i+1))then !!             write(*,*)'Error in sorting strings a-z' !!          endif !!       enddo !!    end program demo_rank_basic !! !!   Results: !! !!    sorted  10000 values !!    from -.3393216923767161E+308 to .4341912370205701E+308 !!     T !!     T !!     T !!     T !!    BEFORE red,green,blue,yellow,orange,black,white,brown, !!    gray,cyan,magenta,purple !!    SORTED black,blue,brown,cyan,gray,green,magenta,orange, !!    purple,red,white,yellow !! !!##AUTHOR !!    Michel Olagnon - April 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_mrgref ( INVALS , IRNGT ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( INVALS ( IRNGT ( JINDA )) <= INVALS ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( INVALS ( IRNGT ( IINDA + 1 )) > INVALS ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine real64_mrgref Subroutine real32_mrgref ( INVALS , IRNGT ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( INVALS ( IRNGT ( JINDA )) <= INVALS ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( INVALS ( IRNGT ( IINDA + 1 )) > INVALS ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine real32_mrgref Subroutine int32_mrgref ( INVALS , IRNGT ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( INVALS ( IRNGT ( JINDA )) <= INVALS ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( INVALS ( IRNGT ( IINDA + 1 )) > INVALS ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine int32_mrgref Subroutine f_char_mrgref ( INVALS , IRNGT ) !!__________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( INVALS ( IRNGT ( JINDA )) <= INVALS ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( INVALS ( IRNGT ( IINDA + 1 )) > INVALS ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine f_char_mrgref end module M_mrgref","tags":"","loc":"sourcefile/m_mrgref.f90.html"},{"title":"M_unirnk.f90 – orderpack","text":"Contents Modules M_unirnk Source Code M_unirnk.f90 Source Code Module M_unirnk use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: unirnk interface unirnk module procedure real64_unirnk , real32_unirnk , int32_unirnk !, f_char_unirnk end interface unirnk interface nearless module procedure real64_nearless , real32_nearless , int32_nearless !, f_char_nearless end interface nearless contains !> !!##NAME !!    Rank_Unique(3f) - [orderpack:RANK:UNIQUE] ranks an array, with removal !!                      of duplicate entries (MergeSort) !! !!##SYNOPSIS !! !!     Subroutine rank_unique (INVALS, IRNGT, NUNI) !! !!       ${TYPE} (Kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IRNGT(:) !!       Integer, Intent (Out)               :: NUNI !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !! !!    Ranks an array, removing duplicate entries. !! !!    Internally, RANK_UNIQUE(3f) performs a Merge-sort ranking of an array, !!    with removal of duplicate entries. !! !!    The routine is similar to pure merge-sort ranking, but on the last !!    pass, it discards indices that correspond to duplicate entries. !! !!    For performance reasons, the first two passes are taken out of the !!    standard loop, and use dedicated coding. !! !!##OPTIONS !!     INVALS      array to index !!     IRNGT      rank index returned pointing to unique values !!     NUNI       the number of unique values found !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rank_unique !!    ! rank an array, with removal of duplicate entries. !!    use M_orderpack, only : rank_unique !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: INVALS(:) !!    ! !!    INVALS=[10,5,7,1,4,5,6,8,9,10,1] !!    call printme() !!    INVALS=[-1,0,-2,0,-3,0,-4] !!    call printme() !!    contains !!    subroutine printme() !!    integer,allocatable :: irngt(:) !!    integer :: nuni !!       if(allocated(irngt))deallocate(irngt) !!       allocate(irngt(size(INVALS))) !!       write(*,g)'ORIGINAL:',INVALS !!       call rank_unique(INVALS,irngt,nuni) !!       write(*,g)'NUMBER OF UNIQUE INDICES:',nuni !!       write(*,g)'RETURNED INDICES:',irngt(:nuni) !!       write(*,g)'SORTED DATA:',INVALS(irngt(:nuni)) !!    end subroutine !!    end program demo_rank_unique !! !!   Results: !! !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF UNIQUE INDICES: 8 !!    RETURNED INDICES: 4 5 2 7 3 8 9 1 !!    SORTED DATA: 1 4 5 6 7 8 9 10 !!    ORIGINAL: -1 0 -2 0 -3 0 -4 !!    NUMBER OF UNIQUE INDICES: 5 !!    RETURNED INDICES: 7 5 3 1 2 !!    SORTED DATA: -4 -3 -2 -1 0 !! !!##AUTHOR !!    Michel Olagnon, 2000-2012 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_unirnk ( INVALS , IRNGT , NUNI ) Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind = real64 ) :: XTST , XVALA , XVALB ! ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) NUNI = NVAL ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( INVALS ( JWRKT ( 1 )), INVALS ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 IRNGT ( NUNI ) = IRNG End If ! End Do ! Return ! End Subroutine real64_unirnk Function real64_nearless ( XVAL ) result ( real64_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real64 ), Intent ( In ) :: XVAL Real ( kind = real64 ) :: real64_nl ! __________________________________________________________ real64_nl = nearest ( XVAL , - 1.0_real64 ) ! End Function real64_nearless Subroutine real32_unirnk ( INVALS , IRNGT , NUNI ) Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind = real32 ) :: XTST , XVALA , XVALB ! ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) NUNI = NVAL ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( INVALS ( JWRKT ( 1 )), INVALS ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 IRNGT ( NUNI ) = IRNG End If ! End Do ! Return ! End Subroutine real32_unirnk Function real32_nearless ( XVAL ) result ( real32_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real32 ), Intent ( In ) :: XVAL Real ( kind = real32 ) :: real32_nl ! __________________________________________________________ real32_nl = nearest ( XVAL , - 1.0_real32 ) ! End Function real32_nearless Subroutine int32_unirnk ( INVALS , IRNGT , NUNI ) Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Integer ( Kind = int32 ) :: XTST , XVALA , XVALB ! ! NVAL = Min ( SIZE ( INVALS ), SIZE ( IRNGT )) NUNI = NVAL ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( INVALS ( IIND - 1 ) < INVALS ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( INVALS ( IRNGT ( IWRKD + 2 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( INVALS ( IRNGT ( IWRKD + 1 )) <= INVALS ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( INVALS ( IRNG1 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( INVALS ( IRNG2 ) <= INVALS ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XVALA = INVALS ( JWRKT ( IINDA )) XVALB = INVALS ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = INVALS ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = INVALS ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( INVALS ( JWRKT ( 1 )), INVALS ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( INVALS ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( INVALS ( JWRKT ( IINDA )) > INVALS ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( INVALS ( IRNG ) > XTST ) Then XTST = INVALS ( IRNG ) NUNI = NUNI + 1 IRNGT ( NUNI ) = IRNG End If ! End Do ! Return ! End Subroutine int32_unirnk Function int32_nearless ( XVAL ) result ( int32_nl ) !! Nearest value less than given value ! __________________________________________________________ Integer ( kind = int32 ), Intent ( In ) :: XVAL Integer ( kind = int32 ) :: int32_nl ! __________________________________________________________ int32_nl = XVAL - 1_int32 ! End Function int32_nearless end module M_unirnk","tags":"","loc":"sourcefile/m_unirnk.f90.html"},{"title":"M_rnkpar.f90 – orderpack","text":"Contents Modules M_rnkpar Source Code M_rnkpar.f90 Source Code Module M_rnkpar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: rnkpar interface rnkpar module procedure real64_rnkpar , real32_rnkpar , int32_rnkpar !, f_char_rnkpar end interface rnkpar contains !> !!##NAME !!    prank(3f) - [orderpack:RANK:PARTIAL] partially ranks an array !!                (QuickSort-like) !! !!##SYNOPSIS !! !!     Subroutine Prank (INVALS, IRNGT, NORD) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IRNGT(:) !!       Integer, Intent (In)                :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Partially ranks array INVALS(), returning indices of the requested !!    number of elements (NORD) in index array IRNGT(), where NORD is the !!    order ( aka. the number of sorted elements requested). !! !!    This routine is refined for speed, and uses a pivoting strategy such !!    as the one of finding the median based on the quicksort algorithm, !!    but we skew the pivot choice to try to bring it to NORD as fast as !!    possible. It uses two temporary arrays, where it stores the indices of !!    the values smaller than the pivot (ILOWT), and the indices of values !!    larger than the pivot that we might still need later on (IHIGT). It !!    iterates until it can bring the number of values in ILOWT to exactly !!    NORD, and then uses an insertion sort to rank this set, since it is !!    supposedly small. !! !!##OPTIONS !!     INVALS      array to rank the elements of !!     IRNGT      returned ranks !!     NORD       number of rank values to return !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_prank !!    ! partially rank array !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_orderpack, only : prank !!    implicit none !!    integer,parameter :: ivals=300 !!    real(kind=real32) :: valsr(2000) !!    real(kind=real32) :: out(ivals) !!    integer           :: indx(2000) !!    integer           :: i !!       call random_seed() !!       call random_number(valsr) !!       valsr=valsr*1000000.0-500000.0 !!       call prank(valsr,indx,ivals) !!       out=valsr(indx(:ivals)) !!       do i=1,ivals-1 !!          if (out(i+1).lt.out(i))then !!             write(*,*)'not sorted' !!             stop 1 !!          endif !!       enddo !!       write(*,*)'random array now sorted' !!    end program demo_prank !! !!   Results: !! !!     random array now sorted !! !!##AUTHOR !!    Michel Olagnon - Feb. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_rnkpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) <= INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( 3 ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) <= INVALS ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else if ( INVALS ( NDON ) < INVALS ( IHIGT ( 2 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = NDON else IHIGT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB JHIG = 3 XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( JLOW ) XMAX = INVALS ( ILOW ) Do ICRS = 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. ! Select Case ( NORD - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , NORD JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = NORD Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = ( JLOW + IDEB ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( 1 )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 JLOW = JDEB ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real64_rnkpar Subroutine real32_rnkpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) <= INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( 3 ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) <= INVALS ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else if ( INVALS ( NDON ) < INVALS ( IHIGT ( 2 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = NDON else IHIGT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB JHIG = 3 XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( JLOW ) XMAX = INVALS ( ILOW ) Do ICRS = 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. ! Select Case ( NORD - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , NORD JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = NORD Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = ( JLOW + IDEB ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( 1 )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 JLOW = JDEB ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real32_rnkpar Subroutine int32_rnkpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( INVALS )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( INVALS ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( INVALS ( 2 ) < INVALS ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! If ( INVALS ( 3 ) <= INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( 3 ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( INVALS ( NDON ) <= INVALS ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( INVALS ( NDON ) < INVALS ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else if ( INVALS ( NDON ) < INVALS ( IHIGT ( 2 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = NDON else IHIGT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB JHIG = 3 XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 3 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) Then XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 2 )) - INVALS ( ILOWT ( IDEB ))) If ( XPIV >= INVALS ( IHIGT ( 1 ))) & XPIV = INVALS ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( INVALS ( IHIGT ( 1 )) - INVALS ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( INVALS ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( INVALS ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( INVALS ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( JLOW ) XMAX = INVALS ( ILOW ) Do ICRS = 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = INVALS ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. ! Select Case ( NORD - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( INVALS ( IHIGT ( 1 )) <= INVALS ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , NORD JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = NORD Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( INVALS ( IWRK2 ) < INVALS ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( INVALS ( IWRK2 ) > INVALS ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( INVALS ( IWRK2 ) < INVALS ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = INVALS ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( INVALS ( IHIGT ( IFIN )) - INVALS ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = INVALS ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( INVALS ( IHIGT ( ICRS )) < XMIN ) Then XMIN = INVALS ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JLOW If ( INVALS ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = INVALS ( ILOWT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = ( JLOW + IDEB ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( INVALS ( ILOWT ( IMIL )) > INVALS ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( INVALS ( ILOWT ( IMIL )) < INVALS ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = INVALS ( ILOWT ( 1 )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - INVALS ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( INVALS ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 JLOW = JDEB ! If ( INVALS ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( INVALS ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( INVALS ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < INVALS ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine int32_rnkpar !$DEFINE CHARACTER !$SET KIND f_char !$SET TYPE character !$POST rnkpar !$UNDEFINE CHARACTER end module M_rnkpar","tags":"","loc":"sourcefile/m_rnkpar.f90.html"},{"title":"M_unista.f90 – orderpack","text":"Contents Modules M_unista Source Code M_unista.f90 Source Code Module M_unista use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 Use M_uniinv implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: unista interface unista module procedure real64_unista , real32_unista , int32_unista , f_char_unista end interface unista contains !> !!##NAME !!    unique(3f) - [orderpack:UNIQUE] removes duplicates from an array !!                 otherwise retaining original order (i.e. it is \"stable\") !! !!##SYNOPSIS !! !!     Subroutine Unique (INOUTVALS, NUNI) !! !!      ${TYPE} (kind=${KIND}), Intent (InOut) :: INOUTVALS(:) !!      Integer, Intent (Out)                  :: NUNI !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    UNIQUE(3f) does a stable removal of duplicates from an array. !! !!    It leaves in the initial set only those entries that are unique, !!    packing the array, and leaving the order of the retained values !!    unchanged. !! !!    Internally this subroutine uses Merge-sort unique inverse ranking. !! !!##OPTIONS !!     INOUTVALS   input array to reduce to unique values !!     NUNI    number of values comprising the returned set of unique !!             values !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unique !!    ! remove duplicates with remaining elements remaining in initial order !!    use M_orderpack, only : unique !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    character(len=*),parameter :: list= '(*(g0:,\", \"))',sp='(*(g0,1x))' !!    integer :: nuni !! !!    int : block !!    integer,allocatable :: INOUTVALS(:) !!     INOUTVALS=[44,33,33,33,22,11,33,44,55,33] !!     print list,'ORIGINAL:',INOUTVALS !!     call unique(INOUTVALS,nuni) !!     INOUTVALS=INOUTVALS(:nuni) !!     print list,'UNIQUE:',INOUTVALS !!    endblock int !! !!    end program demo_unique !! !!   Results: !! !!    ORIGINAL:, 44, 33, 33, 33, 22, 11, 33, 44, 55, 33 !!    UNIQUE:, 44, 33, 22, 11, 55 !! !!##AUTHOR !!    Michel Olagnon - Feb. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_unista ( INOUTVALS , NUNI ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( INOUTVALS )) :: IWRKT Logical , Dimension ( Size ( INOUTVALS )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INOUTVALS , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( INOUTVALS ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 INOUTVALS ( NUNI ) = INOUTVALS ( ICRS ) End If End Do ! End Subroutine real64_unista Subroutine real32_unista ( INOUTVALS , NUNI ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( INOUTVALS )) :: IWRKT Logical , Dimension ( Size ( INOUTVALS )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INOUTVALS , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( INOUTVALS ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 INOUTVALS ( NUNI ) = INOUTVALS ( ICRS ) End If End Do ! End Subroutine real32_unista Subroutine int32_unista ( INOUTVALS , NUNI ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( INOUTVALS )) :: IWRKT Logical , Dimension ( Size ( INOUTVALS )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INOUTVALS , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( INOUTVALS ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 INOUTVALS ( NUNI ) = INOUTVALS ( ICRS ) End If End Do ! End Subroutine int32_unista Subroutine f_char_unista ( INOUTVALS , NUNI ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: INOUTVALS Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( INOUTVALS )) :: IWRKT Logical , Dimension ( Size ( INOUTVALS )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( INOUTVALS , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( INOUTVALS ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 INOUTVALS ( NUNI ) = INOUTVALS ( ICRS ) End If End Do ! End Subroutine f_char_unista end module M_unista","tags":"","loc":"sourcefile/m_unista.f90.html"},{"title":"M_fndnth.f90 – orderpack","text":"Contents Modules M_fndnth Source Code M_fndnth.f90 Source Code Module M_fndnth use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: fndnth interface fndnth module procedure real64_fndnth , real32_fndnth , int32_fndnth !, f_char_fndnth end interface fndnth contains !> !!##NAME !!    orderval_special(3f) - [orderpack:FRACTILE] Return VALUE of Nth !!                           ordered element of array, or \"fractile of !!                           order N/SIZE(array)\" (InsertSort-like) !! !!##SYNOPSIS !! !!     Function Orderval_Special (INVALS, INORD) !! !!      ${TYPE} (Kind=${KIND}), Intent (In) :: INVALS(:) !!      Integer, Intent (In)                :: INORD !!      ${TYPE} (Kind=${KIND})              :: orderval_special !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!    o Real(kind=real32) !!    o Real(kind=real64) !!    o Integer(kind=int32) !! !!##DESCRIPTION !!    ORDERVAL_SPECIAL(3f) returns the INORDth lowest value of INVALS(), !!    i.e. the fractile of order INORD/SIZE(INVALS). !! !!    Internally, This subroutine uses an insertion sort, limiting insertion !!    to the first INORD values and even less when one can know that the !!    value that is considered will not be the INORDth. !! !!    An insertion sort is very fast when INORD is very small !!    (2-5). Additionally, internally it requires only a work array of size !!    INORD (and type of INVALS), !! !!    But worst case behavior can happen fairly probably (e.g., initially !!    inverse sorted). Therefore, in many cases, the refined QuickSort !!    method is faster. !! !!    so ORDERVAL_SPECIAL(3f) should be used when INORD is small and INVALS !!    is likely to be a random array, otherwise consider using INDNTH(3) !!    or VALNTH(3). !! !!##OPTIONS !!     INVALS              input array of values !!     INORD                specify Nth value of sorted INVALS array to !!                         return, from 1 to size(INVALS). !!##RETURNS !!     ORDERVAL_SPECIAL    returned value !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_orderval_special !!    ! return Nth ordered value of an array !!    use M_orderpack, only : orderval_special, medianval !!    implicit none !!    character(len=*),parameter :: list= '(*(g0:,\", \"))',sp='(*(g0,1x))' !!    integer,allocatable :: iarr(:) !!    integer :: i !!       iarr=[80,70,30,40,-50,60,20,10] !!       print sp, 'ORIGINAL:',iarr !!       ! can return the same values as intrinsics minval() and maxval() !!       print sp, 'minval',orderval_special(iarr,1),          minval(iarr) !!       print sp, 'maxval',orderval_special(iarr,size(iarr)), maxval(iarr) !!       ! but more generally it can return the Nth lowest value. !!       print sp, 'median',orderval_special(iarr,(size(iarr+1))/2), medianval(iarr) !!       ! so only Nth ordered value can be found !!       print sp,'inord=',3, ' fractile=',orderval_special(iarr,3) !!       ! sorting the hard way !!       print sp, 'ORIGINAL:',iarr !!       do i=1,size(iarr) !!          write(*,list)i,orderval_special(iarr,i) !!       enddo !!       print * !!    end program demo_orderval_special !! !!   Results: !! !!    ORIGINAL: 80 70 30 40 -50 60 20 10 !!    minval -50 -50 !!    maxval 80 80 !!    median 30 30 !!    inord= 3  fractile= 20 !!    ORIGINAL: 80 70 30 40 -50 60 20 10 !!    1, -50 !!    2, 10 !!    3, 20 !!    4, 30 !!    5, 40 !!    6, 60 !!    7, 70 !!    8, 80 !! !!##SEE ALSO !! !!    indnth(3), valnth(3) !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Function real64_fndnth ( INVALS , INORD ) Result ( FNDNTH ) ! __________________________________________________________ Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Real ( Kind = real64 ) :: FNDNTH Integer , Intent ( In ) :: INORD ! __________________________________________________________ Real ( Kind = real64 ), Dimension ( INORD ) :: XWRKT Real ( Kind = real64 ) :: XWRK , XWRK1 ! Integer :: ICRS , IDCR , ILOW , NDON ! XWRKT ( 1 ) = INVALS ( 1 ) Do ICRS = 2 , INORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NDON = SIZE ( INVALS ) XWRK1 = XWRKT ( INORD ) ILOW = 2 * INORD - NDON Do ICRS = INORD + 1 , NDON If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = INORD - 1 , MAX ( 1 , ILOW ) , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( INORD ) End If ILOW = ILOW + 1 End Do FNDNTH = XWRK1 ! End Function real64_fndnth Function real32_fndnth ( INVALS , INORD ) Result ( FNDNTH ) ! __________________________________________________________ Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Real ( Kind = real32 ) :: FNDNTH Integer , Intent ( In ) :: INORD ! __________________________________________________________ Real ( Kind = real32 ), Dimension ( INORD ) :: XWRKT Real ( Kind = real32 ) :: XWRK , XWRK1 ! Integer :: ICRS , IDCR , ILOW , NDON ! XWRKT ( 1 ) = INVALS ( 1 ) Do ICRS = 2 , INORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NDON = SIZE ( INVALS ) XWRK1 = XWRKT ( INORD ) ILOW = 2 * INORD - NDON Do ICRS = INORD + 1 , NDON If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = INORD - 1 , MAX ( 1 , ILOW ) , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( INORD ) End If ILOW = ILOW + 1 End Do FNDNTH = XWRK1 ! End Function real32_fndnth Function int32_fndnth ( INVALS , INORD ) Result ( FNDNTH ) ! __________________________________________________________ Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer ( Kind = int32 ) :: FNDNTH Integer , Intent ( In ) :: INORD ! __________________________________________________________ Integer ( Kind = int32 ), Dimension ( INORD ) :: XWRKT Integer ( Kind = int32 ) :: XWRK , XWRK1 ! Integer :: ICRS , IDCR , ILOW , NDON ! XWRKT ( 1 ) = INVALS ( 1 ) Do ICRS = 2 , INORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NDON = SIZE ( INVALS ) XWRK1 = XWRKT ( INORD ) ILOW = 2 * INORD - NDON Do ICRS = INORD + 1 , NDON If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = INORD - 1 , MAX ( 1 , ILOW ) , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( INORD ) End If ILOW = ILOW + 1 End Do FNDNTH = XWRK1 ! End Function int32_fndnth end module M_fndnth","tags":"","loc":"sourcefile/m_fndnth.f90.html"},{"title":"M_rinpar.f90 – orderpack","text":"Contents Modules M_rinpar Source Code M_rinpar.f90 Source Code Module M_rinpar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: rinpar interface rinpar module procedure real64_rinpar , real32_rinpar , int32_rinpar end interface rinpar contains !> !!##NAME !!    prank_special(3f) - [orderpack:RANK:PARTIAL] partially ranks an array in !!                 ASCENDING order (Insertion Sort) !! !!##SYNOPSIS !! !!     Subroutine Prank_Special (INVALS, IRNGT, NORD) !! !!      ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!      Integer, Intent (Out)               :: IRNGT(:) !!      Integer, Intent (In)                :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !!    o Real(kind=real32) !!    o Real(kind=real64) !!    o Integer(kind=int32) !!    o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Partially ranks INVALS().  Returns IRNGT(1:NORD) filled with the !!    indices of the lowest values in the array INVALS. More technically, !!    it does a partial ranking of the array INVALS of order NORD. !! !!    NORD is restricted to the range 1 to size(IRNGT). !! !!    Internally, this version is not optimized for performance, and is !!    thus not as difficult to read as some other ones. !! !!    The subroutine uses an insertion sort, limiting insertion to the !!    first NORD values. It does not use any work array and is fastest when !!    NORD is very small (2-5). but worst case behavior can easily happen !!    (ie. if INVALS initially is inverse sorted). Therefore, In many cases, !!    the refined Quicksort method is faster. !! !!##OPTIONS !!     INVALS   array to partially sort !!     NORD    number of indices to return, restricted to 1 to size(IRNGT) !!##RETURNS !!     IRNGT   indices of requested number (NORD) of lowest values in INVALS !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_prank_special !!    ! partially rank N lowest values in an array !!    use M_orderpack, only : prank_special !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: INVALS(:) !!    integer,allocatable :: irngt(:) !!    integer :: nord !!    INVALS=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!    allocate(irngt(nord)) !!       write(*,g)'ORIGINAL:',INVALS !!       call prank_special(INVALS,irngt,nord) !!       write(*,g)'NUMBER OF INDICES TO RETURN:',nord !!       write(*,g)'RETURNED INDICES:',irngt !!       write(*,g)nord,'SMALLEST VALUES:',INVALS(irngt(:nord)) !!    end program demo_prank_special !! !!   Results: !! !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF INDICES TO RETURN: 5 !!    RETURNED INDICES: 4 11 5 2 6 !!    5 SMALLEST VALUES: 1 1 4 5 5 !! !!##AUTHOR !!    Michel Olagnon - Feb. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_rinpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( INVALS ) If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! End Subroutine real64_rinpar Subroutine real32_rinpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( INVALS ) If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! End Subroutine real32_rinpar Subroutine int32_rinpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( INVALS ) If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! End Subroutine int32_rinpar Subroutine f_char_rinpar ( INVALS , IRNGT , NORD ) !!__________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ character ( kind = f_char , len = len ( INVALS )) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = INVALS ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = INVALS ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( INVALS ) If ( INVALS ( ICRS ) < XWRK1 ) Then XWRK = INVALS ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= INVALS ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = INVALS ( IRNGT ( NORD )) End If End Do ! End Subroutine f_char_rinpar end module M_rinpar","tags":"","loc":"sourcefile/m_rinpar.f90.html"},{"title":"M_refpar.f90 – orderpack","text":"Contents Modules M_refpar Source Code M_refpar.f90 Source Code Module M_refpar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: refpar interface refpar module procedure real64_refpar , real32_refpar , int32_refpar end interface refpar contains !> !!##NAME !!    prank_basic(3f) - [orderpack:RANK:PARTIAL] partially ranks an array !!                 (QuickSort) !! !!##SYNOPSIS !! !!     Subroutine Prank_Basic (INVALS, IRNGT, NORD) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: INVALS(:) !!       Integer, Intent (Out)               :: IRNGT(:) !!       Integer, Intent (In)                :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    creates index IRNGT() which partially ranks input array INVALS(), !!    up to order NORD. !! !!    This version is not optimized for performance, and is thus not as !!    difficult to read as some other ones. !! !!    Internally this routine uses a pivoting strategy such as the one used !!    in finding the median based on the QuickSort algorithm. It uses a !!    temporary array, where it stores the partially ranked indices of the !!    values. It iterates until it can bring the number of values lower !!    than the pivot to exactly NORD, and then uses an Insertion-Sort to !!    rank this set, since it is supposedly small. !! !!##OPTIONS !!     INVALS      array to partially rank !!     IRNGT      array to hold indices of ranked elements !!     NORD       number of elements to rank !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_prank !!    ! create index to lowest N values in input array in ascending order !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_orderpack, only : prank_basic !!    implicit none !!    real(kind=real32) :: valsr(2000) !!    integer           :: indx(2000) !!    integer           :: i !!    real,allocatable  :: results(:) !!       ! create some random data !!       call random_seed() !!       call random_number(valsr) !!       valsr=valsr*1000000.0-500000.0 !!       ! get 300 lowest values sorted !!       call prank_basic(valsr,indx,300) !!       ! !!       results=valsr(indx(:300)) !!       ! check if sorted !!       do i=1,300-1 !!          if (results(i+1).lt.results(i))then !!             write(*,*)'ERROR: not sorted' !!             stop 1 !!          endif !!       enddo !!       write(*,*)'random array now sorted' !!    end program demo_prank !! !!   Results: !! !!     random array now sorted !! !!##AUTHOR !!    Michel Olagnon - Feb. 2000 !!##MAINTAINER !!    John Urban, 2022.04.16 !!##LICENSE !!    CC0-1.0 Subroutine real64_refpar ( INVALS , IRNGT , NORD ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( INVALS )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( INVALS ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( INVALS ( IWRKT ( IMIL )) > INVALS ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = INVALS ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INVALS (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( INVALS ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( INVALS ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= INVALS ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine real64_refpar Subroutine real32_refpar ( INVALS , IRNGT , NORD ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( INVALS )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( INVALS ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( INVALS ( IWRKT ( IMIL )) > INVALS ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = INVALS ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INVALS (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( INVALS ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( INVALS ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= INVALS ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine real32_refpar Subroutine int32_refpar ( INVALS , IRNGT , NORD ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( INVALS )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( INVALS ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( INVALS ( IWRKT ( IMIL )) > INVALS ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = INVALS ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INVALS (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( INVALS ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( INVALS ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= INVALS ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine int32_refpar Subroutine f_char_refpar ( INVALS , IRNGT , NORD ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: INVALS Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ character ( kind = f_char , len = len ( INVALS )) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( INVALS )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( INVALS ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( INVALS ( IWRKT ( IMIL )) > INVALS ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( INVALS ( IWRKT ( IMIL )) < INVALS ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = INVALS ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if INVALS (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( INVALS ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( INVALS ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = INVALS ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= INVALS ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine f_char_refpar end module M_refpar","tags":"","loc":"sourcefile/m_refpar.f90.html"},{"title":"demo_psort.f90 – orderpack","text":"Contents Programs demo_psort Source Code demo_psort.f90 Source Code program demo_psort ! partially sort an array use M_orderpack , only : psort implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: nord int : block integer , allocatable :: ia (:) ia = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 write ( * , g ) 'Original.................:' , ia call psort ( ia , nord ) write ( * , g ) 'Number of indices to sort:' , nord write ( * , g ) nord , 'Lowest values..........:' , ia (: nord ) write ( * , g ) 'Entire array.............:' , ia write ( * , g ) endblock int char : block character ( len = :), allocatable :: ca (:) integer :: i ca = [ character ( len = 20 ) :: 'fan' , 'a' , 'car' , 'be' , 'egg' , 'dam' , 'gas' ] nord = 3 write ( * , g ) 'Original.................:' ,( trim ( ca ( i )), i = 1 , size ( ca )) call psort ( ca , nord ) write ( * , g ) 'Number of indices to sort:' , nord write ( * , g ) nord , 'Lowest values..........:' ,( trim ( ca ( i )), i = 1 , nord ) write ( * , g ) 'Entire array.............:' ,( trim ( ca ( i )), i = 1 , size ( ca )) write ( * , g ) endblock char end program demo_psort","tags":"","loc":"sourcefile/demo_psort.f90.html"},{"title":"demo_medianval.f90 – orderpack","text":"Contents Programs demo_medianval Source Code demo_medianval.f90 Source Code program demo_medianval ! return median value use M_orderpack , only : medianval implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'real   ' ,& medianval ( [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] ) write ( * , g ) 'integer' ,& medianval ( [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] ) write ( * , g ) 'double ' ,& medianval ( [ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ] ) end program demo_medianval","tags":"","loc":"sourcefile/demo_medianval.f90.html"},{"title":"demo_prank_special.f90 – orderpack","text":"Contents Programs demo_prank_special Source Code demo_prank_special.f90 Source Code program demo_prank_special ! partially rank N lowest values in an array use M_orderpack , only : prank_special implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) integer , allocatable :: irngt (:) integer :: nord INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , INVALS call prank_special ( INVALS , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'SMALLEST VALUES:' , INVALS ( irngt (: nord )) end program demo_prank_special","tags":"","loc":"sourcefile/demo_prank_special.f90.html"},{"title":"demo_unique.f90 – orderpack","text":"Contents Programs demo_unique Source Code demo_unique.f90 Source Code program demo_unique ! remove duplicates with remaining elements remaining in initial order use M_orderpack , only : unique implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer :: nuni int : block integer , allocatable :: INOUTVALS (:) INOUTVALS = [ 44 , 33 , 33 , 33 , 22 , 11 , 33 , 44 , 55 , 33 ] print list , 'ORIGINAL:' , INOUTVALS call unique ( INOUTVALS , nuni ) INOUTVALS = INOUTVALS (: nuni ) print list , 'UNIQUE:' , INOUTVALS endblock int end program demo_unique","tags":"","loc":"sourcefile/demo_unique.f90.html"},{"title":"demo_prank_decreasing.f90 – orderpack","text":"Contents Programs demo_prank_decreasing Source Code demo_prank_decreasing.f90 Source Code program demo_prank_decreasing ! create index to lowest N values in input array in decreasing order use M_orderpack , only : prank_decreasing implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) integer , allocatable :: irngt (:) integer :: nord INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , INVALS call prank_decreasing ( INVALS , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'MAXIMUM VALUES:' , INVALS ( irngt (: nord )) end program demo_prank_decreasing","tags":"","loc":"sourcefile/demo_prank_decreasing.f90.html"},{"title":"demo_sort.f90 – orderpack","text":"Contents Programs demo_sort Source Code demo_sort.f90 Source Code program demo_sort ! sort array in ascending order use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : sort implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. real ( kind = real64 ) :: valsd ( 2000 ) integer :: i call random_seed () call random_number ( valsd ) valsd = valsd * 100000 0.0 - 50000 0.0 call sort ( valsd ) do i = 1 , size ( valsd ) - 1 if ( valsd ( i + 1 ). lt . valsd ( i )) then write ( * , * ) 'not sorted' stop 3 endif enddo write ( * , * ) 'random arrays are now sorted' end program demo_sort","tags":"","loc":"sourcefile/demo_sort.f90.html"},{"title":"demo_sort_special.f90 – orderpack","text":"Contents Programs demo_sort_special Source Code demo_sort_special.f90 Source Code program demo_sort_special ! sort an array using insertion sort use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : sort_special implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. integer , parameter :: isz = 2000 real ( kind = real64 ) :: dd ( isz ), hi , low integer :: i ! make an array of random values call random_seed () call random_number ( dd ) dd = dd * 100000 0.0 - 50000 0.0 low = minval ( dd ) hi = maxval ( dd ) ! sort the data call sort_special ( dd ) ! cursory checks if ( any ( dd ( 1 : isz - 1 ) . gt . dd ( 2 : isz ))) stop 'ERROR: array not sorted' write ( * , * ) 'check min:' , dd ( 1 ). eq . low write ( * , * ) 'check max:' , dd ( isz ). eq . hi write ( * , * ) 'PASSED: random array is now sorted' end program demo_sort_special","tags":"","loc":"sourcefile/demo_sort_special.f90.html"},{"title":"demo_prank.f90 – orderpack","text":"Contents Programs demo_prank Source Code demo_prank.f90 Source Code program demo_prank ! partially rank array use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : prank implicit none integer , parameter :: ivals = 300 real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real32 ) :: out ( ivals ) integer :: indx ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call prank ( valsr , indx , ivals ) out = valsr ( indx (: ivals )) do i = 1 , ivals - 1 if ( out ( i + 1 ). lt . out ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_prank","tags":"","loc":"sourcefile/demo_prank.f90.html"},{"title":"demo_orderloc.f90 – orderpack","text":"Contents Programs demo_orderloc Source Code demo_orderloc.f90 Source Code program demo_orderloc ! find Nth lowest ordered value in an array without sorting entire array use M_orderpack , only : orderloc use M_orderpack , only : medianloc implicit none integer , allocatable :: iarr (:) character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer :: i integer :: indx iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 , 0 , - 100 ] print list , 'ORIGINAL:' , iarr ! like minloc() and maxloc() print sp , 'minloc' , orderloc ( iarr , 1 ), minloc ( iarr ) print sp , 'maxloc' , orderloc ( iarr , size ( iarr )), maxloc ( iarr ) ! can find median call medianloc ( iarr , indx ) print sp , 'median' , orderloc ( iarr ,( size ( iarr ) + 1 ) / 2 ), indx ! but more general so can find location of the Nth lowest value ... ! ! sort the hard way, finding location of Nth value one at a time do i = 1 , size ( iarr ) write ( * , sp , advance = 'no' ) iarr ( orderloc ( iarr , i )) enddo print * contains subroutine printme ( n ) integer , intent ( in ) :: n integer :: ii ii = orderloc ( iarr , n ) print sp , 'nord=' , n , ' index=' , ii , ' fractile=' , iarr ( ii ) end subroutine printme end program demo_orderloc","tags":"","loc":"sourcefile/demo_orderloc.f90.html"},{"title":"demo_prank_unique.f90 – orderpack","text":"Contents Programs demo_prank_unique Source Code demo_prank_unique.f90 Source Code program demo_prank_unique ! ranks array, removing duplicates use M_orderpack , only : prank_unique implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) integer , allocatable :: irngt (:) integer :: nord ! write ( * , g ) 'If enough values are unique, will return NORD indices' if ( allocated ( irngt )) deallocate ( irngt ) INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) call printme () ! !BUG!write(*,g)'If not enough values are unique, will change NORD' !BUG!INVALS=[-1,0,-1,0,-1,0,-1] !BUG!nord=5 !BUG!if(allocated(irngt))deallocate(irngt) !BUG!allocate(irngt(nord)) !BUG!call printme() contains subroutine printme () write ( * , g ) 'ORIGINAL:' , INVALS write ( * , g ) 'NUMBER OF INDICES TO SORT:' , nord call prank_unique ( INVALS , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES RETURNED:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt (: nord ) write ( * , g ) nord , 'SMALLEST UNIQUE VALUES:' , INVALS ( irngt (: nord )) end subroutine end program demo_prank_unique","tags":"","loc":"sourcefile/demo_prank_unique.f90.html"},{"title":"demo_rank.f90 – orderpack","text":"Contents Programs demo_rank Source Code demo_rank.f90 Source Code program demo_rank ! create an index that can order an array in ascending order use M_orderpack , only : rank implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call rank ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ); allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call rank ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_rank","tags":"","loc":"sourcefile/demo_rank.f90.html"},{"title":"demo_occurrences.f90 – orderpack","text":"Contents Programs demo_occurrences Source Code demo_occurrences.f90 Source Code program demo_occurrences use M_orderpack , only : occurrences ! determine how many times each value appears in an input array implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) integer :: csz integer :: i ! each name appears the number of times its name represents strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call occurrences ( strings , cindx ) write ( * , g )( trim ( strings ( i )), i = 1 , csz ) write ( * , g ) cindx end program demo_occurrences","tags":"","loc":"sourcefile/demo_occurrences.f90.html"},{"title":"demo_orderval_special.f90 – orderpack","text":"Contents Programs demo_orderval_special Source Code demo_orderval_special.f90 Source Code program demo_orderval_special ! return Nth ordered value of an array use M_orderpack , only : orderval_special , medianval implicit none character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer , allocatable :: iarr (:) integer :: i iarr = [ 80 , 70 , 30 , 40 , - 50 , 60 , 20 , 10 ] print sp , 'ORIGINAL:' , iarr ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , orderval_special ( iarr , 1 ), minval ( iarr ) print sp , 'maxval' , orderval_special ( iarr , size ( iarr )), maxval ( iarr ) ! but more generally it can return the Nth lowest value. print sp , 'median' , orderval_special ( iarr ,( size ( iarr + 1 )) / 2 ), medianval ( iarr ) ! so only Nth ordered value can be found print sp , 'inord=' , 3 , ' fractile=' , orderval_special ( iarr , 3 ) ! sorting the hard way print sp , 'ORIGINAL:' , iarr do i = 1 , size ( iarr ) write ( * , list ) i , orderval_special ( iarr , i ) enddo print * end program demo_orderval_special","tags":"","loc":"sourcefile/demo_orderval_special.f90.html"},{"title":"demo_perturb.f90 – orderpack","text":"Contents Programs demo_perturb Source Code demo_perturb.f90 Source Code program demo_perturb ! generate a random perturbation of an array use M_orderpack , only : perturb implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: list = '(*(g0:,\", \"))' integer , allocatable :: xout (:,:) integer :: isz , i , j isz = 200 ! randomly perturb location of values ! ! make an array with three initially identical rows of ! values perturbed by different amounts if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) xout ( 1 ,:) = [( i , i = isz , 1 , - 1 )] * 10 xout ( 2 ,:) = xout ( 1 ,:) xout ( 3 ,:) = xout ( 1 ,:) ! perturb each row a different amount call perturb ( xout ( 1 ,:), 0.0 ) call perturb ( xout ( 2 ,:), 0.1 ) call perturb ( xout ( 3 ,:), 1.0 ) ! show values write ( * , '(a)' ) 'count    unchanged  perturbed  random' do i = 1 , size ( xout , dim = 2 ) write ( * , '(*(i8,1x))' ) i , xout (:, i ) enddo char : block character ( len = :), allocatable :: cdont (:) cdont = [ character ( len = 20 ) :: 'a' , 'be' , 'car' , 'dam' , 'fan' , 'gas' , 'egg' ] isz = size ( cdont ) write ( * , g ) 'Original.................:' ,( trim ( cdont ( i )), i = 1 , isz ) call perturb ( cdont , 1.0 ) write ( * , g ) 'Perturbed ...............:' ,( trim ( cdont ( i )), i = 1 , isz ) write ( * , g ) endblock char end program demo_perturb","tags":"","loc":"sourcefile/demo_perturb.f90.html"},{"title":"demo_prank_basic.f90 – orderpack","text":"Contents Programs demo_prank Source Code demo_prank_basic.f90 Source Code program demo_prank ! create index to lowest N values in input array in ascending order use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : prank_basic implicit none real ( kind = real32 ) :: valsr ( 2000 ) integer :: indx ( 2000 ) integer :: i real , allocatable :: results (:) ! create some random data call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 ! get 300 lowest values sorted call prank_basic ( valsr , indx , 300 ) ! results = valsr ( indx (: 300 )) ! check if sorted do i = 1 , 300 - 1 if ( results ( i + 1 ). lt . results ( i )) then write ( * , * ) 'ERROR: not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_prank","tags":"","loc":"sourcefile/demo_prank_basic.f90.html"},{"title":"demo_rank_unique.f90 – orderpack","text":"Contents Programs demo_rank_unique Source Code demo_rank_unique.f90 Source Code program demo_rank_unique ! rank an array, with removal of duplicate entries. use M_orderpack , only : rank_unique implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) ! INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] call printme () INVALS = [ - 1 , 0 , - 2 , 0 , - 3 , 0 , - 4 ] call printme () contains subroutine printme () integer , allocatable :: irngt (:) integer :: nuni if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( INVALS ))) write ( * , g ) 'ORIGINAL:' , INVALS call rank_unique ( INVALS , irngt , nuni ) write ( * , g ) 'NUMBER OF UNIQUE INDICES:' , nuni write ( * , g ) 'RETURNED INDICES:' , irngt (: nuni ) write ( * , g ) 'SORTED DATA:' , INVALS ( irngt (: nuni )) end subroutine end program demo_rank_unique","tags":"","loc":"sourcefile/demo_rank_unique.f90.html"},{"title":"demo_medianloc.f90 – orderpack","text":"Contents Programs demo_medianloc Source Code demo_medianloc.f90 Source Code program demo_medianloc ! return index of median value use M_orderpack , only : medianloc implicit none real , allocatable :: INVALS (:) character ( len = :), allocatable :: cdont (:) character ( len =* ), parameter :: fmt = '(i5,t11,g0)' integer :: ii write ( * , * ) 'location  median' INVALS = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call medianloc ( INVALS , ii ) write ( * , fmt ) ii , INVALS ( ii ) ! INVALS = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call medianloc ( INVALS , ii ) write ( * , fmt ) ii , INVALS ( ii ) ! INVALS = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call medianloc ( INVALS , ii ) write ( * , fmt ) ii , INVALS ( ii ) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' ,& 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call medianloc ( cdont , ii ) write ( * , fmt ) ii , cdont ( ii ) ! end program demo_medianloc","tags":"","loc":"sourcefile/demo_medianloc.f90.html"},{"title":"demo_median.f90 – orderpack","text":"Contents Programs demo_median Source Code demo_median.f90 Source Code program demo_median ! calculate median value use M_orderpack , only : median implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'real   ' , median (& [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] ) write ( * , g ) 'integer' , median (& [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] ) write ( * , g ) 'double ' , median (& [ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ]) end program demo_median","tags":"","loc":"sourcefile/demo_median.f90.html"},{"title":"package.f90 – orderpack","text":"Contents Programs demo_package Source Code package.f90 Source Code program demo_package use M_mrgref , only : mrgref use M_orderpack , only : rank_basic use M_mrgrnk , only : mrgrnk use M_orderpack , only : rank use M_inssor , only : inssor use M_orderpack , only : Sort_special use M_refsor , only : refsor use M_orderpack , only : Sort use M_rinpar , only : rinpar use M_orderpack , only : prank_special use M_refpar , only : refpar use M_orderpack , only : prank_basic use M_rapknr , only : rapknr use M_orderpack , only : prank_decreasing use M_rnkpar , only : rnkpar use M_orderpack , only : prank use M_inspar , only : inspar use M_orderpack , only : psort implicit none character ( len =* ), parameter :: g = '(a,*(i3,1x))' integer , parameter :: isz = 30 ! number of random numbers integer :: mx = 13 ! maxval(abs(ii)), biggest magnitude of random values, < isz to likely get duplicates integer , parameter :: par = 8 ! order of partial sort integer :: ii ( isz ), jj ( isz ) integer :: indx ( isz ) real :: rr ( isz ) integer :: i , j , k !=================================================================================================================================== call random_seed () call random_number ( rr ) rr = rr - 0.50 ii = floor ( rr * mx ) write ( * , g ) 'Original ' , ii write ( * , g ) 'mrgref     - [RANK] produces a sorted ranking index array of input array (basic merge-sort)' indx =- 99 call mrgref ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) write ( * , g ) 'rank_basic - [RANK] produces a sorted ranking index array of input array (basic merge-sort)' indx =- 99 call mrgref ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) !=================================================================================================================================== write ( * , g ) 'mrgrnk - [RANK] produces a sorted ranking index array of input array (optimized merge-sort)' indx =- 99 call mrgrnk ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) write ( * , g ) 'rank   - [RANK] produces a sorted ranking index array of input array (optimized merge-sort)' indx =- 99 call rank ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) !=================================================================================================================================== write ( * , g ) 'inssor       - [SORT] Sorts array into ascending order (Insertion sort, generally for small or nearly sorted arrays)' jj = ii call inssor ( jj ) write ( * , g ) '         ' , jj write ( * , g ) 'Sort_special - [SORT] Sorts array into ascending order (Insertion sort, generally for small or nearly sorted arrays)' jj = ii call Sort_special ( jj ) write ( * , g ) '         ' , jj !=================================================================================================================================== write ( * , g ) 'refsor - [SORT] Sorts array into ascending order (Quicksort)' jj = ii call refsor ( jj ) write ( * , g ) '         ' , jj write ( * , g ) 'Sort   - [SORT] Sorts array into ascending order (Quicksort)' jj = ii call Sort ( jj ) write ( * , g ) '         ' , jj !=================================================================================================================================== write ( * , g ) 'inspar - [SORT:PARTIAL] partially sorts an array, bringing the N lowest values to the beginning of the array' jj = ii call inspar ( jj , par ) ! note the remainder of the data is perturbed write ( * , g ) '         ' , jj write ( * , g ) '         ' , jj ( 1 : par ) write ( * , g ) 'psort  - [SORT:PARTIAL] partially sorts an array, bringing the N lowest values to the beginning of the array' jj = ii call psort ( jj , par ) ! note the remainder of the data is perturbed write ( * , g ) '         ' , jj write ( * , g ) '         ' , jj ( 1 : par ) !=================================================================================================================================== write ( * , g ) 'rinpar        - [RANK:PARTIAL] creates partial rank index of N lowest values in an array' indx =- 99 call rinpar ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank_special - [RANK:PARTIAL] creates partial rank index of N lowest values in an array' indx =- 99 call prank_special ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'refpar - [RANK:PARTIAL] partially rank array up to specified number of elements (QuickSort-like)' indx =- 99 call refpar ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank_basic  - [RANK:PARTIAL] partially rank array up to specified number of elements (QuickSort-like)' indx =- 99 call prank_basic ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'rapknr           - [RANK:PARTIAL] partially ranks an array up to a specified number of values, in DECREASING order.' indx =- 99 call rapknr ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank_decreasing - [RANK:PARTIAL] partially ranks an array up to a specified number of values, in DECREASING order.' indx =- 99 call prank_decreasing ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'rnkpar   - [RANK:PARTIAL] partially rank array, up to order N (N number of sorted elements to return) (QuickSort-like)' indx =- 99 call rnkpar ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank    - [RANK:PARTIAL] partially rank array, up to order N (N number of sorted elements to return) (QuickSort-like)' indx =- 99 call prank ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'unipar - [RANK:PARTIAL:UNIQUE] partially rank an array removing duplicates' write ( * , g ) 'prank_unique - [RANK:PARTIAL:UNIQUE] partially rank an array removing duplicates' !=================================================================================================================================== write ( * , g ) 'uniinv - [RANK:UNIQUE] a MergeSort inverse ranking of an array, with duplicate entries assigned the same rank.' write ( * , g ) 'rank_orders - [RANK:UNIQUE] a MergeSort inverse ranking of an array, with duplicate entries assigned the same rank.' !=================================================================================================================================== write ( * , g ) 'unirnk - [RANK:UNIQUE] performs a MergeSort ranking of an array, with removal of duplicate entries.' write ( * , g ) 'rank_unique - [RANK:UNIQUE] performs a MergeSort ranking of an array, with removal of duplicate entries.' !=================================================================================================================================== write ( * , g ) 'unista - [UNIQUE] (Stable unique) Removes duplicates from an array otherwise retaining original order' write ( * , g ) 'unique - [UNIQUE] (Stable unique) Removes duplicates from an array otherwise retaining original order' !=================================================================================================================================== write ( * , g ) 'fndnth           - [FRACTILE] Return Nth lowest value of an array  (InsertSort-like)' write ( * , g ) 'orderval_special - [FRACTILE] Return Nth lowest value of an array  (InsertSort-like)' !=================================================================================================================================== write ( * , g ) 'indnth   - [FRACTILE] Return INDEX of Nth value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' write ( * , g ) 'orderloc - [FRACTILE] Return INDEX of Nth value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' !=================================================================================================================================== write ( * , g ) 'valnth   - [FRACTILE] Return VALUE of Nth lowest value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' write ( * , g ) 'orderval - [FRACTILE] Return VALUE of Nth lowest value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' !=================================================================================================================================== write ( * , g ) 'valmed    - [MEDIAN] finds the median of an array' write ( * , g ) 'medianval - [MEDIAN] finds the median of an array' !=================================================================================================================================== write ( * , g ) 'median - [MEDIAN] Return median value of array. If number of data is even, return average of the two \"medians\".' write ( * , g ) 'median - [MEDIAN] Return median value of array. If number of data is even, return average of the two \"medians\".' !=================================================================================================================================== write ( * , g ) 'indmed    - [MEDIAN] Returns INDEX of median value of an array.' write ( * , g ) 'medianloc - [MEDIAN] Returns INDEX of median value of an array.' !=================================================================================================================================== write ( * , g ) 'ctrper  - [PERMUTATION] generate a random permutation of an array leaving elements close to initial locations' write ( * , g ) 'perturb - [PERMUTATION] generate a random permutation of an array leaving elements close to initial locations' !=================================================================================================================================== write ( * , g ) 'mulcnt      - [MULTIPLICITY] Give the multiplicity for each array value (number of times that it appears in the array)' write ( * , g ) 'occurrences - [MULTIPLICITY] Give the multiplicity for each array value (number of times that it appears in the array)' !=================================================================================================================================== end program demo_package","tags":"","loc":"sourcefile/package.f90.html"},{"title":"demo_rank_decreasing.f90 – orderpack","text":"Contents Programs demo_rank_decreasing Source Code demo_rank_decreasing.f90 Source Code program demo_rank_decreasing ! rank input array ranking duplicates the same use M_orderpack , only : rank_decreasing implicit none character ( len =* ), parameter :: fmt = '(a,*(g3.3,1x))' integer , allocatable , dimension (:) :: INVALS , igoest , distinct , count integer :: imx , i ! create an input array INVALS = [ 11 , 11 , 22 , 11 , 33 , 33 , 22 , 33 , 33 ] ! make an index array of the same size if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( INVALS ))) print fmt , 'Original:                 ' , INVALS print fmt , 'Number of indices to sort:' , size ( INVALS ) ! rank input array ranking duplicates the same call rank_decreasing ( INVALS , igoest ) print fmt , 'Returned Indices:         ' , igoest (:) ! ! interrogate the results ! imx = maxval ( igoest ) print fmt , 'Number of unique indices :' , imx ! squeeze it down to just IMX unique values count = [( 0 , i = 1 , imx )] ! count how many times a value occurs distinct = count ! array to set of unique values do i = 1 , size ( INVALS ) distinct ( igoest ( i )) = INVALS ( i ) count ( igoest ( i )) = count ( igoest ( i )) + 1 enddo print fmt , 'Sorted unique values:     ' , distinct print fmt , 'count of occurrences:     ' , count end program demo_rank_decreasing","tags":"","loc":"sourcefile/demo_rank_decreasing.f90.html"},{"title":"demo_rank_basic.f90 – orderpack","text":"Contents Programs demo_rank_basic Source Code demo_rank_basic.f90 Source Code program demo_rank_basic ! create an index that can order an array in ascending order use M_orderpack , only : rank_basic implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call rank_basic ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call rank_basic ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_rank_basic","tags":"","loc":"sourcefile/demo_rank_basic.f90.html"},{"title":"demo_orderval.f90 – orderpack","text":"Contents Programs demo_orderval Source Code demo_orderval.f90 Source Code program demo_orderval !  Return value of Nth lowest value of array use M_orderpack , only : orderval implicit none character ( len =* ), parameter :: list = '(*(g0:,\", \"))' character ( len =* ), parameter :: sp = '(*(g0,1x))' real , parameter :: INVALS ( * ) = [ 1.1 , 2 0.20 , 3.3 , 1 0.10 , 5.5 , 4.4 , 2.2 ] integer :: i integer :: imiddle write ( * , list ) 'ORIGINAL:' , INVALS ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , orderval ( INVALS , 1 ), minval ( INVALS ) print sp , 'maxval' , orderval ( INVALS , size ( INVALS )), maxval ( INVALS ) ! but more generally it can return the Nth lowest value. print sp , 'nord=' , 4 , ' fractile=' , orderval ( INVALS , 4 ) ! so a value at the middle would be imiddle = ( size ( INVALS ) + 1 ) / 2 print sp , 'median' , orderval ( INVALS , imiddle ) ! sorting the hard way do i = 1 , size ( INVALS ) write ( * , list ) i , orderval ( INVALS , i ) enddo end program demo_orderval","tags":"","loc":"sourcefile/demo_orderval.f90.html"},{"title":"test_suite_orderpack.f90 – orderpack","text":"Contents Programs runtest Source Code test_suite_orderpack.f90 Source Code !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT program runtest use M_msg use M_msg , only : str use M_verify use M_verify , only : unit_check_level use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_stop ! full ranking use M_mrgref , only : mrgref use M_mrgrnk , only : mrgrnk ! full sorting use M_inssor , only : inssor use M_refsor , only : refsor ! pertubation use M_ctrper , only : ctrper ! fractile (nth value) use M_fndnth , only : fndnth use M_indnth , only : indnth use M_valnth , only : valnth ! median use M_indmed , only : indmed use M_valmed , only : valmed use M_median , only : median ! use M_refpar , only : refpar use M_rinpar , only : rinpar use M_rnkpar , only : rnkpar use M_inspar , only : inspar use M_rapknr , only : rapknr use M_unipar , only : unipar use M_mulcnt , only : mulcnt use M_unirnk , only : unirnk use M_unista , only : unista use M_uniinv , only : uniinv implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_gen ( 'mrgref' ) call test_gen ( 'mrgrnk' ) call test_gen ( 'inssor' ) call test_gen ( 'refsor' ) call test_ctrper () call test_fndnth () call test_indnth () call test_valnth () call test_indmed () call test_valmed () call test_median () call test_refpar () call test_rinpar () call test_rnkpar () call test_rapknr () call test_inspar () call test_unipar () call test_mulcnt () call test_unirnk () call test_unista () call test_uniinv () call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_gen ( name ) character ( len =* ), intent ( in ) :: name integer , parameter :: isz = 10000 real :: rr ( isz ) real ( kind = dp ) :: dd ( isz ) integer :: ii ( isz ) character ( len = 10 ) :: cc ( isz ) integer :: indx ( isz ) integer :: i call unit_check_start ( name , '-library orderpack' ) ! start tests CALL RANDOM_NUMBER ( RR ) rr = rr * huge ( 0.0 ) select case ( name ) case ( 'inssor' ); call inssor ( rr ) case ( 'refsor' ); call refsor ( rr ) case ( 'mrgrnk' ); call mrgrnk ( rr , indx ); rr = rr ( indx ) case ( 'mrgref' ); call mrgref ( rr , indx ); rr = rr ( indx ) endselect call unit_check ( name , all ( rr ( 1 : isz - 1 ) . le . rr ( 2 : isz )), 'real test' , isz , 'values' ) CALL RANDOM_NUMBER ( RR ) ii = rr * huge ( 0 ) select case ( name ) case ( 'inssor' ); call inssor ( ii ) case ( 'refsor' ); call refsor ( ii ) case ( 'mrgrnk' ); call mrgrnk ( ii , indx ); ii = ii ( indx ) case ( 'mrgref' ); call mrgref ( ii , indx ); ii = ii ( indx ) endselect call unit_check ( name , all ( ii ( 1 : isz - 1 ) . le . ii ( 2 : isz )), 'integer test' , isz , 'values' ) CALL RANDOM_NUMBER ( DD ) dd = dd * huge ( 0.0_dp ) select case ( name ) case ( 'inssor' ); call inssor ( dd ) case ( 'refsor' ); call refsor ( dd ) case ( 'mrgrnk' ); call mrgrnk ( dd , indx ); dd = dd ( indx ) case ( 'mrgref' ); call mrgref ( dd , indx ); dd = dd ( indx ) endselect call unit_check ( name , all ( dd ( 1 : isz - 1 ) . le . dd ( 2 : isz )), 'double test' , isz , 'values' ) do i = 1 , isz cc ( i ) = random_string ( 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 10 ) enddo select case ( name ) case ( 'inssor' ); call inssor ( cc ) case ( 'refsor' ); call refsor ( cc ) case ( 'mrgrnk' ); call mrgrnk ( cc , indx ); cc = cc ( indx ) case ( 'mrgref' ); call mrgref ( cc , indx ); cc = cc ( indx ) endselect call unit_check ( name , all ( cc ( 1 : isz - 1 ) . le . cc ( 2 : isz )), 'string test, random' , isz , 'values' ) call unit_check_done ( name , msg = 'test completed' ) end subroutine test_gen !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ctrper implicit none integer , allocatable :: row (:) integer , allocatable :: xout (:,:) integer :: isz , i , j , jsz real , allocatable :: perturb (:) call unit_check_start ( 'ctrper' , '-library orderpack' ) ! start tests perturb = [ 0.0 , 0.1 , 1.0 ] jsz = size ( perturb ) isz = 200 if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) allocate ( row ( isz )) ! make each row the same initially row = [( i , i = 1 , isz )] * 10 do j = 1 , 3 xout ( j ,:) = row call ctrper ( xout ( j ,:), perturb ( j )) enddo !write(*,'(a)')'count    unchanged  perturbed  random' !do i=1,size(row) !   write(*,'(*(i8,1x))')i,xout(:,i) !enddo call unit_check ( 'ctrper' , all ( xout ( 1 ,:) . eq . row ), 'perturb 0 should not change' ) call unit_check ( 'ctrper' ,. not .( all ( xout ( 3 ,:) . eq . row )), 'perturb 1 should be random,unlikely not changed' ) char : block character ( len = :), allocatable :: xdont (:) xdont = [ character ( len = 20 ) :: 'a' , 'be' , 'car' , 'dam' , 'fan' , 'gas' , 'egg' ] isz = size ( xdont ) !write(*,g)'Original.................:',(trim(xdont(i)),i=1,isz) call ctrper ( xdont , 1.0 ) !write(*,g)'Perturbed ...............:',(trim(xdont(i)),i=1,isz) !write(*,g) endblock char call unit_check_done ( 'ctrper' , msg = 'test completed' ) end subroutine test_ctrper !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_valnth use M_valnth , only : valnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'valnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minval() and maxval() call unit_check ( 'valnth' , valnth ( iarr , 1 ). eq . minval ( iarr ), 'like minval()' ) call unit_check ( 'valnth' , valnth ( iarr , size ( iarr )). eq . maxval ( iarr ), 'like maxval()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'valnth' , valnth ( iarr , 8 ). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'valnth' , valnth ( iarr , imiddle ). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'valnth' , all ([( valnth ( iarr , i ), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'valnth' , msg = 'test completed' ) end subroutine test_valnth !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_indnth use M_indnth , only : indnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'indnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minloc() and maxloc() call unit_check ( 'indnth' , all ( indnth ( iarr , 1 ). eq . minloc ( iarr )), 'like minloc()' ) call unit_check ( 'indnth' , all ( indnth ( iarr , size ( iarr )). eq . maxloc ( iarr )), 'like maxloc()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'indnth' , iarr ( indnth ( iarr , 8 )). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'indnth' , iarr ( indnth ( iarr , imiddle )). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'indnth' , all ([( iarr ( indnth ( iarr , i )), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'indnth' , msg = 'test completed' ) end subroutine test_indnth !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fndnth use M_fndnth , only : fndnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'fndnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minval() and maxval() call unit_check ( 'fndnth' , fndnth ( iarr , 1 ). eq . minval ( iarr ), 'like minval()' ) call unit_check ( 'fndnth' , fndnth ( iarr , size ( iarr )). eq . maxval ( iarr ), 'like maxval()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'fndnth' , fndnth ( iarr , 8 ). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'fndnth' , fndnth ( iarr , imiddle ). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'fndnth' , all ([( fndnth ( iarr , i ), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'fndnth' , msg = 'test completed' ) end subroutine test_fndnth !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_indmed use M_indmed , only : indmed implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) character ( len = :), allocatable :: cdont (:) integer :: ii call unit_check_start ( 'indmed' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call indmed ( xdont , ii ) call unit_check ( 'indmed' , ii . eq . 2. and . xdont ( ii ). eq . 7 0.0 , 'real median' , ii , xdont ( ii )) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call indmed ( idont , ii ) call unit_check ( 'indmed' , ii . eq . 4. and . idont ( ii ). eq . 44 , 'integer median' , ii , idont ( ii )) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call indmed ( ddont , ii ) call unit_check ( 'indmed' , ii . eq . 5. and . ddont ( ii ). eq . 3 3.0d0 , 'doubleprecision median' , ii , ddont ( ii )) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' , 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call indmed ( cdont , ii ) call unit_check ( 'indmed' , ii . eq . 5. and . cdont ( ii ). eq . 'elephant' , 'character median' , ii , cdont ( ii )) ! call unit_check_done ( 'indmed' , msg = 'test completed' ) end subroutine test_indmed !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_valmed use M_valmed , only : valmed implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) call unit_check_start ( 'valmed' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call unit_check ( 'valmed' , valmed ( xdont ). eq . 7 0.0 , 'real valmed' , valmed ( xdont ), 7 0.0 ) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call unit_check ( 'valmed' , valmed ( idont ). eq . 44 , 'integer valmed' , valmed ( idont ), 44 ) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call unit_check ( 'valmed' , valmed ( ddont ). eq . 3 3.0d0 , 'doubleprecision valmed' , valmed ( ddont ), 3 3.0 ) ! call unit_check_done ( 'valmed' , msg = 'test completed' ) end subroutine test_valmed !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_median use M_median , only : median implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) call unit_check_start ( 'median' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call unit_check ( 'median' , median ( xdont ). eq . 7 0.0 , 'real median' , median ( xdont ), 7 0.0 ) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call unit_check ( 'median' , median ( idont ). eq . 49 , 'integer median' , median ( idont ), 49 ) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call unit_check ( 'median' , median ( ddont ). eq . 4 9.5d0 , 'doubleprecision median' , median ( ddont ), 4 9.5 ) ! call unit_check_done ( 'median' , msg = 'test completed' ) end subroutine test_median !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_inspar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: i call unit_check_start ( 'inspar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call inspar ( valsr , little ) call unit_check ( 'inspar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'inspar' , msg = 'test completed' ) end subroutine test_inspar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_rapknr () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rapknr' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rapknr ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rapknr' , all ( valsr ( 1 : little - 1 ) . ge . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rapknr' , msg = 'test completed' ) end subroutine test_rapknr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_rnkpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rnkpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rnkpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rnkpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rnkpar' , msg = 'test completed' ) end subroutine test_rnkpar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_rinpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rinpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rinpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rinpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rinpar' , msg = 'test completed' ) end subroutine test_rinpar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_refpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'refpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call refpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'refpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'refpar' , msg = 'test completed' ) end subroutine test_refpar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unipar () use M_unipar , only : unipar implicit none integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord call unit_check_start ( 'unipar' , '-library orderpack' ) ! start tests ! xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( nord )) ! call unipar ( xdont , irngt , nord ) call unit_check ( 'unipar' , nord . eq . 5 , 'number of unique values found' , nord , 5 ) call unit_check ( 'unipar' , all ( irngt ( 1 : nord ) . eq . [ 11 , 5 , 2 , 7 , 3 ]) , 'returned indices' ) call unit_check ( 'unipar' , all ( xdont ( irngt ( 1 : nord )) . eq .[ 1 , 4 , 5 , 6 , 7 ]) , 'returned values' ) call unit_check_done ( 'unipar' , msg = 'test completed' ) end subroutine test_unipar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mulcnt () character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) integer :: csz integer :: i call unit_check_start ( 'mulcnt' , '-library orderpack' ) ! start tests ! strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call mulcnt ( strings , cindx ) call unit_check ( 'mulcnt' , all ( cindx . eq . [ 2 , 4 , 3 , 5 , 5 , 2 , 4 , 3 , 5 , 5 , 4 , 4 , 3 , 1 , 5 ]) , 'returned values' ) call unit_check_done ( 'mulcnt' , msg = 'test completed' ) end subroutine test_mulcnt !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unirnk () integer , allocatable :: xvalt (:) integer , allocatable :: irngt (:) integer :: nuni call unit_check_start ( 'unirnk' , '-library orderpack' ) ! start tests xvalt = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( xvalt ))) call unirnk ( xvalt , irngt , nuni ) call unit_check ( 'unirnk' , nuni . eq . 8 , 'number of indices. got' , nuni , 'expected' , 8 ) call unit_check ( 'unirnk' , all ( irngt (: nuni ) . eq . [ 4 , 5 , 2 , 7 , 3 , 8 , 9 , 1 ]) , 'returned indices' ) call unit_check ( 'unirnk' , all ( xvalt ( irngt (: nuni )) . eq . [ 1 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) , 'sorted data' ) call unit_check_done ( 'unirnk' , msg = 'test completed' ) end subroutine test_unirnk !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unista () integer , allocatable :: xdont (:) integer :: nuni call unit_check_start ( 'unista' , '-library orderpack' ) ! start tests xdont = [ 44 , 33 , 33 , 33 , 22 , 11 , 33 , 44 , 55 , 33 ] call unista ( xdont , nuni ) call unit_check ( 'unista' , nuni . eq . 5 , 'number of indices. got' , nuni , 'expected' , 5 ) call unit_check ( 'unista' , all ( xdont (: nuni ) . eq . [ 44 , 33 , 22 , 11 , 55 ]) , 'unique values' ) call unit_check_done ( 'unista' , msg = 'test completed' ) end subroutine test_unista !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_uniinv () integer , allocatable :: xdont (:) integer , allocatable :: igoest (:) integer , allocatable :: out (:) integer :: imx integer :: i xdont = [ 10 , 20 , 30 , 10 , 20 , 30 , 10 , 20 , 30 ] if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( xdont ))) call uniinv ( xdont , igoest ) call unit_check ( 'uniinv' , all ( igoest . eq . [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ]) , 'returned indices' ) imx = maxval ( igoest ) call unit_check ( 'unista' , imx . eq . 3 , 'unique indices. got' , imx , 'expected' , 3 ) if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( xdont ) out ( igoest ( i )) = xdont ( i ) enddo call unit_check ( 'uniinv' , all ( xdont . eq . [ 10 , 20 , 30 ]) , 'sorted unique values' ) call unit_check_done ( 'uniinv' , msg = 'test completed' ) end subroutine test_uniinv !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT function random_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","loc":"sourcefile/test_suite_orderpack.f90.html"},{"title":"test_mrgrnk.f90 – orderpack","text":"Contents Programs test_mrgrnk Source Code test_mrgrnk.f90 Source Code program test_mrgrnk ! depending on the compiler and options you might have to unlimit stacksize ! to avoid segmentation faults when using large arrays, or specify on ! compiler to put arrays on heap. ! !    ulimit -s unlimited # bash shell use M_mrgrnk , only : mrgrnk implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000000 real ( kind = dp ), allocatable :: dd (:) real ( kind = dp ) :: pp integer , allocatable :: indx (:) integer :: i , j , k , m real ( kind = dp ) :: start , finish ! ! set up storage ! if ( allocated ( indx )) deallocate ( indx ) allocate ( indx ( isz )) if ( allocated ( dd )) deallocate ( dd ) allocate ( dd ( isz )) ! ! make some random numbers ! call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo !do i=1,isz !   write(*,*)i,indx(i),dd(indx(i)) !enddo write ( * , * ) 'for MRGRNK(3f):         ' write ( * , * ) 'number of values to sort' , isz ! sort data call cpu_time ( start ) call mrgrnk ( dd , indx ) call cpu_time ( finish ) write ( * , * ) \"Processor Time (random)=              \" , finish - start , \" seconds.\" ! ! do some checks ! m = 0 do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , * ) 'ERROR: data not sorted i=' , i , 'indx=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) m = m + 1 endif enddo ! time if already sorted dd = dd ( indx ) call cpu_time ( start ) call mrgrnk ( dd , indx ) call cpu_time ( finish ) write ( * , * ) \"Processor Time (already sorted)=      \" , finish - start , \" seconds.\" ! time if initially reverse sorted dd = dd ( isz : 1 : - 1 ) call cpu_time ( start ) call mrgrnk ( dd , indx ) call cpu_time ( finish ) write ( * , * ) \"Processor Time (input reverse sorted)=\" , finish - start , \" seconds.\" write ( * , * ) 'lowest                  ' , dd ( indx ( 1 )), minval ( dd ),& & dd ( indx ( 1 )). eq . minval ( dd ) write ( * , * ) 'highest                 ' , dd ( indx ( size ( indx ))), maxval ( dd ),& & dd ( indx ( size ( indx ))). eq . maxval ( dd ) write ( * , * ) 'smallest absolute value ' , minval ( abs ( dd )) write ( * , * ) 'for reference huge is   ' , huge ( 0.0_dp ) write ( * , * ) '              tiny is   ' , tiny ( 0.0_dp ) write ( * , * ) '              epsilon is' , epsilon ( 0.0_dp ) if ( m . eq . 0 ) then write ( * , * ) 'sort passed' else write ( * , * ) 'sort failed, bad=' , m endif end program test_mrgrnk","tags":"","loc":"sourcefile/test_mrgrnk.f90.html"},{"title":"inssor – orderpack","text":"public interface inssor Contents Module Procedures real64_inssor real32_inssor int32_inssor f_char_inssor Module Procedures private subroutine real64_inssor(INOUTVALS) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS private subroutine real32_inssor(INOUTVALS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS private subroutine int32_inssor(INOUTVALS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS private subroutine f_char_inssor(INOUTVALS) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS","tags":"","loc":"interface/inssor.html"},{"title":"indnth – orderpack","text":"public interface indnth Contents Module Procedures real64_indnth real32_indnth int32_indnth Module Procedures private function real64_indnth(INVALS, NORD) result(INDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer private function real32_indnth(INVALS, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer private function int32_indnth(INVALS, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer","tags":"","loc":"interface/indnth.html"},{"title":"mulcnt – orderpack","text":"public interface mulcnt Contents Module Procedures real64_mulcnt real32_mulcnt int32_mulcnt f_char_mulcnt Module Procedures private subroutine real64_mulcnt(INVALS, IMULT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT private subroutine real32_mulcnt(INVALS, IMULT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT private subroutine int32_mulcnt(INVALS, IMULT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT private subroutine f_char_mulcnt(INVALS, IMULT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT","tags":"","loc":"interface/mulcnt.html"},{"title":"unipar – orderpack","text":"public interface unipar Contents Module Procedures real64_unipar real32_unipar int32_unipar Module Procedures private subroutine real64_unipar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine real32_unipar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine int32_unipar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD","tags":"","loc":"interface/unipar.html"},{"title":"median – orderpack","text":"public interface median Contents Module Procedures real64_median real32_median int32_median Module Procedures private function real64_median(INVALS) result(median) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS Return Value real(kind=real64) private function real32_median(INVALS) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS Return Value real(kind=real32) private function int32_median(INVALS) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS Return Value integer(kind=int32)","tags":"","loc":"interface/median.html"},{"title":"refsor – orderpack","text":"public interface refsor Contents Module Procedures real64_refsor real32_refsor int32_refsor f_char_refsor Module Procedures private subroutine real64_refsor(INOUTVALS) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS private subroutine real32_refsor(INOUTVALS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS private subroutine int32_refsor(INOUTVALS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS private subroutine f_char_refsor(INOUTVALS) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS","tags":"","loc":"interface/refsor.html"},{"title":"indmed – orderpack","text":"public interface indmed Contents Module Procedures real64_indmed real32_indmed int32_indmed f_char_indmed Module Procedures private subroutine real64_indmed(INVALS, OUTORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD private subroutine real32_indmed(INVALS, OUTORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD private subroutine int32_indmed(INVALS, OUTORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD private subroutine f_char_indmed(INVALS, OUTORD) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD","tags":"","loc":"interface/indmed.html"},{"title":"mrgrnk – orderpack","text":"public interface mrgrnk Contents Module Procedures real64_mrgrnk real32_mrgrnk int32_mrgrnk f_char_mrgrnk Module Procedures private subroutine real64_mrgrnk(INVALS, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgrnk(INVALS, IRNGT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgrnk(INVALS, IRNGT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgrnk(INVALS, IRNGT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"interface/mrgrnk.html"},{"title":"valmed – orderpack","text":"public interface valmed Contents Module Procedures real64_valmed real32_valmed int32_valmed Module Procedures private recursive function real64_valmed(INVALS) result(res_med) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS Return Value real(kind=real64) private recursive function real32_valmed(INVALS) result(res_med) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS Return Value real(kind=real32) private recursive function int32_valmed(INVALS) result(res_med) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS Return Value integer(kind=int32)","tags":"","loc":"interface/valmed.html"},{"title":"uniinv – orderpack","text":"public interface uniinv Contents Module Procedures real64_uniinv real32_uniinv int32_uniinv f_char_uniinv Module Procedures private subroutine real64_uniinv(INVALS, IGOEST) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST private subroutine real32_uniinv(INVALS, IGOEST) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST private subroutine int32_uniinv(INVALS, IGOEST) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST private subroutine f_char_uniinv(INVALS, IGOEST) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST","tags":"","loc":"interface/uniinv.html"},{"title":"ctrper – orderpack","text":"public interface ctrper Contents Module Procedures real64_ctrper real32_ctrper int32_ctrper f_char_ctrper Module Procedures private subroutine real64_CTRPER(INOUTVALS, CLOSENESS) Shuffle the array INOUTVALS randomly, leaving elements close to their\n   initial locations. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS private subroutine real32_CTRPER(INOUTVALS, CLOSENESS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS private subroutine int32_CTRPER(INOUTVALS, CLOSENESS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS private subroutine f_char_CTRPER(INOUTVALS, CLOSENESS) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS","tags":"","loc":"interface/ctrper.html"},{"title":"valnth – orderpack","text":"public interface valnth Contents Module Procedures real64_valnth real32_valnth int32_valnth Module Procedures private function real64_valnth(INVALS, NORD) result(valnth) ORDERVAL(3f) returns the  NORDth (ascending order) value of INVALS,\n   i.e. the fractile of order NORD/SIZE(INVALS). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value real(kind=real64) private function real32_valnth(INVALS, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value real(kind=real32) private function int32_valnth(INVALS, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer(kind=int32)","tags":"","loc":"interface/valnth.html"},{"title":"inspar – orderpack","text":"public interface inspar Contents Module Procedures real64_inspar real32_inspar int32_inspar f_char_inspar Module Procedures private subroutine real64_inspar(INOUTVALS, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD private subroutine real32_inspar(INOUTVALS, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD private subroutine int32_inspar(INOUTVALS, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD private subroutine f_char_inspar(INOUTVALS, NORD) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD","tags":"","loc":"interface/inspar.html"},{"title":"rapknr – orderpack","text":"public interface rapknr Contents Module Procedures real64_rapknr real32_rapknr int32_rapknr Module Procedures private subroutine real64_rapknr(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rapknr(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rapknr(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/rapknr.html"},{"title":"mrgref – orderpack","text":"public interface mrgref Contents Module Procedures real64_mrgref real32_mrgref int32_mrgref f_char_mrgref Module Procedures private subroutine real64_mrgref(INVALS, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgref(INVALS, IRNGT) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgref(INVALS, IRNGT) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgref(INVALS, IRNGT) Read more… Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"interface/mrgref.html"},{"title":"unirnk – orderpack","text":"public interface unirnk Contents Module Procedures real64_unirnk real32_unirnk int32_unirnk Module Procedures private subroutine real64_unirnk(INVALS, IRNGT, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine real32_unirnk(INVALS, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine int32_unirnk(INVALS, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI","tags":"","loc":"interface/unirnk.html"},{"title":"rnkpar – orderpack","text":"public interface rnkpar Contents Module Procedures real64_rnkpar real32_rnkpar int32_rnkpar Module Procedures private subroutine real64_rnkpar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rnkpar(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rnkpar(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/rnkpar.html"},{"title":"unista – orderpack","text":"public interface unista Contents Module Procedures real64_unista real32_unista int32_unista f_char_unista Module Procedures private subroutine real64_unista(INOUTVALS, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI private subroutine real32_unista(INOUTVALS, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI private subroutine int32_unista(INOUTVALS, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI private subroutine f_char_unista(INOUTVALS, NUNI) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI","tags":"","loc":"interface/unista.html"},{"title":"fndnth – orderpack","text":"public interface fndnth Contents Module Procedures real64_fndnth real32_fndnth int32_fndnth Module Procedures private function real64_fndnth(INVALS, INORD) result(FNDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(in) :: INORD Return Value real(kind=real64) private function real32_fndnth(INVALS, INORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: INORD Return Value real(kind=real32) private function int32_fndnth(INVALS, INORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: INORD Return Value integer(kind=int32)","tags":"","loc":"interface/fndnth.html"},{"title":"rinpar – orderpack","text":"public interface rinpar Contents Module Procedures real64_rinpar real32_rinpar int32_rinpar Module Procedures private subroutine real64_rinpar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rinpar(INVALS, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rinpar(INVALS, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/rinpar.html"},{"title":"refpar – orderpack","text":"public interface refpar Contents Module Procedures real64_refpar real32_refpar int32_refpar Module Procedures private subroutine real64_refpar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_refpar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_refpar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/refpar.html"},{"title":"printme – orderpack","text":"subroutine printme(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Contents Variables ii Source Code printme Variables Type Visibility Attributes Name Initial integer, public :: ii Source Code subroutine printme ( n ) integer , intent ( in ) :: n integer :: ii ii = orderloc ( iarr , n ) print sp , 'nord=' , n , ' index=' , ii , ' fractile=' , iarr ( ii ) end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"printme – orderpack","text":"subroutine printme() Arguments None Contents None","tags":"","loc":"proc/printme~2.html"},{"title":"printme – orderpack","text":"subroutine printme() Arguments None Contents Variables irngt nuni Variables Type Visibility Attributes Name Initial integer, public, allocatable :: irngt (:) integer, public :: nuni","tags":"","loc":"proc/printme~3.html"},{"title":"random_string – orderpack","text":"function random_string(chars, length) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(in) :: length Return Value character(len=:),\n  allocatable Contents Variables i ilen which x Source Code random_string Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ilen integer, public :: which real, public :: x Source Code function random_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_string","tags":"","loc":"proc/random_string.html"},{"title":"test_ctrper – orderpack","text":"subroutine test_ctrper() Arguments None Contents Variables i isz j jsz perturb row xout Source Code test_ctrper Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: isz integer, public :: j integer, public :: jsz real, public, allocatable :: perturb (:) integer, public, allocatable :: row (:) integer, public, allocatable :: xout (:,:) Source Code subroutine test_ctrper implicit none integer , allocatable :: row (:) integer , allocatable :: xout (:,:) integer :: isz , i , j , jsz real , allocatable :: perturb (:) call unit_check_start ( 'ctrper' , '-library orderpack' ) ! start tests perturb = [ 0.0 , 0.1 , 1.0 ] jsz = size ( perturb ) isz = 200 if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) allocate ( row ( isz )) ! make each row the same initially row = [( i , i = 1 , isz )] * 10 do j = 1 , 3 xout ( j ,:) = row call ctrper ( xout ( j ,:), perturb ( j )) enddo !write(*,'(a)')'count    unchanged  perturbed  random' !do i=1,size(row) !   write(*,'(*(i8,1x))')i,xout(:,i) !enddo call unit_check ( 'ctrper' , all ( xout ( 1 ,:) . eq . row ), 'perturb 0 should not change' ) call unit_check ( 'ctrper' ,. not .( all ( xout ( 3 ,:) . eq . row )), 'perturb 1 should be random,unlikely not changed' ) char : block character ( len = :), allocatable :: xdont (:) xdont = [ character ( len = 20 ) :: 'a' , 'be' , 'car' , 'dam' , 'fan' , 'gas' , 'egg' ] isz = size ( xdont ) !write(*,g)'Original.................:',(trim(xdont(i)),i=1,isz) call ctrper ( xdont , 1.0 ) !write(*,g)'Perturbed ...............:',(trim(xdont(i)),i=1,isz) !write(*,g) endblock char call unit_check_done ( 'ctrper' , msg = 'test completed' ) end subroutine test_ctrper","tags":"","loc":"proc/test_ctrper.html"},{"title":"test_fndnth – orderpack","text":"subroutine test_fndnth() Uses M_fndnth Arguments None Contents Variables i iarr imiddle Source Code test_fndnth Variables Type Visibility Attributes Name Initial integer, public :: i integer, public, allocatable :: iarr (:) integer, public :: imiddle Source Code subroutine test_fndnth use M_fndnth , only : fndnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'fndnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minval() and maxval() call unit_check ( 'fndnth' , fndnth ( iarr , 1 ). eq . minval ( iarr ), 'like minval()' ) call unit_check ( 'fndnth' , fndnth ( iarr , size ( iarr )). eq . maxval ( iarr ), 'like maxval()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'fndnth' , fndnth ( iarr , 8 ). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'fndnth' , fndnth ( iarr , imiddle ). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'fndnth' , all ([( fndnth ( iarr , i ), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'fndnth' , msg = 'test completed' ) end subroutine test_fndnth","tags":"","loc":"proc/test_fndnth.html"},{"title":"test_gen – orderpack","text":"subroutine test_gen(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Contents Variables cc dd i ii indx isz rr Source Code test_gen Variables Type Visibility Attributes Name Initial character(len=10), public :: cc (isz) real(kind=dp), public :: dd (isz) integer, public :: i integer, public :: ii (isz) integer, public :: indx (isz) integer, public, parameter :: isz = 10000 real, public :: rr (isz) Source Code subroutine test_gen ( name ) character ( len =* ), intent ( in ) :: name integer , parameter :: isz = 10000 real :: rr ( isz ) real ( kind = dp ) :: dd ( isz ) integer :: ii ( isz ) character ( len = 10 ) :: cc ( isz ) integer :: indx ( isz ) integer :: i call unit_check_start ( name , '-library orderpack' ) ! start tests CALL RANDOM_NUMBER ( RR ) rr = rr * huge ( 0.0 ) select case ( name ) case ( 'inssor' ); call inssor ( rr ) case ( 'refsor' ); call refsor ( rr ) case ( 'mrgrnk' ); call mrgrnk ( rr , indx ); rr = rr ( indx ) case ( 'mrgref' ); call mrgref ( rr , indx ); rr = rr ( indx ) endselect call unit_check ( name , all ( rr ( 1 : isz - 1 ) . le . rr ( 2 : isz )), 'real test' , isz , 'values' ) CALL RANDOM_NUMBER ( RR ) ii = rr * huge ( 0 ) select case ( name ) case ( 'inssor' ); call inssor ( ii ) case ( 'refsor' ); call refsor ( ii ) case ( 'mrgrnk' ); call mrgrnk ( ii , indx ); ii = ii ( indx ) case ( 'mrgref' ); call mrgref ( ii , indx ); ii = ii ( indx ) endselect call unit_check ( name , all ( ii ( 1 : isz - 1 ) . le . ii ( 2 : isz )), 'integer test' , isz , 'values' ) CALL RANDOM_NUMBER ( DD ) dd = dd * huge ( 0.0_dp ) select case ( name ) case ( 'inssor' ); call inssor ( dd ) case ( 'refsor' ); call refsor ( dd ) case ( 'mrgrnk' ); call mrgrnk ( dd , indx ); dd = dd ( indx ) case ( 'mrgref' ); call mrgref ( dd , indx ); dd = dd ( indx ) endselect call unit_check ( name , all ( dd ( 1 : isz - 1 ) . le . dd ( 2 : isz )), 'double test' , isz , 'values' ) do i = 1 , isz cc ( i ) = random_string ( 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 10 ) enddo select case ( name ) case ( 'inssor' ); call inssor ( cc ) case ( 'refsor' ); call refsor ( cc ) case ( 'mrgrnk' ); call mrgrnk ( cc , indx ); cc = cc ( indx ) case ( 'mrgref' ); call mrgref ( cc , indx ); cc = cc ( indx ) endselect call unit_check ( name , all ( cc ( 1 : isz - 1 ) . le . cc ( 2 : isz )), 'string test, random' , isz , 'values' ) call unit_check_done ( name , msg = 'test completed' ) end subroutine test_gen","tags":"","loc":"proc/test_gen.html"},{"title":"test_indmed – orderpack","text":"subroutine test_indmed() Uses M_indmed Arguments None Contents Variables cdont ddont idont ii xdont Source Code test_indmed Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cdont (:) real(kind=dp), public, allocatable :: ddont (:) integer, public, allocatable :: idont (:) integer, public :: ii real, public, allocatable :: xdont (:) Source Code subroutine test_indmed use M_indmed , only : indmed implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) character ( len = :), allocatable :: cdont (:) integer :: ii call unit_check_start ( 'indmed' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call indmed ( xdont , ii ) call unit_check ( 'indmed' , ii . eq . 2. and . xdont ( ii ). eq . 7 0.0 , 'real median' , ii , xdont ( ii )) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call indmed ( idont , ii ) call unit_check ( 'indmed' , ii . eq . 4. and . idont ( ii ). eq . 44 , 'integer median' , ii , idont ( ii )) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call indmed ( ddont , ii ) call unit_check ( 'indmed' , ii . eq . 5. and . ddont ( ii ). eq . 3 3.0d0 , 'doubleprecision median' , ii , ddont ( ii )) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' , 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call indmed ( cdont , ii ) call unit_check ( 'indmed' , ii . eq . 5. and . cdont ( ii ). eq . 'elephant' , 'character median' , ii , cdont ( ii )) ! call unit_check_done ( 'indmed' , msg = 'test completed' ) end subroutine test_indmed","tags":"","loc":"proc/test_indmed.html"},{"title":"test_indnth – orderpack","text":"subroutine test_indnth() Uses M_indnth Arguments None Contents Variables i iarr imiddle Source Code test_indnth Variables Type Visibility Attributes Name Initial integer, public :: i integer, public, allocatable :: iarr (:) integer, public :: imiddle Source Code subroutine test_indnth use M_indnth , only : indnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'indnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minloc() and maxloc() call unit_check ( 'indnth' , all ( indnth ( iarr , 1 ). eq . minloc ( iarr )), 'like minloc()' ) call unit_check ( 'indnth' , all ( indnth ( iarr , size ( iarr )). eq . maxloc ( iarr )), 'like maxloc()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'indnth' , iarr ( indnth ( iarr , 8 )). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'indnth' , iarr ( indnth ( iarr , imiddle )). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'indnth' , all ([( iarr ( indnth ( iarr , i )), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'indnth' , msg = 'test completed' ) end subroutine test_indnth","tags":"","loc":"proc/test_indnth.html"},{"title":"test_inspar – orderpack","text":"subroutine test_inspar() Arguments None Contents Variables big i little valsr Source Code test_inspar Variables Type Visibility Attributes Name Initial integer, public, parameter :: big = 2000 integer, public :: i integer, public, parameter :: little = 300 real, public :: valsr (big) Source Code subroutine test_inspar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: i call unit_check_start ( 'inspar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call inspar ( valsr , little ) call unit_check ( 'inspar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'inspar' , msg = 'test completed' ) end subroutine test_inspar","tags":"","loc":"proc/test_inspar.html"},{"title":"test_median – orderpack","text":"subroutine test_median() Uses M_median Arguments None Contents Variables ddont idont xdont Source Code test_median Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ddont (:) integer, public, allocatable :: idont (:) real, public, allocatable :: xdont (:) Source Code subroutine test_median use M_median , only : median implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) call unit_check_start ( 'median' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call unit_check ( 'median' , median ( xdont ). eq . 7 0.0 , 'real median' , median ( xdont ), 7 0.0 ) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call unit_check ( 'median' , median ( idont ). eq . 49 , 'integer median' , median ( idont ), 49 ) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call unit_check ( 'median' , median ( ddont ). eq . 4 9.5d0 , 'doubleprecision median' , median ( ddont ), 4 9.5 ) ! call unit_check_done ( 'median' , msg = 'test completed' ) end subroutine test_median","tags":"","loc":"proc/test_median.html"},{"title":"test_mulcnt – orderpack","text":"subroutine test_mulcnt() Arguments None Contents Variables cindx csz i strings Source Code test_mulcnt Variables Type Visibility Attributes Name Initial integer, public, allocatable :: cindx (:) integer, public :: csz integer, public :: i character(len=20), public, allocatable :: strings (:) Source Code subroutine test_mulcnt () character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) integer :: csz integer :: i call unit_check_start ( 'mulcnt' , '-library orderpack' ) ! start tests ! strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call mulcnt ( strings , cindx ) call unit_check ( 'mulcnt' , all ( cindx . eq . [ 2 , 4 , 3 , 5 , 5 , 2 , 4 , 3 , 5 , 5 , 4 , 4 , 3 , 1 , 5 ]) , 'returned values' ) call unit_check_done ( 'mulcnt' , msg = 'test completed' ) end subroutine test_mulcnt","tags":"","loc":"proc/test_mulcnt.html"},{"title":"test_rapknr – orderpack","text":"subroutine test_rapknr() Arguments None Contents Variables big i indx little valsr Source Code test_rapknr Variables Type Visibility Attributes Name Initial integer, public, parameter :: big = 2000 integer, public :: i integer, public :: indx (little) integer, public, parameter :: little = 300 real, public :: valsr (big) Source Code subroutine test_rapknr () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rapknr' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rapknr ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rapknr' , all ( valsr ( 1 : little - 1 ) . ge . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rapknr' , msg = 'test completed' ) end subroutine test_rapknr","tags":"","loc":"proc/test_rapknr.html"},{"title":"test_refpar – orderpack","text":"subroutine test_refpar() Arguments None Contents Variables big i indx little valsr Source Code test_refpar Variables Type Visibility Attributes Name Initial integer, public, parameter :: big = 2000 integer, public :: i integer, public :: indx (little) integer, public, parameter :: little = 300 real, public :: valsr (big) Source Code subroutine test_refpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'refpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call refpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'refpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'refpar' , msg = 'test completed' ) end subroutine test_refpar","tags":"","loc":"proc/test_refpar.html"},{"title":"test_rinpar – orderpack","text":"subroutine test_rinpar() Arguments None Contents Variables big i indx little valsr Source Code test_rinpar Variables Type Visibility Attributes Name Initial integer, public, parameter :: big = 2000 integer, public :: i integer, public :: indx (little) integer, public, parameter :: little = 300 real, public :: valsr (big) Source Code subroutine test_rinpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rinpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rinpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rinpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rinpar' , msg = 'test completed' ) end subroutine test_rinpar","tags":"","loc":"proc/test_rinpar.html"},{"title":"test_rnkpar – orderpack","text":"subroutine test_rnkpar() Arguments None Contents Variables big i indx little valsr Source Code test_rnkpar Variables Type Visibility Attributes Name Initial integer, public, parameter :: big = 2000 integer, public :: i integer, public :: indx (little) integer, public, parameter :: little = 300 real, public :: valsr (big) Source Code subroutine test_rnkpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rnkpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rnkpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rnkpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rnkpar' , msg = 'test completed' ) end subroutine test_rnkpar","tags":"","loc":"proc/test_rnkpar.html"},{"title":"test_uniinv – orderpack","text":"subroutine test_uniinv() Arguments None Contents Variables i igoest imx out xdont Source Code test_uniinv Variables Type Visibility Attributes Name Initial integer, public :: i integer, public, allocatable :: igoest (:) integer, public :: imx integer, public, allocatable :: out (:) integer, public, allocatable :: xdont (:) Source Code subroutine test_uniinv () integer , allocatable :: xdont (:) integer , allocatable :: igoest (:) integer , allocatable :: out (:) integer :: imx integer :: i xdont = [ 10 , 20 , 30 , 10 , 20 , 30 , 10 , 20 , 30 ] if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( xdont ))) call uniinv ( xdont , igoest ) call unit_check ( 'uniinv' , all ( igoest . eq . [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ]) , 'returned indices' ) imx = maxval ( igoest ) call unit_check ( 'unista' , imx . eq . 3 , 'unique indices. got' , imx , 'expected' , 3 ) if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( xdont ) out ( igoest ( i )) = xdont ( i ) enddo call unit_check ( 'uniinv' , all ( xdont . eq . [ 10 , 20 , 30 ]) , 'sorted unique values' ) call unit_check_done ( 'uniinv' , msg = 'test completed' ) end subroutine test_uniinv","tags":"","loc":"proc/test_uniinv.html"},{"title":"test_unipar – orderpack","text":"subroutine test_unipar() Uses M_unipar Arguments None Contents Variables irngt nord xdont Source Code test_unipar Variables Type Visibility Attributes Name Initial integer, public, allocatable :: irngt (:) integer, public :: nord integer, public, allocatable :: xdont (:) Source Code subroutine test_unipar () use M_unipar , only : unipar implicit none integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord call unit_check_start ( 'unipar' , '-library orderpack' ) ! start tests ! xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( nord )) ! call unipar ( xdont , irngt , nord ) call unit_check ( 'unipar' , nord . eq . 5 , 'number of unique values found' , nord , 5 ) call unit_check ( 'unipar' , all ( irngt ( 1 : nord ) . eq . [ 11 , 5 , 2 , 7 , 3 ]) , 'returned indices' ) call unit_check ( 'unipar' , all ( xdont ( irngt ( 1 : nord )) . eq .[ 1 , 4 , 5 , 6 , 7 ]) , 'returned values' ) call unit_check_done ( 'unipar' , msg = 'test completed' ) end subroutine test_unipar","tags":"","loc":"proc/test_unipar.html"},{"title":"test_unirnk – orderpack","text":"subroutine test_unirnk() Arguments None Contents Variables irngt nuni xvalt Source Code test_unirnk Variables Type Visibility Attributes Name Initial integer, public, allocatable :: irngt (:) integer, public :: nuni integer, public, allocatable :: xvalt (:) Source Code subroutine test_unirnk () integer , allocatable :: xvalt (:) integer , allocatable :: irngt (:) integer :: nuni call unit_check_start ( 'unirnk' , '-library orderpack' ) ! start tests xvalt = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( xvalt ))) call unirnk ( xvalt , irngt , nuni ) call unit_check ( 'unirnk' , nuni . eq . 8 , 'number of indices. got' , nuni , 'expected' , 8 ) call unit_check ( 'unirnk' , all ( irngt (: nuni ) . eq . [ 4 , 5 , 2 , 7 , 3 , 8 , 9 , 1 ]) , 'returned indices' ) call unit_check ( 'unirnk' , all ( xvalt ( irngt (: nuni )) . eq . [ 1 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) , 'sorted data' ) call unit_check_done ( 'unirnk' , msg = 'test completed' ) end subroutine test_unirnk","tags":"","loc":"proc/test_unirnk.html"},{"title":"test_unista – orderpack","text":"subroutine test_unista() Arguments None Contents Variables nuni xdont Source Code test_unista Variables Type Visibility Attributes Name Initial integer, public :: nuni integer, public, allocatable :: xdont (:) Source Code subroutine test_unista () integer , allocatable :: xdont (:) integer :: nuni call unit_check_start ( 'unista' , '-library orderpack' ) ! start tests xdont = [ 44 , 33 , 33 , 33 , 22 , 11 , 33 , 44 , 55 , 33 ] call unista ( xdont , nuni ) call unit_check ( 'unista' , nuni . eq . 5 , 'number of indices. got' , nuni , 'expected' , 5 ) call unit_check ( 'unista' , all ( xdont (: nuni ) . eq . [ 44 , 33 , 22 , 11 , 55 ]) , 'unique values' ) call unit_check_done ( 'unista' , msg = 'test completed' ) end subroutine test_unista","tags":"","loc":"proc/test_unista.html"},{"title":"test_valmed – orderpack","text":"subroutine test_valmed() Uses M_valmed Arguments None Contents Variables ddont idont xdont Source Code test_valmed Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ddont (:) integer, public, allocatable :: idont (:) real, public, allocatable :: xdont (:) Source Code subroutine test_valmed use M_valmed , only : valmed implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) call unit_check_start ( 'valmed' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call unit_check ( 'valmed' , valmed ( xdont ). eq . 7 0.0 , 'real valmed' , valmed ( xdont ), 7 0.0 ) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call unit_check ( 'valmed' , valmed ( idont ). eq . 44 , 'integer valmed' , valmed ( idont ), 44 ) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call unit_check ( 'valmed' , valmed ( ddont ). eq . 3 3.0d0 , 'doubleprecision valmed' , valmed ( ddont ), 3 3.0 ) ! call unit_check_done ( 'valmed' , msg = 'test completed' ) end subroutine test_valmed","tags":"","loc":"proc/test_valmed.html"},{"title":"test_valnth – orderpack","text":"subroutine test_valnth() Uses M_valnth Arguments None Contents Variables i iarr imiddle Source Code test_valnth Variables Type Visibility Attributes Name Initial integer, public :: i integer, public, allocatable :: iarr (:) integer, public :: imiddle Source Code subroutine test_valnth use M_valnth , only : valnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'valnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minval() and maxval() call unit_check ( 'valnth' , valnth ( iarr , 1 ). eq . minval ( iarr ), 'like minval()' ) call unit_check ( 'valnth' , valnth ( iarr , size ( iarr )). eq . maxval ( iarr ), 'like maxval()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'valnth' , valnth ( iarr , 8 ). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'valnth' , valnth ( iarr , imiddle ). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'valnth' , all ([( valnth ( iarr , i ), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'valnth' , msg = 'test completed' ) end subroutine test_valnth","tags":"","loc":"proc/test_valnth.html"},{"title":"M_inssor – orderpack","text":"Uses iso_fortran_env Contents Interfaces inssor Interfaces public interface inssor private subroutine real64_inssor(INOUTVALS) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS private subroutine real32_inssor(INOUTVALS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS private subroutine int32_inssor(INOUTVALS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS private subroutine f_char_inssor(INOUTVALS) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS","tags":"","loc":"module/m_inssor.html"},{"title":"M_indnth – orderpack","text":"Uses iso_fortran_env Contents Interfaces indnth Interfaces public interface indnth private function real64_indnth(INVALS, NORD) result(INDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer private function real32_indnth(INVALS, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer private function int32_indnth(INVALS, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer","tags":"","loc":"module/m_indnth.html"},{"title":"M_mulcnt – orderpack","text":"Uses iso_fortran_env M_uniinv Contents Interfaces mulcnt Interfaces public interface mulcnt private subroutine real64_mulcnt(INVALS, IMULT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT private subroutine real32_mulcnt(INVALS, IMULT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT private subroutine int32_mulcnt(INVALS, IMULT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT private subroutine f_char_mulcnt(INVALS, IMULT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IMULT","tags":"","loc":"module/m_mulcnt.html"},{"title":"M_unipar – orderpack","text":"Uses iso_fortran_env Contents Interfaces unipar Interfaces public interface unipar private subroutine real64_unipar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine real32_unipar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine int32_unipar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD","tags":"","loc":"module/m_unipar.html"},{"title":"M_median – orderpack","text":"Uses iso_fortran_env Contents Interfaces median Interfaces public interface median private function real64_median(INVALS) result(median) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS Return Value real(kind=real64) private function real32_median(INVALS) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS Return Value real(kind=real32) private function int32_median(INVALS) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS Return Value integer(kind=int32)","tags":"","loc":"module/m_median.html"},{"title":"M_refsor – orderpack","text":"Uses iso_fortran_env Contents Interfaces refsor Interfaces public interface refsor private subroutine real64_refsor(INOUTVALS) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS private subroutine real32_refsor(INOUTVALS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS private subroutine int32_refsor(INOUTVALS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS private subroutine f_char_refsor(INOUTVALS) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS","tags":"","loc":"module/m_refsor.html"},{"title":"M_indmed – orderpack","text":"Uses iso_fortran_env Contents Interfaces indmed Interfaces public interface indmed private subroutine real64_indmed(INVALS, OUTORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD private subroutine real32_indmed(INVALS, OUTORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD private subroutine int32_indmed(INVALS, OUTORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD private subroutine f_char_indmed(INVALS, OUTORD) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out) :: OUTORD","tags":"","loc":"module/m_indmed.html"},{"title":"M_mrgrnk – orderpack","text":"Uses iso_fortran_env Contents Interfaces mrgrnk Interfaces public interface mrgrnk private subroutine real64_mrgrnk(INVALS, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgrnk(INVALS, IRNGT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgrnk(INVALS, IRNGT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgrnk(INVALS, IRNGT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"module/m_mrgrnk.html"},{"title":"M_valmed – orderpack","text":"Uses iso_fortran_env Contents Interfaces valmed Interfaces public interface valmed private recursive function real64_valmed(INVALS) result(res_med) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS Return Value real(kind=real64) private recursive function real32_valmed(INVALS) result(res_med) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS Return Value real(kind=real32) private recursive function int32_valmed(INVALS) result(res_med) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS Return Value integer(kind=int32)","tags":"","loc":"module/m_valmed.html"},{"title":"M_orderpack – orderpack","text":"Uses M_refsor M_inssor M_inspar M_mrgrnk M_mrgref M_uniinv M_unirnk M_rnkpar M_refpar M_rinpar M_rapknr M_unipar M_median M_valmed M_indmed M_indnth M_valnth M_fndnth M_unista M_mulcnt M_ctrper Contents None","tags":"","loc":"module/m_orderpack.html"},{"title":"M_uniinv – orderpack","text":"Uses iso_fortran_env Contents Interfaces uniinv Interfaces public interface uniinv private subroutine real64_uniinv(INVALS, IGOEST) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST private subroutine real32_uniinv(INVALS, IGOEST) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST private subroutine int32_uniinv(INVALS, IGOEST) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST private subroutine f_char_uniinv(INVALS, IGOEST) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IGOEST","tags":"","loc":"module/m_uniinv.html"},{"title":"M_ctrper – orderpack","text":"Uses iso_fortran_env M_mrgrnk Contents Interfaces ctrper Interfaces public interface ctrper private subroutine real64_CTRPER(INOUTVALS, CLOSENESS) Shuffle the array INOUTVALS randomly, leaving elements close to their\n   initial locations. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS private subroutine real32_CTRPER(INOUTVALS, CLOSENESS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS private subroutine int32_CTRPER(INOUTVALS, CLOSENESS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS private subroutine f_char_CTRPER(INOUTVALS, CLOSENESS) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS real, intent(in) :: CLOSENESS","tags":"","loc":"module/m_ctrper.html"},{"title":"M_valnth – orderpack","text":"Uses iso_fortran_env Contents Interfaces valnth Interfaces public interface valnth private function real64_valnth(INVALS, NORD) result(valnth) ORDERVAL(3f) returns the  NORDth (ascending order) value of INVALS,\n   i.e. the fractile of order NORD/SIZE(INVALS). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value real(kind=real64) private function real32_valnth(INVALS, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value real(kind=real32) private function int32_valnth(INVALS, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: NORD Return Value integer(kind=int32)","tags":"","loc":"module/m_valnth.html"},{"title":"M_inspar – orderpack","text":"Uses iso_fortran_env Contents Interfaces inspar Interfaces public interface inspar private subroutine real64_inspar(INOUTVALS, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD private subroutine real32_inspar(INOUTVALS, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD private subroutine int32_inspar(INOUTVALS, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD private subroutine f_char_inspar(INOUTVALS, NORD) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS integer, intent(in) :: NORD","tags":"","loc":"module/m_inspar.html"},{"title":"M_rapknr – orderpack","text":"Uses iso_fortran_env Contents Interfaces rapknr Interfaces public interface rapknr private subroutine real64_rapknr(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rapknr(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rapknr(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_rapknr.html"},{"title":"M_mrgref – orderpack","text":"Uses iso_fortran_env Contents Interfaces mrgref Interfaces public interface mrgref private subroutine real64_mrgref(INVALS, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgref(INVALS, IRNGT) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgref(INVALS, IRNGT) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgref(INVALS, IRNGT) Read more… Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"module/m_mrgref.html"},{"title":"M_unirnk – orderpack","text":"Uses iso_fortran_env Contents Interfaces unirnk Interfaces public interface unirnk private subroutine real64_unirnk(INVALS, IRNGT, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine real32_unirnk(INVALS, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine int32_unirnk(INVALS, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI","tags":"","loc":"module/m_unirnk.html"},{"title":"M_rnkpar – orderpack","text":"Uses iso_fortran_env Contents Interfaces rnkpar Interfaces public interface rnkpar private subroutine real64_rnkpar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rnkpar(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rnkpar(INVALS, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_rnkpar.html"},{"title":"M_unista – orderpack","text":"Uses iso_fortran_env M_uniinv Contents Interfaces unista Interfaces public interface unista private subroutine real64_unista(INOUTVALS, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI private subroutine real32_unista(INOUTVALS, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI private subroutine int32_unista(INOUTVALS, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI private subroutine f_char_unista(INOUTVALS, NUNI) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: INOUTVALS integer, intent(out) :: NUNI","tags":"","loc":"module/m_unista.html"},{"title":"M_fndnth – orderpack","text":"Uses iso_fortran_env Contents Interfaces fndnth Interfaces public interface fndnth private function real64_fndnth(INVALS, INORD) result(FNDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(in) :: INORD Return Value real(kind=real64) private function real32_fndnth(INVALS, INORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: INORD Return Value real(kind=real32) private function int32_fndnth(INVALS, INORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(in) :: INORD Return Value integer(kind=int32)","tags":"","loc":"module/m_fndnth.html"},{"title":"M_rinpar – orderpack","text":"Uses iso_fortran_env Contents Interfaces rinpar Interfaces public interface rinpar private subroutine real64_rinpar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rinpar(INVALS, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rinpar(INVALS, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_rinpar.html"},{"title":"M_refpar – orderpack","text":"Uses iso_fortran_env Contents Interfaces refpar Interfaces public interface refpar private subroutine real64_refpar(INVALS, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_refpar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_refpar(INVALS, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: INVALS integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_refpar.html"},{"title":"demo_psort – orderpack","text":"Uses M_orderpack Contents Variables g nord Source Code demo_psort Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer :: nord Source Code program demo_psort ! partially sort an array use M_orderpack , only : psort implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: nord int : block integer , allocatable :: ia (:) ia = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 write ( * , g ) 'Original.................:' , ia call psort ( ia , nord ) write ( * , g ) 'Number of indices to sort:' , nord write ( * , g ) nord , 'Lowest values..........:' , ia (: nord ) write ( * , g ) 'Entire array.............:' , ia write ( * , g ) endblock int char : block character ( len = :), allocatable :: ca (:) integer :: i ca = [ character ( len = 20 ) :: 'fan' , 'a' , 'car' , 'be' , 'egg' , 'dam' , 'gas' ] nord = 3 write ( * , g ) 'Original.................:' ,( trim ( ca ( i )), i = 1 , size ( ca )) call psort ( ca , nord ) write ( * , g ) 'Number of indices to sort:' , nord write ( * , g ) nord , 'Lowest values..........:' ,( trim ( ca ( i )), i = 1 , nord ) write ( * , g ) 'Entire array.............:' ,( trim ( ca ( i )), i = 1 , size ( ca )) write ( * , g ) endblock char end program demo_psort","tags":"","loc":"program/demo_psort.html"},{"title":"demo_medianval – orderpack","text":"Uses M_orderpack Contents Variables g Source Code demo_medianval Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_medianval ! return median value use M_orderpack , only : medianval implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'real   ' ,& medianval ( [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] ) write ( * , g ) 'integer' ,& medianval ( [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] ) write ( * , g ) 'double ' ,& medianval ( [ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ] ) end program demo_medianval","tags":"","loc":"program/demo_medianval.html"},{"title":"demo_prank_special – orderpack","text":"Uses M_orderpack Contents Variables INVALS g irngt nord Source Code demo_prank_special Variables Type Attributes Name Initial integer, allocatable :: INVALS (:) character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: irngt (:) integer :: nord Source Code program demo_prank_special ! partially rank N lowest values in an array use M_orderpack , only : prank_special implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) integer , allocatable :: irngt (:) integer :: nord INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , INVALS call prank_special ( INVALS , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'SMALLEST VALUES:' , INVALS ( irngt (: nord )) end program demo_prank_special","tags":"","loc":"program/demo_prank_special.html"},{"title":"demo_unique – orderpack","text":"Uses M_orderpack Contents Variables g list nuni sp Source Code demo_unique Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' character(len=*), parameter :: list = '(*(g0:,\", \"))' integer :: nuni character(len=*), parameter :: sp = '(*(g0,1x))' Source Code program demo_unique ! remove duplicates with remaining elements remaining in initial order use M_orderpack , only : unique implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer :: nuni int : block integer , allocatable :: INOUTVALS (:) INOUTVALS = [ 44 , 33 , 33 , 33 , 22 , 11 , 33 , 44 , 55 , 33 ] print list , 'ORIGINAL:' , INOUTVALS call unique ( INOUTVALS , nuni ) INOUTVALS = INOUTVALS (: nuni ) print list , 'UNIQUE:' , INOUTVALS endblock int end program demo_unique","tags":"","loc":"program/demo_unique.html"},{"title":"demo_prank_decreasing – orderpack","text":"Uses M_orderpack Contents Variables INVALS g irngt nord Source Code demo_prank_decreasing Variables Type Attributes Name Initial integer, allocatable :: INVALS (:) character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: irngt (:) integer :: nord Source Code program demo_prank_decreasing ! create index to lowest N values in input array in decreasing order use M_orderpack , only : prank_decreasing implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) integer , allocatable :: irngt (:) integer :: nord INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , INVALS call prank_decreasing ( INVALS , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'MAXIMUM VALUES:' , INVALS ( irngt (: nord )) end program demo_prank_decreasing","tags":"","loc":"program/demo_prank_decreasing.html"},{"title":"demo_sort – orderpack","text":"Uses iso_fortran_env M_orderpack Contents Variables i valsd Source Code demo_sort Variables Type Attributes Name Initial integer :: i real(kind=real64) :: valsd (2000) Source Code program demo_sort ! sort array in ascending order use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : sort implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. real ( kind = real64 ) :: valsd ( 2000 ) integer :: i call random_seed () call random_number ( valsd ) valsd = valsd * 100000 0.0 - 50000 0.0 call sort ( valsd ) do i = 1 , size ( valsd ) - 1 if ( valsd ( i + 1 ). lt . valsd ( i )) then write ( * , * ) 'not sorted' stop 3 endif enddo write ( * , * ) 'random arrays are now sorted' end program demo_sort","tags":"","loc":"program/demo_sort.html"},{"title":"demo_sort_special – orderpack","text":"Uses iso_fortran_env M_orderpack Contents Variables dd hi i isz low Source Code demo_sort_special Variables Type Attributes Name Initial real(kind=real64) :: dd (isz) real(kind=real64) :: hi integer :: i integer, parameter :: isz = 2000 real(kind=real64) :: low Source Code program demo_sort_special ! sort an array using insertion sort use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : sort_special implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. integer , parameter :: isz = 2000 real ( kind = real64 ) :: dd ( isz ), hi , low integer :: i ! make an array of random values call random_seed () call random_number ( dd ) dd = dd * 100000 0.0 - 50000 0.0 low = minval ( dd ) hi = maxval ( dd ) ! sort the data call sort_special ( dd ) ! cursory checks if ( any ( dd ( 1 : isz - 1 ) . gt . dd ( 2 : isz ))) stop 'ERROR: array not sorted' write ( * , * ) 'check min:' , dd ( 1 ). eq . low write ( * , * ) 'check max:' , dd ( isz ). eq . hi write ( * , * ) 'PASSED: random array is now sorted' end program demo_sort_special","tags":"","loc":"program/demo_sort_special.html"},{"title":"demo_prank – orderpack","text":"Uses iso_fortran_env M_orderpack Contents Variables i indx ivals out valsr Source Code demo_prank Variables Type Attributes Name Initial integer :: i integer :: indx (2000) integer, parameter :: ivals = 300 real(kind=real32) :: out (ivals) real(kind=real32) :: valsr (2000) Source Code program demo_prank ! partially rank array use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : prank implicit none integer , parameter :: ivals = 300 real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real32 ) :: out ( ivals ) integer :: indx ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call prank ( valsr , indx , ivals ) out = valsr ( indx (: ivals )) do i = 1 , ivals - 1 if ( out ( i + 1 ). lt . out ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_prank","tags":"","loc":"program/demo_prank.html"},{"title":"demo_orderloc – orderpack","text":"Uses M_orderpack M_orderpack Contents Variables i iarr indx list sp Subroutines printme Source Code demo_orderloc Variables Type Attributes Name Initial integer :: i integer, allocatable :: iarr (:) integer :: indx character(len=*), parameter :: list = '(*(g0:,\", \"))' character(len=*), parameter :: sp = '(*(g0,1x))' Subroutines subroutine printme (n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Source Code program demo_orderloc ! find Nth lowest ordered value in an array without sorting entire array use M_orderpack , only : orderloc use M_orderpack , only : medianloc implicit none integer , allocatable :: iarr (:) character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer :: i integer :: indx iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 , 0 , - 100 ] print list , 'ORIGINAL:' , iarr ! like minloc() and maxloc() print sp , 'minloc' , orderloc ( iarr , 1 ), minloc ( iarr ) print sp , 'maxloc' , orderloc ( iarr , size ( iarr )), maxloc ( iarr ) ! can find median call medianloc ( iarr , indx ) print sp , 'median' , orderloc ( iarr ,( size ( iarr ) + 1 ) / 2 ), indx ! but more general so can find location of the Nth lowest value ... ! ! sort the hard way, finding location of Nth value one at a time do i = 1 , size ( iarr ) write ( * , sp , advance = 'no' ) iarr ( orderloc ( iarr , i )) enddo print * contains subroutine printme ( n ) integer , intent ( in ) :: n integer :: ii ii = orderloc ( iarr , n ) print sp , 'nord=' , n , ' index=' , ii , ' fractile=' , iarr ( ii ) end subroutine printme end program demo_orderloc","tags":"","loc":"program/demo_orderloc.html"},{"title":"demo_prank_unique – orderpack","text":"Uses M_orderpack Contents Variables INVALS g irngt nord Subroutines printme Source Code demo_prank_unique Variables Type Attributes Name Initial integer, allocatable :: INVALS (:) character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: irngt (:) integer :: nord Subroutines subroutine printme () Arguments None Source Code program demo_prank_unique ! ranks array, removing duplicates use M_orderpack , only : prank_unique implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) integer , allocatable :: irngt (:) integer :: nord ! write ( * , g ) 'If enough values are unique, will return NORD indices' if ( allocated ( irngt )) deallocate ( irngt ) INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) call printme () ! !BUG!write(*,g)'If not enough values are unique, will change NORD' !BUG!INVALS=[-1,0,-1,0,-1,0,-1] !BUG!nord=5 !BUG!if(allocated(irngt))deallocate(irngt) !BUG!allocate(irngt(nord)) !BUG!call printme() contains subroutine printme () write ( * , g ) 'ORIGINAL:' , INVALS write ( * , g ) 'NUMBER OF INDICES TO SORT:' , nord call prank_unique ( INVALS , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES RETURNED:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt (: nord ) write ( * , g ) nord , 'SMALLEST UNIQUE VALUES:' , INVALS ( irngt (: nord )) end subroutine end program demo_prank_unique","tags":"","loc":"program/demo_prank_unique.html"},{"title":"demo_rank – orderpack","text":"Uses M_orderpack Contents Variables cindx dd dp g i indx isz j k pp strings Source Code demo_rank Variables Type Attributes Name Initial integer, allocatable :: cindx (:) real(kind=dp) :: dd (isz) integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: indx (isz) integer, parameter :: isz = 10000 integer :: j integer :: k real(kind=dp) :: pp character(len=:), allocatable :: strings (:) Source Code program demo_rank ! create an index that can order an array in ascending order use M_orderpack , only : rank implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call rank ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ); allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call rank ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_rank","tags":"","loc":"program/demo_rank.html"},{"title":"demo_occurrences – orderpack","text":"Uses M_orderpack Contents Variables cindx csz g i strings Source Code demo_occurrences Variables Type Attributes Name Initial integer, allocatable :: cindx (:) integer :: csz character(len=*), parameter :: g = '(*(g0,1x))' integer :: i character(len=20), allocatable :: strings (:) Source Code program demo_occurrences use M_orderpack , only : occurrences ! determine how many times each value appears in an input array implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) integer :: csz integer :: i ! each name appears the number of times its name represents strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call occurrences ( strings , cindx ) write ( * , g )( trim ( strings ( i )), i = 1 , csz ) write ( * , g ) cindx end program demo_occurrences","tags":"","loc":"program/demo_occurrences.html"},{"title":"demo_orderval_special – orderpack","text":"Uses M_orderpack Contents Variables i iarr list sp Source Code demo_orderval_special Variables Type Attributes Name Initial integer :: i integer, allocatable :: iarr (:) character(len=*), parameter :: list = '(*(g0:,\", \"))' character(len=*), parameter :: sp = '(*(g0,1x))' Source Code program demo_orderval_special ! return Nth ordered value of an array use M_orderpack , only : orderval_special , medianval implicit none character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer , allocatable :: iarr (:) integer :: i iarr = [ 80 , 70 , 30 , 40 , - 50 , 60 , 20 , 10 ] print sp , 'ORIGINAL:' , iarr ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , orderval_special ( iarr , 1 ), minval ( iarr ) print sp , 'maxval' , orderval_special ( iarr , size ( iarr )), maxval ( iarr ) ! but more generally it can return the Nth lowest value. print sp , 'median' , orderval_special ( iarr ,( size ( iarr + 1 )) / 2 ), medianval ( iarr ) ! so only Nth ordered value can be found print sp , 'inord=' , 3 , ' fractile=' , orderval_special ( iarr , 3 ) ! sorting the hard way print sp , 'ORIGINAL:' , iarr do i = 1 , size ( iarr ) write ( * , list ) i , orderval_special ( iarr , i ) enddo print * end program demo_orderval_special","tags":"","loc":"program/demo_orderval_special.html"},{"title":"demo_perturb – orderpack","text":"Uses M_orderpack Contents Variables g i isz j list xout Source Code demo_perturb Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: isz integer :: j character(len=*), parameter :: list = '(*(g0:,\", \"))' integer, allocatable :: xout (:,:) Source Code program demo_perturb ! generate a random perturbation of an array use M_orderpack , only : perturb implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: list = '(*(g0:,\", \"))' integer , allocatable :: xout (:,:) integer :: isz , i , j isz = 200 ! randomly perturb location of values ! ! make an array with three initially identical rows of ! values perturbed by different amounts if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) xout ( 1 ,:) = [( i , i = isz , 1 , - 1 )] * 10 xout ( 2 ,:) = xout ( 1 ,:) xout ( 3 ,:) = xout ( 1 ,:) ! perturb each row a different amount call perturb ( xout ( 1 ,:), 0.0 ) call perturb ( xout ( 2 ,:), 0.1 ) call perturb ( xout ( 3 ,:), 1.0 ) ! show values write ( * , '(a)' ) 'count    unchanged  perturbed  random' do i = 1 , size ( xout , dim = 2 ) write ( * , '(*(i8,1x))' ) i , xout (:, i ) enddo char : block character ( len = :), allocatable :: cdont (:) cdont = [ character ( len = 20 ) :: 'a' , 'be' , 'car' , 'dam' , 'fan' , 'gas' , 'egg' ] isz = size ( cdont ) write ( * , g ) 'Original.................:' ,( trim ( cdont ( i )), i = 1 , isz ) call perturb ( cdont , 1.0 ) write ( * , g ) 'Perturbed ...............:' ,( trim ( cdont ( i )), i = 1 , isz ) write ( * , g ) endblock char end program demo_perturb","tags":"","loc":"program/demo_perturb.html"},{"title":"demo_prank – orderpack","text":"Uses iso_fortran_env M_orderpack Contents Variables i indx results valsr Source Code demo_prank Variables Type Attributes Name Initial integer :: i integer :: indx (2000) real, allocatable :: results (:) real(kind=real32) :: valsr (2000) Source Code program demo_prank ! create index to lowest N values in input array in ascending order use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_orderpack , only : prank_basic implicit none real ( kind = real32 ) :: valsr ( 2000 ) integer :: indx ( 2000 ) integer :: i real , allocatable :: results (:) ! create some random data call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 ! get 300 lowest values sorted call prank_basic ( valsr , indx , 300 ) ! results = valsr ( indx (: 300 )) ! check if sorted do i = 1 , 300 - 1 if ( results ( i + 1 ). lt . results ( i )) then write ( * , * ) 'ERROR: not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_prank","tags":"","loc":"program/demo_prank~2.html"},{"title":"demo_rank_unique – orderpack","text":"Uses M_orderpack Contents Variables INVALS g Subroutines printme Source Code demo_rank_unique Variables Type Attributes Name Initial integer, allocatable :: INVALS (:) character(len=*), parameter :: g = '(*(g0,1x))' Subroutines subroutine printme () Arguments None Source Code program demo_rank_unique ! rank an array, with removal of duplicate entries. use M_orderpack , only : rank_unique implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: INVALS (:) ! INVALS = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] call printme () INVALS = [ - 1 , 0 , - 2 , 0 , - 3 , 0 , - 4 ] call printme () contains subroutine printme () integer , allocatable :: irngt (:) integer :: nuni if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( INVALS ))) write ( * , g ) 'ORIGINAL:' , INVALS call rank_unique ( INVALS , irngt , nuni ) write ( * , g ) 'NUMBER OF UNIQUE INDICES:' , nuni write ( * , g ) 'RETURNED INDICES:' , irngt (: nuni ) write ( * , g ) 'SORTED DATA:' , INVALS ( irngt (: nuni )) end subroutine end program demo_rank_unique","tags":"","loc":"program/demo_rank_unique.html"},{"title":"demo_medianloc – orderpack","text":"Uses M_orderpack Contents Variables INVALS cdont fmt ii Source Code demo_medianloc Variables Type Attributes Name Initial real, allocatable :: INVALS (:) character(len=:), allocatable :: cdont (:) character(len=*), parameter :: fmt = '(i5,t11,g0)' integer :: ii Source Code program demo_medianloc ! return index of median value use M_orderpack , only : medianloc implicit none real , allocatable :: INVALS (:) character ( len = :), allocatable :: cdont (:) character ( len =* ), parameter :: fmt = '(i5,t11,g0)' integer :: ii write ( * , * ) 'location  median' INVALS = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call medianloc ( INVALS , ii ) write ( * , fmt ) ii , INVALS ( ii ) ! INVALS = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call medianloc ( INVALS , ii ) write ( * , fmt ) ii , INVALS ( ii ) ! INVALS = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call medianloc ( INVALS , ii ) write ( * , fmt ) ii , INVALS ( ii ) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' ,& 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call medianloc ( cdont , ii ) write ( * , fmt ) ii , cdont ( ii ) ! end program demo_medianloc","tags":"","loc":"program/demo_medianloc.html"},{"title":"demo_median – orderpack","text":"Uses M_orderpack Contents Variables g Source Code demo_median Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_median ! calculate median value use M_orderpack , only : median implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'real   ' , median (& [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] ) write ( * , g ) 'integer' , median (& [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] ) write ( * , g ) 'double ' , median (& [ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ]) end program demo_median","tags":"","loc":"program/demo_median.html"},{"title":"demo_package – orderpack","text":"Uses M_mrgref M_orderpack M_mrgrnk M_orderpack M_inssor M_orderpack M_refsor M_orderpack M_rinpar M_orderpack M_refpar M_orderpack M_rapknr M_orderpack M_rnkpar M_orderpack M_inspar M_orderpack Contents Variables g i ii indx isz j jj k mx par rr Source Code demo_package Variables Type Attributes Name Initial character(len=*), parameter :: g = '(a,*(i3,1x))' integer :: i integer :: ii (isz) integer :: indx (isz) integer, parameter :: isz = 30 integer :: j integer :: jj (isz) integer :: k integer :: mx = 13 integer, parameter :: par = 8 real :: rr (isz) Source Code program demo_package use M_mrgref , only : mrgref use M_orderpack , only : rank_basic use M_mrgrnk , only : mrgrnk use M_orderpack , only : rank use M_inssor , only : inssor use M_orderpack , only : Sort_special use M_refsor , only : refsor use M_orderpack , only : Sort use M_rinpar , only : rinpar use M_orderpack , only : prank_special use M_refpar , only : refpar use M_orderpack , only : prank_basic use M_rapknr , only : rapknr use M_orderpack , only : prank_decreasing use M_rnkpar , only : rnkpar use M_orderpack , only : prank use M_inspar , only : inspar use M_orderpack , only : psort implicit none character ( len =* ), parameter :: g = '(a,*(i3,1x))' integer , parameter :: isz = 30 ! number of random numbers integer :: mx = 13 ! maxval(abs(ii)), biggest magnitude of random values, < isz to likely get duplicates integer , parameter :: par = 8 ! order of partial sort integer :: ii ( isz ), jj ( isz ) integer :: indx ( isz ) real :: rr ( isz ) integer :: i , j , k !=================================================================================================================================== call random_seed () call random_number ( rr ) rr = rr - 0.50 ii = floor ( rr * mx ) write ( * , g ) 'Original ' , ii write ( * , g ) 'mrgref     - [RANK] produces a sorted ranking index array of input array (basic merge-sort)' indx =- 99 call mrgref ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) write ( * , g ) 'rank_basic - [RANK] produces a sorted ranking index array of input array (basic merge-sort)' indx =- 99 call mrgref ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) !=================================================================================================================================== write ( * , g ) 'mrgrnk - [RANK] produces a sorted ranking index array of input array (optimized merge-sort)' indx =- 99 call mrgrnk ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) write ( * , g ) 'rank   - [RANK] produces a sorted ranking index array of input array (optimized merge-sort)' indx =- 99 call rank ( ii , indx ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ) !=================================================================================================================================== write ( * , g ) 'inssor       - [SORT] Sorts array into ascending order (Insertion sort, generally for small or nearly sorted arrays)' jj = ii call inssor ( jj ) write ( * , g ) '         ' , jj write ( * , g ) 'Sort_special - [SORT] Sorts array into ascending order (Insertion sort, generally for small or nearly sorted arrays)' jj = ii call Sort_special ( jj ) write ( * , g ) '         ' , jj !=================================================================================================================================== write ( * , g ) 'refsor - [SORT] Sorts array into ascending order (Quicksort)' jj = ii call refsor ( jj ) write ( * , g ) '         ' , jj write ( * , g ) 'Sort   - [SORT] Sorts array into ascending order (Quicksort)' jj = ii call Sort ( jj ) write ( * , g ) '         ' , jj !=================================================================================================================================== write ( * , g ) 'inspar - [SORT:PARTIAL] partially sorts an array, bringing the N lowest values to the beginning of the array' jj = ii call inspar ( jj , par ) ! note the remainder of the data is perturbed write ( * , g ) '         ' , jj write ( * , g ) '         ' , jj ( 1 : par ) write ( * , g ) 'psort  - [SORT:PARTIAL] partially sorts an array, bringing the N lowest values to the beginning of the array' jj = ii call psort ( jj , par ) ! note the remainder of the data is perturbed write ( * , g ) '         ' , jj write ( * , g ) '         ' , jj ( 1 : par ) !=================================================================================================================================== write ( * , g ) 'rinpar        - [RANK:PARTIAL] creates partial rank index of N lowest values in an array' indx =- 99 call rinpar ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank_special - [RANK:PARTIAL] creates partial rank index of N lowest values in an array' indx =- 99 call prank_special ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'refpar - [RANK:PARTIAL] partially rank array up to specified number of elements (QuickSort-like)' indx =- 99 call refpar ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank_basic  - [RANK:PARTIAL] partially rank array up to specified number of elements (QuickSort-like)' indx =- 99 call prank_basic ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'rapknr           - [RANK:PARTIAL] partially ranks an array up to a specified number of values, in DECREASING order.' indx =- 99 call rapknr ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank_decreasing - [RANK:PARTIAL] partially ranks an array up to a specified number of values, in DECREASING order.' indx =- 99 call prank_decreasing ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'rnkpar   - [RANK:PARTIAL] partially rank array, up to order N (N number of sorted elements to return) (QuickSort-like)' indx =- 99 call rnkpar ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) write ( * , g ) 'prank    - [RANK:PARTIAL] partially rank array, up to order N (N number of sorted elements to return) (QuickSort-like)' indx =- 99 call prank ( ii , indx , par ) write ( * , g ) '         ' , indx write ( * , g ) '         ' , ii ( indx ( 1 : par )) !=================================================================================================================================== write ( * , g ) 'unipar - [RANK:PARTIAL:UNIQUE] partially rank an array removing duplicates' write ( * , g ) 'prank_unique - [RANK:PARTIAL:UNIQUE] partially rank an array removing duplicates' !=================================================================================================================================== write ( * , g ) 'uniinv - [RANK:UNIQUE] a MergeSort inverse ranking of an array, with duplicate entries assigned the same rank.' write ( * , g ) 'rank_orders - [RANK:UNIQUE] a MergeSort inverse ranking of an array, with duplicate entries assigned the same rank.' !=================================================================================================================================== write ( * , g ) 'unirnk - [RANK:UNIQUE] performs a MergeSort ranking of an array, with removal of duplicate entries.' write ( * , g ) 'rank_unique - [RANK:UNIQUE] performs a MergeSort ranking of an array, with removal of duplicate entries.' !=================================================================================================================================== write ( * , g ) 'unista - [UNIQUE] (Stable unique) Removes duplicates from an array otherwise retaining original order' write ( * , g ) 'unique - [UNIQUE] (Stable unique) Removes duplicates from an array otherwise retaining original order' !=================================================================================================================================== write ( * , g ) 'fndnth           - [FRACTILE] Return Nth lowest value of an array  (InsertSort-like)' write ( * , g ) 'orderval_special - [FRACTILE] Return Nth lowest value of an array  (InsertSort-like)' !=================================================================================================================================== write ( * , g ) 'indnth   - [FRACTILE] Return INDEX of Nth value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' write ( * , g ) 'orderloc - [FRACTILE] Return INDEX of Nth value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' !=================================================================================================================================== write ( * , g ) 'valnth   - [FRACTILE] Return VALUE of Nth lowest value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' write ( * , g ) 'orderval - [FRACTILE] Return VALUE of Nth lowest value of array, i.e fractile of order N/SIZE(array) (QuickSort-like)' !=================================================================================================================================== write ( * , g ) 'valmed    - [MEDIAN] finds the median of an array' write ( * , g ) 'medianval - [MEDIAN] finds the median of an array' !=================================================================================================================================== write ( * , g ) 'median - [MEDIAN] Return median value of array. If number of data is even, return average of the two \"medians\".' write ( * , g ) 'median - [MEDIAN] Return median value of array. If number of data is even, return average of the two \"medians\".' !=================================================================================================================================== write ( * , g ) 'indmed    - [MEDIAN] Returns INDEX of median value of an array.' write ( * , g ) 'medianloc - [MEDIAN] Returns INDEX of median value of an array.' !=================================================================================================================================== write ( * , g ) 'ctrper  - [PERMUTATION] generate a random permutation of an array leaving elements close to initial locations' write ( * , g ) 'perturb - [PERMUTATION] generate a random permutation of an array leaving elements close to initial locations' !=================================================================================================================================== write ( * , g ) 'mulcnt      - [MULTIPLICITY] Give the multiplicity for each array value (number of times that it appears in the array)' write ( * , g ) 'occurrences - [MULTIPLICITY] Give the multiplicity for each array value (number of times that it appears in the array)' !=================================================================================================================================== end program demo_package","tags":"","loc":"program/demo_package.html"},{"title":"demo_rank_decreasing – orderpack","text":"Uses M_orderpack Contents Variables INVALS count distinct fmt i igoest imx Source Code demo_rank_decreasing Variables Type Attributes Name Initial integer, allocatable, dimension(:) :: INVALS integer, allocatable, dimension(:) :: count integer, allocatable, dimension(:) :: distinct character(len=*), parameter :: fmt = '(a,*(g3.3,1x))' integer :: i integer, allocatable, dimension(:) :: igoest integer :: imx Source Code program demo_rank_decreasing ! rank input array ranking duplicates the same use M_orderpack , only : rank_decreasing implicit none character ( len =* ), parameter :: fmt = '(a,*(g3.3,1x))' integer , allocatable , dimension (:) :: INVALS , igoest , distinct , count integer :: imx , i ! create an input array INVALS = [ 11 , 11 , 22 , 11 , 33 , 33 , 22 , 33 , 33 ] ! make an index array of the same size if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( INVALS ))) print fmt , 'Original:                 ' , INVALS print fmt , 'Number of indices to sort:' , size ( INVALS ) ! rank input array ranking duplicates the same call rank_decreasing ( INVALS , igoest ) print fmt , 'Returned Indices:         ' , igoest (:) ! ! interrogate the results ! imx = maxval ( igoest ) print fmt , 'Number of unique indices :' , imx ! squeeze it down to just IMX unique values count = [( 0 , i = 1 , imx )] ! count how many times a value occurs distinct = count ! array to set of unique values do i = 1 , size ( INVALS ) distinct ( igoest ( i )) = INVALS ( i ) count ( igoest ( i )) = count ( igoest ( i )) + 1 enddo print fmt , 'Sorted unique values:     ' , distinct print fmt , 'count of occurrences:     ' , count end program demo_rank_decreasing","tags":"","loc":"program/demo_rank_decreasing.html"},{"title":"demo_rank_basic – orderpack","text":"Uses M_orderpack Contents Variables cindx dd dp g i indx isz j k pp strings Source Code demo_rank_basic Variables Type Attributes Name Initial integer, allocatable :: cindx (:) real(kind=dp) :: dd (isz) integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: indx (isz) integer, parameter :: isz = 10000 integer :: j integer :: k real(kind=dp) :: pp character(len=:), allocatable :: strings (:) Source Code program demo_rank_basic ! create an index that can order an array in ascending order use M_orderpack , only : rank_basic implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call rank_basic ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call rank_basic ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_rank_basic","tags":"","loc":"program/demo_rank_basic.html"},{"title":"demo_orderval – orderpack","text":"Uses M_orderpack Contents Variables INVALS i imiddle list sp Source Code demo_orderval Variables Type Attributes Name Initial real, parameter :: INVALS (*) = [1.1, 20.20, 3.3, 10.10, 5.5, 4.4, 2.2] integer :: i integer :: imiddle character(len=*), parameter :: list = '(*(g0:,\", \"))' character(len=*), parameter :: sp = '(*(g0,1x))' Source Code program demo_orderval !  Return value of Nth lowest value of array use M_orderpack , only : orderval implicit none character ( len =* ), parameter :: list = '(*(g0:,\", \"))' character ( len =* ), parameter :: sp = '(*(g0,1x))' real , parameter :: INVALS ( * ) = [ 1.1 , 2 0.20 , 3.3 , 1 0.10 , 5.5 , 4.4 , 2.2 ] integer :: i integer :: imiddle write ( * , list ) 'ORIGINAL:' , INVALS ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , orderval ( INVALS , 1 ), minval ( INVALS ) print sp , 'maxval' , orderval ( INVALS , size ( INVALS )), maxval ( INVALS ) ! but more generally it can return the Nth lowest value. print sp , 'nord=' , 4 , ' fractile=' , orderval ( INVALS , 4 ) ! so a value at the middle would be imiddle = ( size ( INVALS ) + 1 ) / 2 print sp , 'median' , orderval ( INVALS , imiddle ) ! sorting the hard way do i = 1 , size ( INVALS ) write ( * , list ) i , orderval ( INVALS , i ) enddo end program demo_orderval","tags":"","loc":"program/demo_orderval.html"},{"title":"runtest – orderpack","text":"Uses M_msg M_msg M_verify M_verify M_verify M_verify M_mrgref M_mrgrnk M_inssor M_refsor M_ctrper M_fndnth M_indnth M_valnth M_indmed M_valmed M_median M_refpar M_rinpar M_rnkpar M_inspar M_rapknr M_unipar M_mulcnt M_unirnk M_unista M_uniinv Contents Variables dp g Functions random_string Subroutines test_ctrper test_fndnth test_gen test_indmed test_indnth test_inspar test_median test_mulcnt test_rapknr test_refpar test_rinpar test_rnkpar test_uniinv test_unipar test_unirnk test_unista test_valmed test_valnth Source Code runtest Variables Type Attributes Name Initial integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' Functions function random_string (chars, length) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(in) :: length Return Value character(len=:),\n  allocatable Subroutines subroutine test_ctrper () Arguments None subroutine test_fndnth () Arguments None subroutine test_gen (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name subroutine test_indmed () Arguments None subroutine test_indnth () Arguments None subroutine test_inspar () Arguments None subroutine test_median () Arguments None subroutine test_mulcnt () Arguments None subroutine test_rapknr () Arguments None subroutine test_refpar () Arguments None subroutine test_rinpar () Arguments None subroutine test_rnkpar () Arguments None subroutine test_uniinv () Arguments None subroutine test_unipar () Arguments None subroutine test_unirnk () Arguments None subroutine test_unista () Arguments None subroutine test_valmed () Arguments None subroutine test_valnth () Arguments None Source Code program runtest use M_msg use M_msg , only : str use M_verify use M_verify , only : unit_check_level use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_stop ! full ranking use M_mrgref , only : mrgref use M_mrgrnk , only : mrgrnk ! full sorting use M_inssor , only : inssor use M_refsor , only : refsor ! pertubation use M_ctrper , only : ctrper ! fractile (nth value) use M_fndnth , only : fndnth use M_indnth , only : indnth use M_valnth , only : valnth ! median use M_indmed , only : indmed use M_valmed , only : valmed use M_median , only : median ! use M_refpar , only : refpar use M_rinpar , only : rinpar use M_rnkpar , only : rnkpar use M_inspar , only : inspar use M_rapknr , only : rapknr use M_unipar , only : unipar use M_mulcnt , only : mulcnt use M_unirnk , only : unirnk use M_unista , only : unista use M_uniinv , only : uniinv implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_gen ( 'mrgref' ) call test_gen ( 'mrgrnk' ) call test_gen ( 'inssor' ) call test_gen ( 'refsor' ) call test_ctrper () call test_fndnth () call test_indnth () call test_valnth () call test_indmed () call test_valmed () call test_median () call test_refpar () call test_rinpar () call test_rnkpar () call test_rapknr () call test_inspar () call test_unipar () call test_mulcnt () call test_unirnk () call test_unista () call test_uniinv () call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_gen ( name ) character ( len =* ), intent ( in ) :: name integer , parameter :: isz = 10000 real :: rr ( isz ) real ( kind = dp ) :: dd ( isz ) integer :: ii ( isz ) character ( len = 10 ) :: cc ( isz ) integer :: indx ( isz ) integer :: i call unit_check_start ( name , '-library orderpack' ) ! start tests CALL RANDOM_NUMBER ( RR ) rr = rr * huge ( 0.0 ) select case ( name ) case ( 'inssor' ); call inssor ( rr ) case ( 'refsor' ); call refsor ( rr ) case ( 'mrgrnk' ); call mrgrnk ( rr , indx ); rr = rr ( indx ) case ( 'mrgref' ); call mrgref ( rr , indx ); rr = rr ( indx ) endselect call unit_check ( name , all ( rr ( 1 : isz - 1 ) . le . rr ( 2 : isz )), 'real test' , isz , 'values' ) CALL RANDOM_NUMBER ( RR ) ii = rr * huge ( 0 ) select case ( name ) case ( 'inssor' ); call inssor ( ii ) case ( 'refsor' ); call refsor ( ii ) case ( 'mrgrnk' ); call mrgrnk ( ii , indx ); ii = ii ( indx ) case ( 'mrgref' ); call mrgref ( ii , indx ); ii = ii ( indx ) endselect call unit_check ( name , all ( ii ( 1 : isz - 1 ) . le . ii ( 2 : isz )), 'integer test' , isz , 'values' ) CALL RANDOM_NUMBER ( DD ) dd = dd * huge ( 0.0_dp ) select case ( name ) case ( 'inssor' ); call inssor ( dd ) case ( 'refsor' ); call refsor ( dd ) case ( 'mrgrnk' ); call mrgrnk ( dd , indx ); dd = dd ( indx ) case ( 'mrgref' ); call mrgref ( dd , indx ); dd = dd ( indx ) endselect call unit_check ( name , all ( dd ( 1 : isz - 1 ) . le . dd ( 2 : isz )), 'double test' , isz , 'values' ) do i = 1 , isz cc ( i ) = random_string ( 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 10 ) enddo select case ( name ) case ( 'inssor' ); call inssor ( cc ) case ( 'refsor' ); call refsor ( cc ) case ( 'mrgrnk' ); call mrgrnk ( cc , indx ); cc = cc ( indx ) case ( 'mrgref' ); call mrgref ( cc , indx ); cc = cc ( indx ) endselect call unit_check ( name , all ( cc ( 1 : isz - 1 ) . le . cc ( 2 : isz )), 'string test, random' , isz , 'values' ) call unit_check_done ( name , msg = 'test completed' ) end subroutine test_gen !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ctrper implicit none integer , allocatable :: row (:) integer , allocatable :: xout (:,:) integer :: isz , i , j , jsz real , allocatable :: perturb (:) call unit_check_start ( 'ctrper' , '-library orderpack' ) ! start tests perturb = [ 0.0 , 0.1 , 1.0 ] jsz = size ( perturb ) isz = 200 if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) allocate ( row ( isz )) ! make each row the same initially row = [( i , i = 1 , isz )] * 10 do j = 1 , 3 xout ( j ,:) = row call ctrper ( xout ( j ,:), perturb ( j )) enddo !write(*,'(a)')'count    unchanged  perturbed  random' !do i=1,size(row) !   write(*,'(*(i8,1x))')i,xout(:,i) !enddo call unit_check ( 'ctrper' , all ( xout ( 1 ,:) . eq . row ), 'perturb 0 should not change' ) call unit_check ( 'ctrper' ,. not .( all ( xout ( 3 ,:) . eq . row )), 'perturb 1 should be random,unlikely not changed' ) char : block character ( len = :), allocatable :: xdont (:) xdont = [ character ( len = 20 ) :: 'a' , 'be' , 'car' , 'dam' , 'fan' , 'gas' , 'egg' ] isz = size ( xdont ) !write(*,g)'Original.................:',(trim(xdont(i)),i=1,isz) call ctrper ( xdont , 1.0 ) !write(*,g)'Perturbed ...............:',(trim(xdont(i)),i=1,isz) !write(*,g) endblock char call unit_check_done ( 'ctrper' , msg = 'test completed' ) end subroutine test_ctrper !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_valnth use M_valnth , only : valnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'valnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minval() and maxval() call unit_check ( 'valnth' , valnth ( iarr , 1 ). eq . minval ( iarr ), 'like minval()' ) call unit_check ( 'valnth' , valnth ( iarr , size ( iarr )). eq . maxval ( iarr ), 'like maxval()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'valnth' , valnth ( iarr , 8 ). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'valnth' , valnth ( iarr , imiddle ). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'valnth' , all ([( valnth ( iarr , i ), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'valnth' , msg = 'test completed' ) end subroutine test_valnth !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_indnth use M_indnth , only : indnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'indnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minloc() and maxloc() call unit_check ( 'indnth' , all ( indnth ( iarr , 1 ). eq . minloc ( iarr )), 'like minloc()' ) call unit_check ( 'indnth' , all ( indnth ( iarr , size ( iarr )). eq . maxloc ( iarr )), 'like maxloc()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'indnth' , iarr ( indnth ( iarr , 8 )). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'indnth' , iarr ( indnth ( iarr , imiddle )). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'indnth' , all ([( iarr ( indnth ( iarr , i )), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'indnth' , msg = 'test completed' ) end subroutine test_indnth !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fndnth use M_fndnth , only : fndnth implicit none integer , allocatable :: iarr (:) integer :: i integer :: imiddle call unit_check_start ( 'fndnth' , '-library orderpack' ) ! start tests ! find Nth lowest value in an array without sorting entire array iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] ! can return the same values as intrinsics minval() and maxval() call unit_check ( 'fndnth' , fndnth ( iarr , 1 ). eq . minval ( iarr ), 'like minval()' ) call unit_check ( 'fndnth' , fndnth ( iarr , size ( iarr )). eq . maxval ( iarr ), 'like maxval()' ) ! but more generally it can return the Nth lowest value. call unit_check ( 'fndnth' , fndnth ( iarr , 8 ). eq . 80 , 'Nth value' ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 call unit_check ( 'fndnth' , fndnth ( iarr , imiddle ). eq . 40 , 'find median' ) ! sort the hard way, one value at a time call unit_check ( 'fndnth' , all ([( fndnth ( iarr , i ), i = 1 , size ( iarr ))]. eq .[ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 ]), 'sort hard way' ) call unit_check_done ( 'fndnth' , msg = 'test completed' ) end subroutine test_fndnth !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_indmed use M_indmed , only : indmed implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) character ( len = :), allocatable :: cdont (:) integer :: ii call unit_check_start ( 'indmed' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call indmed ( xdont , ii ) call unit_check ( 'indmed' , ii . eq . 2. and . xdont ( ii ). eq . 7 0.0 , 'real median' , ii , xdont ( ii )) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call indmed ( idont , ii ) call unit_check ( 'indmed' , ii . eq . 4. and . idont ( ii ). eq . 44 , 'integer median' , ii , idont ( ii )) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call indmed ( ddont , ii ) call unit_check ( 'indmed' , ii . eq . 5. and . ddont ( ii ). eq . 3 3.0d0 , 'doubleprecision median' , ii , ddont ( ii )) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' , 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call indmed ( cdont , ii ) call unit_check ( 'indmed' , ii . eq . 5. and . cdont ( ii ). eq . 'elephant' , 'character median' , ii , cdont ( ii )) ! call unit_check_done ( 'indmed' , msg = 'test completed' ) end subroutine test_indmed !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_valmed use M_valmed , only : valmed implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) call unit_check_start ( 'valmed' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call unit_check ( 'valmed' , valmed ( xdont ). eq . 7 0.0 , 'real valmed' , valmed ( xdont ), 7 0.0 ) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call unit_check ( 'valmed' , valmed ( idont ). eq . 44 , 'integer valmed' , valmed ( idont ), 44 ) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call unit_check ( 'valmed' , valmed ( ddont ). eq . 3 3.0d0 , 'doubleprecision valmed' , valmed ( ddont ), 3 3.0 ) ! call unit_check_done ( 'valmed' , msg = 'test completed' ) end subroutine test_valmed !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_median use M_median , only : median implicit none real , allocatable :: xdont (:) real ( kind = dp ), allocatable :: ddont (:) integer , allocatable :: idont (:) call unit_check_start ( 'median' , '-library orderpack' ) ! start tests xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call unit_check ( 'median' , median ( xdont ). eq . 7 0.0 , 'real median' , median ( xdont ), 7 0.0 ) ! idont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call unit_check ( 'median' , median ( idont ). eq . 49 , 'integer median' , median ( idont ), 49 ) ! ddont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call unit_check ( 'median' , median ( ddont ). eq . 4 9.5d0 , 'doubleprecision median' , median ( ddont ), 4 9.5 ) ! call unit_check_done ( 'median' , msg = 'test completed' ) end subroutine test_median !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_inspar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: i call unit_check_start ( 'inspar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call inspar ( valsr , little ) call unit_check ( 'inspar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'inspar' , msg = 'test completed' ) end subroutine test_inspar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_rapknr () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rapknr' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rapknr ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rapknr' , all ( valsr ( 1 : little - 1 ) . ge . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rapknr' , msg = 'test completed' ) end subroutine test_rapknr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_rnkpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rnkpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rnkpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rnkpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rnkpar' , msg = 'test completed' ) end subroutine test_rnkpar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_rinpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'rinpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rinpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'rinpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'rinpar' , msg = 'test completed' ) end subroutine test_rinpar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_refpar () implicit none integer , parameter :: big = 2000 , little = 300 real :: valsr ( big ) integer :: indx ( little ) integer :: i call unit_check_start ( 'refpar' , '-library orderpack' ) ! start tests call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call refpar ( valsr , indx , little ) valsr (: 300 ) = valsr ( indx (: little )) call unit_check ( 'refpar' , all ( valsr ( 1 : little - 1 ) . le . valsr ( 2 : little )), 'real test' , little , 'out of' , big , 'values' ) call unit_check_done ( 'refpar' , msg = 'test completed' ) end subroutine test_refpar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unipar () use M_unipar , only : unipar implicit none integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord call unit_check_start ( 'unipar' , '-library orderpack' ) ! start tests ! xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( nord )) ! call unipar ( xdont , irngt , nord ) call unit_check ( 'unipar' , nord . eq . 5 , 'number of unique values found' , nord , 5 ) call unit_check ( 'unipar' , all ( irngt ( 1 : nord ) . eq . [ 11 , 5 , 2 , 7 , 3 ]) , 'returned indices' ) call unit_check ( 'unipar' , all ( xdont ( irngt ( 1 : nord )) . eq .[ 1 , 4 , 5 , 6 , 7 ]) , 'returned values' ) call unit_check_done ( 'unipar' , msg = 'test completed' ) end subroutine test_unipar !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mulcnt () character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) integer :: csz integer :: i call unit_check_start ( 'mulcnt' , '-library orderpack' ) ! start tests ! strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call mulcnt ( strings , cindx ) call unit_check ( 'mulcnt' , all ( cindx . eq . [ 2 , 4 , 3 , 5 , 5 , 2 , 4 , 3 , 5 , 5 , 4 , 4 , 3 , 1 , 5 ]) , 'returned values' ) call unit_check_done ( 'mulcnt' , msg = 'test completed' ) end subroutine test_mulcnt !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unirnk () integer , allocatable :: xvalt (:) integer , allocatable :: irngt (:) integer :: nuni call unit_check_start ( 'unirnk' , '-library orderpack' ) ! start tests xvalt = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( xvalt ))) call unirnk ( xvalt , irngt , nuni ) call unit_check ( 'unirnk' , nuni . eq . 8 , 'number of indices. got' , nuni , 'expected' , 8 ) call unit_check ( 'unirnk' , all ( irngt (: nuni ) . eq . [ 4 , 5 , 2 , 7 , 3 , 8 , 9 , 1 ]) , 'returned indices' ) call unit_check ( 'unirnk' , all ( xvalt ( irngt (: nuni )) . eq . [ 1 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) , 'sorted data' ) call unit_check_done ( 'unirnk' , msg = 'test completed' ) end subroutine test_unirnk !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unista () integer , allocatable :: xdont (:) integer :: nuni call unit_check_start ( 'unista' , '-library orderpack' ) ! start tests xdont = [ 44 , 33 , 33 , 33 , 22 , 11 , 33 , 44 , 55 , 33 ] call unista ( xdont , nuni ) call unit_check ( 'unista' , nuni . eq . 5 , 'number of indices. got' , nuni , 'expected' , 5 ) call unit_check ( 'unista' , all ( xdont (: nuni ) . eq . [ 44 , 33 , 22 , 11 , 55 ]) , 'unique values' ) call unit_check_done ( 'unista' , msg = 'test completed' ) end subroutine test_unista !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_uniinv () integer , allocatable :: xdont (:) integer , allocatable :: igoest (:) integer , allocatable :: out (:) integer :: imx integer :: i xdont = [ 10 , 20 , 30 , 10 , 20 , 30 , 10 , 20 , 30 ] if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( xdont ))) call uniinv ( xdont , igoest ) call unit_check ( 'uniinv' , all ( igoest . eq . [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ]) , 'returned indices' ) imx = maxval ( igoest ) call unit_check ( 'unista' , imx . eq . 3 , 'unique indices. got' , imx , 'expected' , 3 ) if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( xdont ) out ( igoest ( i )) = xdont ( i ) enddo call unit_check ( 'uniinv' , all ( xdont . eq . [ 10 , 20 , 30 ]) , 'sorted unique values' ) call unit_check_done ( 'uniinv' , msg = 'test completed' ) end subroutine test_uniinv !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT function random_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","loc":"program/runtest.html"},{"title":"test_mrgrnk – orderpack","text":"Uses M_mrgrnk Contents Variables dd dp finish i indx isz j k m pp start Source Code test_mrgrnk Variables Type Attributes Name Initial real(kind=dp), allocatable :: dd (:) integer, parameter :: dp = kind(0.0d0) real(kind=dp) :: finish integer :: i integer, allocatable :: indx (:) integer, parameter :: isz = 10000000 integer :: j integer :: k integer :: m real(kind=dp) :: pp real(kind=dp) :: start Source Code program test_mrgrnk ! depending on the compiler and options you might have to unlimit stacksize ! to avoid segmentation faults when using large arrays, or specify on ! compiler to put arrays on heap. ! !    ulimit -s unlimited # bash shell use M_mrgrnk , only : mrgrnk implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000000 real ( kind = dp ), allocatable :: dd (:) real ( kind = dp ) :: pp integer , allocatable :: indx (:) integer :: i , j , k , m real ( kind = dp ) :: start , finish ! ! set up storage ! if ( allocated ( indx )) deallocate ( indx ) allocate ( indx ( isz )) if ( allocated ( dd )) deallocate ( dd ) allocate ( dd ( isz )) ! ! make some random numbers ! call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo !do i=1,isz !   write(*,*)i,indx(i),dd(indx(i)) !enddo write ( * , * ) 'for MRGRNK(3f):         ' write ( * , * ) 'number of values to sort' , isz ! sort data call cpu_time ( start ) call mrgrnk ( dd , indx ) call cpu_time ( finish ) write ( * , * ) \"Processor Time (random)=              \" , finish - start , \" seconds.\" ! ! do some checks ! m = 0 do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , * ) 'ERROR: data not sorted i=' , i , 'indx=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) m = m + 1 endif enddo ! time if already sorted dd = dd ( indx ) call cpu_time ( start ) call mrgrnk ( dd , indx ) call cpu_time ( finish ) write ( * , * ) \"Processor Time (already sorted)=      \" , finish - start , \" seconds.\" ! time if initially reverse sorted dd = dd ( isz : 1 : - 1 ) call cpu_time ( start ) call mrgrnk ( dd , indx ) call cpu_time ( finish ) write ( * , * ) \"Processor Time (input reverse sorted)=\" , finish - start , \" seconds.\" write ( * , * ) 'lowest                  ' , dd ( indx ( 1 )), minval ( dd ),& & dd ( indx ( 1 )). eq . minval ( dd ) write ( * , * ) 'highest                 ' , dd ( indx ( size ( indx ))), maxval ( dd ),& & dd ( indx ( size ( indx ))). eq . maxval ( dd ) write ( * , * ) 'smallest absolute value ' , minval ( abs ( dd )) write ( * , * ) 'for reference huge is   ' , huge ( 0.0_dp ) write ( * , * ) '              tiny is   ' , tiny ( 0.0_dp ) write ( * , * ) '              epsilon is' , epsilon ( 0.0_dp ) if ( m . eq . 0 ) then write ( * , * ) 'sort passed' else write ( * , * ) 'sort failed, bad=' , m endif end program test_mrgrnk","tags":"","loc":"program/test_mrgrnk.html"}]}
var tipuesearch = {"pages":[{"title":" orderpack ","text":"orderpack Name orderpack(3f) - general and specialized ranking and sorting routines\n   (LICENSE:CC0-1.0) Description This repository is a clone of ORDERPACK 2.0 from Michel Olagnon that\nhas been restructured so as to be useable as an fpm(1) package; placed\nin a git(1) repository; and has a growing set of unit tests. ORDERPACK 2.0 provides Fortran procedures for General and Specialized\nRanking and Sorting Routines.  It includes Fortran 90 source code for\nUnconditional, Unique, and Partial Ranking, Sorting, and Permutation. Authors : Michel Olagnon date : 2000 - 2012 Suggestions, testing, test cases, feedback, and assistance welcome for\nthe update. Recent Events and Issues (See Also : CHANGELOG) 2022-04-19 uniinv, mulcnt now support CHARACTER variables 2022-04-18 Main sorting routines inssor(), mrgref(), mrgrnk(), refsor() can now take a CHARACTER array as an argument. Ongoing support of CHARACTER types continues.\n   - All routines now have a preliminary man-page containing an example program, which is also rendered into HTML\n   - All the example programs from the man-pages are also available as demo programs in the example directory.\n   - A (preliminary, but functional)  make(1) file has been added\n   - Developer Note: all routines are now using the prep(1) preprocessor and have been converted to templates to simplify \n maintaining code that allows multiple input types. There appear to be issues with the original code, but may have been introduced\n  (but are being looked at): UNIPAR returns non-unique values when less unique values in input than requested in output with gfortran,nvfortran; OK with ifort INDMED has issues that may only manifest when debug options are used when compiling At line 499 of file ./src/M_indmed.f90\n    Fortran runtime error: Array bound mismatch for dimension 1 of array 'iwrkt' (7/5) Building the module using make This will compile the Fortran module and basic example programs that exercise the routines: git clone https://github.com/urbanjost/orderpack.git cd orderpack/src # change Makefile if not using one of the listed compilers # for gfortran make clean\n     make gfortran # for ifort make clean\n     make ifort # for nvfortran make clean\n     make nvfortran Build and test with Download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) git clone https://github.com/urbanjost/orderpack.git cd orderpack\n        fpm build or just list it as a dependency in your fpm.toml project file. [dependencies] orderpack = { git = \"https://github.com/urbanjost/orderpack.git\" } Documentation User UNDER CONSTRUCTION an index to man-pages in HTML form for all the routines documentation derived from the original procedure documentation ,\n     which will gradually be replaced by the above. - CHANGELOG provides a history of significant changes Developer ford(1) output . doxygen(1) output . github action status See also * parallel mrgrnk References ORDERPACK2.0 ORDERPACK2.0 Wikipedia Developer Info Michel Olagnon","tags":"home","loc":"index.html"},{"title":"M_mulcnt.f90 – orderpack","text":"Contents Modules M_mulcnt Source Code M_mulcnt.f90 Source Code Module M_mulcnt use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 Use M_uniinv implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: mulcnt private :: real64_mulcnt , real32_mulcnt , int32_mulcnt interface mulcnt module procedure real64_mulcnt , real32_mulcnt , int32_mulcnt , f_char_mulcnt end interface mulcnt contains !> !!##NAME !!    mulcnt(3f) - [orderpack:MULTIPLICITY] Give the multiplicity for each !!                 array value (number of times that it appears in the array) !! !!##SYNOPSIS !! !!     Subroutine mulcnt (XDONT, IMULT) !! !!       ${TYPE} (kind=${KIND}), Intent (In) :: XDONT(:) !!       Integer, Dimension (:), Intent (Out) :: IMULT !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!     MULCNT = Give for each array value its multiplicity !!              (number of times that it appears in the array) !! !!##OPTIONS !!     XDONT      input array !!     IMULT      array containing how often the value in XDONT !!                appears in XDONT !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_mulcnt !!    use M_mulcnt, only : mulcnt !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    real,parameter :: xdont(*)=[1,2,3,4,5,6,7,4,5,6,6,2] !!    integer, dimension(size(xdont)) :: imult !!    character(len=20),allocatable :: strings(:) !!       ! !!       call mulcnt(xdont,imult) !!       write(*,*)xdont !!       write(*,g)imult !!       ! !!       strings= [ character(len=20) ::                           & !!       & 'red',    'green', 'blue', 'yellow', 'orange',   'black'] !!       call printme() !!       ! !!       strings= [ character(len=20) ::                           & !!       & 'two  ',  'four ', 'three', 'five',   'five',           & !!       & 'two  ',  'four ', 'three', 'five',   'five',           & !!       & 'four ',  'four ', 'three', 'one  ',  'five'] !!       call printme() !!       ! !!       strings=['purple', 'purple', 'purple', 'purple'] !!       call printme() !!       contains !!       subroutine printme() !!       integer,allocatable :: cindx(:) !!       integer :: csz !!       integer :: i !!          csz=size(strings) !!          if(allocated(cindx))deallocate(cindx) !!          allocate(cindx(csz)) !!          call mulcnt(strings,cindx) !!          write(*,g)(trim(strings(i)),i=1,csz) !!          write(*,g)cindx !!       end subroutine printme !!    end program demo_mulcnt !! !!   Results: !! !!       1.000000   2.000000   3.000000   4.000000   5.000000 !!       6.000000   7.000000   4.000000   5.000000   6.000000 !!       6.000000   2.000000 !!    1 2 1 2 2 3 1 2 2 3 3 2 !!    red green blue yellow orange black !!    1 1 1 1 1 1 !!    two four three five five two four three five five four four three one five !!    2 4 3 5 5 2 4 3 5 5 4 4 3 1 5 !!    purple purple purple purple !!    4 4 4 4 !! !! !!##AUTHOR !!     Michel Olagnon, Mar 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_mulcnt ( XDONT , IMULT ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Integer , Dimension ( Size ( XDONT )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( XDONT ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( XDONT ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine real64_mulcnt Subroutine real32_mulcnt ( XDONT , IMULT ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Integer , Dimension ( Size ( XDONT )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( XDONT ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( XDONT ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine real32_mulcnt Subroutine int32_mulcnt ( XDONT , IMULT ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Integer , Dimension ( Size ( XDONT )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( XDONT ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( XDONT ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine int32_mulcnt Subroutine f_char_mulcnt ( XDONT , IMULT ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IMULT ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Integer , Dimension ( Size ( XDONT )) :: ICNTT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) ICNTT = 0 Do ICRS = 1 , Size ( XDONT ) ICNTT ( IWRKT ( ICRS )) = ICNTT ( IWRKT ( ICRS )) + 1 End Do Do ICRS = 1 , Size ( XDONT ) IMULT ( ICRS ) = ICNTT ( IWRKT ( ICRS )) End Do ! End Subroutine f_char_mulcnt end module M_mulcnt","tags":"","loc":"sourcefile/m_mulcnt.f90.html"},{"title":"M_unipar.f90 – orderpack","text":"Contents Modules M_unipar Source Code M_unipar.f90 Source Code Module M_unipar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: unipar interface unipar module procedure real64_unipar , real32_unipar , int32_unipar end interface unipar contains !> !!##NAME !!    unipar(3f) - [orderpack:PARTIAL_RANK_UNIQUE] partially rank an array !!                 removing duplicates !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_unipar (XDONT, IRNGT, NORD) !! !!      ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!      Integer, Dimension (:), Intent (Out) :: IRNGT !!      Integer, Intent (InOut) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Ranks partially XDONT by IRNGT, up to order NORD at most, !!    removing duplicate entries !! !!    This routine uses a pivoting strategy such as the one of !!    finding the median based on the quicksort algorithm, but !!    we skew the pivot choice to try to bring it to NORD as !!    quickly as possible. It uses 2 temporary arrays, where it !!    stores the indices of the values smaller than the pivot !!    (ILOWT), and the indices of values larger than the pivot !!    that we might still need later on (IHIGT). It iterates !!    until it can bring the number of values in ILOWT to !!    exactly NORD, and then uses an insertion sort to rank !!    this set, since it is supposedly small. At all times, the !!    NORD first values in ILOWT correspond to distinct values !!    of the input array. !! !!##OPTIONS !!     XDONT      array to partially sort !!     IRNGT      indices returned that point to lowest values !!     NORD       number of sorted values to determine before !!                eliminating duplicates !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unipar !!    use M_unipar, only : unipar !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: xdont(:) !!    integer,allocatable :: irngt(:) !!    integer :: nord !!    ! !!    write(*,g)'If enough values are unique, will return NORD indices' !!    if(allocated(irngt))deallocate(irngt) !!    xdont=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!    allocate(irngt(nord)) !!    call printme() !!    ! !!    !BUG!write(*,g)'If not enough values are unique, will change NORD' !!    !BUG!xdont=[-1,0,-1,0,-1,0,-1] !!    !BUG!nord=5 !!    !BUG!if(allocated(irngt))deallocate(irngt) !!    !BUG!allocate(irngt(nord)) !!    !BUG!call printme() !!    contains !!    subroutine printme() !!       write(*,g)'ORIGINAL:',xdont !!       write(*,g)'NUMBER OF INDICES TO SORT:',nord !!       call unipar(xdont,irngt,nord) !!       write(*,g)'NUMBER OF INDICES RETURNED:',nord !!       write(*,g)'RETURNED INDICES:',irngt(:nord) !!       write(*,g)nord,'SMALLEST UNIQUE VALUES:',xdont(irngt(:nord)) !!    end subroutine !!    end program demo_unipar !! !!   Results: !! !!    If enough values are unique, will return NORD indices !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF INDICES TO SORT: 5 !!    NUMBER OF INDICES RETURNED: 5 !!    RETURNED INDICES: 11 5 2 7 3 !!    5 SMALLEST UNIQUE VALUES: 1 4 5 6 7 !!    If not enough values are unique, will change NORD !!    ORIGINAL: -1 0 -1 0 -1 0 -1 !!    NUMBER OF INDICES TO SORT: 5 !!    NUMBER OF INDICES RETURNED: 2 !!    RETURNED INDICES: 1 2 !!    2 SMALLEST UNIQUE VALUES: -1 0 !! !!##AUTHOR !!     Michel Olagnon - Feb. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_unipar ( XDONT , IRNGT , NORD ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( InOut ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XWRK , XWRK1 , XMIN , XMAX , XPIV0 ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) Then NORD = 1 IRNGT ( 1 ) = 1 End If Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! Do ICRS = 2 , NDON If ( XDONT ( ICRS ) == XDONT ( 1 )) Then Cycle Else If ( XDONT ( ICRS ) < XDONT ( 1 )) Then ILOWT ( 1 ) = ICRS IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = ICRS End If Exit End Do ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , 2 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! ICRS = ICRS + 1 JHIG = 1 If ( XDONT ( ICRS ) < XDONT ( IHIGT ( 1 ))) Then If ( XDONT ( ICRS ) < XDONT ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = ICRS Else If ( XDONT ( ICRS ) > XDONT ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ICRS End If ElseIf ( XDONT ( ICRS ) > XDONT ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) < XDONT ( IHIGT ( 1 ))) Then If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON JHIG = JHIG + 1 ElseIf ( XDONT ( NDON ) > XDONT ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = NDON JHIG = JHIG + 1 End If ElseIf ( XDONT ( NDON ) > XDONT ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = NDON End If ! If ( NDON <= ICRS + 1 ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT, i.e. one more than !  strictly necessary so as to be able to come out of the !  case where JLOWT would be NORD distinct values followed !  by values that are exclusively duplicates of these. ! ! If ( XDONT ( NDON ) > XPIV ) Then lowloop1 : Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( XDONT ( ICRS ) == XDONT ( ILOWT ( ILOW ))) Cycle lowloop1 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop1 ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! lowloop2 : Do ICRS = ICRS + 1 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( XDONT ( ICRS ) == XDONT ( ILOWT ( ILOW ))) Cycle lowloop2 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop2 ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIG = 0 Do ICRS = 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) /= XMIN ) then IHIG = IHIG + 1 IHIGT ( IHIG ) = IHIGT ( ICRS ) End If End Do JHIG = IHIG Else ILOW = ILOWT ( JLOW ) XMAX = XDONT ( ILOW ) Do ICRS = 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. In order to make better pivot choices, we !   decrease NORD if we already know that we don't have that !   many distinct values as a whole. ! IF ( JLOW + JHIG < NORD ) NORD = JLOW + JHIG Select Case ( NORD - JLOW ) ! ______________________________ Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) ! !   Not enough values in high part either (too many duplicates) ! Case ( 0 ) NORD = JLOW ! Case ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) ElseIf ( XDONT ( IHIGT ( 1 )) == XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 1 JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JHIG = JHIG + 1 IF ( XDONT ( IHIGT ( JHIG )) /= XDONT ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If JHIG = JHIG + 1 IF ( XDONT ( IHIGT ( JHIG )) /= XDONT ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If NORD = Min ( JLOW , NORD ) Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 lowloop3 : Do ICRS = 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then Do ILOW = 1 , JLOW If ( XDONT ( IHIGT ( ICRS )) == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop3 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW > NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do lowloop3 ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! ______________________________ ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! ______________________________ ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! ______________________________ ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) insert1 : Do ICRS = NORD + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do ILOW = 1 , NORD - 1 If ( XWRK <= XDONT ( IRNGT ( ILOW ))) Then If ( XWRK == XDONT ( IRNGT ( ILOW ))) Cycle insert1 Exit End If End Do Do IDCR = NORD - 1 , ILOW , - 1 IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do insert1 ! Return ! ! ______________________________ ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = MIN (( JLOW + IDEB ) / 2 , NORD ) IFIN = MIN ( JLOW , NORD + 1 ) ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 IFIN = JLOW JLOW = JDEB ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB lowloop4 : Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else XWRK1 = XDONT ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop4 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop4 ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else lowloop5 : Do ICRS = IDEB , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else XWRK1 = XDONT ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop5 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop5 ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! ______________________________ ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real64_unipar Subroutine real32_unipar ( XDONT , IRNGT , NORD ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( InOut ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XWRK , XWRK1 , XMIN , XMAX , XPIV0 ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) Then NORD = 1 IRNGT ( 1 ) = 1 End If Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! Do ICRS = 2 , NDON If ( XDONT ( ICRS ) == XDONT ( 1 )) Then Cycle Else If ( XDONT ( ICRS ) < XDONT ( 1 )) Then ILOWT ( 1 ) = ICRS IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = ICRS End If Exit End Do ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , 2 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! ICRS = ICRS + 1 JHIG = 1 If ( XDONT ( ICRS ) < XDONT ( IHIGT ( 1 ))) Then If ( XDONT ( ICRS ) < XDONT ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = ICRS Else If ( XDONT ( ICRS ) > XDONT ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ICRS End If ElseIf ( XDONT ( ICRS ) > XDONT ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) < XDONT ( IHIGT ( 1 ))) Then If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON JHIG = JHIG + 1 ElseIf ( XDONT ( NDON ) > XDONT ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = NDON JHIG = JHIG + 1 End If ElseIf ( XDONT ( NDON ) > XDONT ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = NDON End If ! If ( NDON <= ICRS + 1 ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT, i.e. one more than !  strictly necessary so as to be able to come out of the !  case where JLOWT would be NORD distinct values followed !  by values that are exclusively duplicates of these. ! ! If ( XDONT ( NDON ) > XPIV ) Then lowloop1 : Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( XDONT ( ICRS ) == XDONT ( ILOWT ( ILOW ))) Cycle lowloop1 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop1 ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! lowloop2 : Do ICRS = ICRS + 1 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( XDONT ( ICRS ) == XDONT ( ILOWT ( ILOW ))) Cycle lowloop2 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop2 ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIG = 0 Do ICRS = 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) /= XMIN ) then IHIG = IHIG + 1 IHIGT ( IHIG ) = IHIGT ( ICRS ) End If End Do JHIG = IHIG Else ILOW = ILOWT ( JLOW ) XMAX = XDONT ( ILOW ) Do ICRS = 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. In order to make better pivot choices, we !   decrease NORD if we already know that we don't have that !   many distinct values as a whole. ! IF ( JLOW + JHIG < NORD ) NORD = JLOW + JHIG Select Case ( NORD - JLOW ) ! ______________________________ Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) ! !   Not enough values in high part either (too many duplicates) ! Case ( 0 ) NORD = JLOW ! Case ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) ElseIf ( XDONT ( IHIGT ( 1 )) == XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 1 JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JHIG = JHIG + 1 IF ( XDONT ( IHIGT ( JHIG )) /= XDONT ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If JHIG = JHIG + 1 IF ( XDONT ( IHIGT ( JHIG )) /= XDONT ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If NORD = Min ( JLOW , NORD ) Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 lowloop3 : Do ICRS = 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then Do ILOW = 1 , JLOW If ( XDONT ( IHIGT ( ICRS )) == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop3 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW > NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do lowloop3 ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! ______________________________ ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! ______________________________ ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! ______________________________ ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) insert1 : Do ICRS = NORD + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do ILOW = 1 , NORD - 1 If ( XWRK <= XDONT ( IRNGT ( ILOW ))) Then If ( XWRK == XDONT ( IRNGT ( ILOW ))) Cycle insert1 Exit End If End Do Do IDCR = NORD - 1 , ILOW , - 1 IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do insert1 ! Return ! ! ______________________________ ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = MIN (( JLOW + IDEB ) / 2 , NORD ) IFIN = MIN ( JLOW , NORD + 1 ) ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 IFIN = JLOW JLOW = JDEB ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB lowloop4 : Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else XWRK1 = XDONT ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop4 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop4 ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else lowloop5 : Do ICRS = IDEB , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else XWRK1 = XDONT ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop5 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop5 ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! ______________________________ ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real32_unipar Subroutine int32_unipar ( XDONT , IRNGT , NORD ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( InOut ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XWRK , XWRK1 , XMIN , XMAX , XPIV0 ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) Then NORD = 1 IRNGT ( 1 ) = 1 End If Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! Do ICRS = 2 , NDON If ( XDONT ( ICRS ) == XDONT ( 1 )) Then Cycle Else If ( XDONT ( ICRS ) < XDONT ( 1 )) Then ILOWT ( 1 ) = ICRS IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = ICRS End If Exit End Do ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , 2 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! ICRS = ICRS + 1 JHIG = 1 If ( XDONT ( ICRS ) < XDONT ( IHIGT ( 1 ))) Then If ( XDONT ( ICRS ) < XDONT ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = ICRS Else If ( XDONT ( ICRS ) > XDONT ( ILOWT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( 1 ) IHIGT ( 1 ) = ICRS End If ElseIf ( XDONT ( ICRS ) > XDONT ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If ! If ( NDON <= ICRS ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) < XDONT ( IHIGT ( 1 ))) Then If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON JHIG = JHIG + 1 ElseIf ( XDONT ( NDON ) > XDONT ( ILOWT ( 1 ))) Then Do IDCR = JHIG , 1 , - 1 IHIGT ( IDCR + 1 ) = IHIGT ( IDCR ) End Do IHIGT ( 1 ) = NDON JHIG = JHIG + 1 End If ElseIf ( XDONT ( NDON ) > XDONT ( IHIGT ( 1 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = NDON End If ! If ( NDON <= ICRS + 1 ) Then NORD = Min ( NORD , JHIG + 1 ) If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT, i.e. one more than !  strictly necessary so as to be able to come out of the !  case where JLOWT would be NORD distinct values followed !  by values that are exclusively duplicates of these. ! ! If ( XDONT ( NDON ) > XPIV ) Then lowloop1 : Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( XDONT ( ICRS ) == XDONT ( ILOWT ( ILOW ))) Cycle lowloop1 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop1 ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! lowloop2 : Do ICRS = ICRS + 1 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else Do ILOW = 1 , JLOW If ( XDONT ( ICRS ) == XDONT ( ILOWT ( ILOW ))) Cycle lowloop2 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do lowloop2 ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIG = 0 Do ICRS = 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) /= XMIN ) then IHIG = IHIG + 1 IHIGT ( IHIG ) = IHIGT ( ICRS ) End If End Do JHIG = IHIG Else ILOW = ILOWT ( JLOW ) XMAX = XDONT ( ILOW ) Do ICRS = 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. In order to make better pivot choices, we !   decrease NORD if we already know that we don't have that !   many distinct values as a whole. ! IF ( JLOW + JHIG < NORD ) NORD = JLOW + JHIG Select Case ( NORD - JLOW ) ! ______________________________ Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) ! !   Not enough values in high part either (too many duplicates) ! Case ( 0 ) NORD = JLOW ! Case ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) ElseIf ( XDONT ( IHIGT ( 1 )) == XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) NORD = JLOW Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 1 JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JHIG = JHIG + 1 IF ( XDONT ( IHIGT ( JHIG )) /= XDONT ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If JHIG = JHIG + 1 IF ( XDONT ( IHIGT ( JHIG )) /= XDONT ( ILOWT ( JLOW ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( JHIG ) End If NORD = Min ( JLOW , NORD ) Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 lowloop3 : Do ICRS = 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then Do ILOW = 1 , JLOW If ( XDONT ( IHIGT ( ICRS )) == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop3 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW > NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do lowloop3 ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! ______________________________ ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! ______________________________ ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! ______________________________ ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) insert1 : Do ICRS = NORD + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do ILOW = 1 , NORD - 1 If ( XWRK <= XDONT ( IRNGT ( ILOW ))) Then If ( XWRK == XDONT ( IRNGT ( ILOW ))) Cycle insert1 Exit End If End Do Do IDCR = NORD - 1 , ILOW , - 1 IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do insert1 ! Return ! ! ______________________________ ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = MIN (( JLOW + IDEB ) / 2 , NORD ) IFIN = MIN ( JLOW , NORD + 1 ) ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 IFIN = JLOW JLOW = JDEB ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB lowloop4 : Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else XWRK1 = XDONT ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop4 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop4 ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else lowloop5 : Do ICRS = IDEB , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else XWRK1 = XDONT ( ILOWT ( ICRS )) Do ILOW = IDEB , JLOW If ( XWRK1 == XDONT ( ILOWT ( ILOW ))) & Cycle lowloop5 End Do JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do lowloop5 ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! ______________________________ ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine int32_unipar end module M_unipar","tags":"","loc":"sourcefile/m_unipar.f90.html"},{"title":"M_inssor.f90 – orderpack","text":"Contents Modules M_inssor Source Code M_inssor.f90 Source Code Module M_inssor use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: inssor interface inssor module procedure real64_inssor , real32_inssor , int32_inssor , f_char_inssor end interface inssor contains !> !!##NAME !!    inssor(3f) - [orderpack:SORT] Sorts array into ascending order !!                 (Insertion sort) !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_inssor (XDONT) !! !!             ${TYPE} (kind=${KIND}), Dimension (:), Intent (InOut) :: XDONT !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Sorts XDONT into ascending order (Insertion sort) !! !!    This subroutine uses an insertion sort. It does not use any work array !!    and is faster when XDONT is of very small size (< 20), or already !!    almost sorted, but worst case behavior can happen fairly probably !!    (initially inverse sorted).  In many cases, the quicksort or merge !!    sort method is faster. !! !!##OPTIONS !!     XDONT      array to sort !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_inssor !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_inssor, only : inssor !!    implicit none !!    ! an insertion sort is very efficient for very small arrays !!    ! but generally slower than methods like quicksort and mergesort. !!    real(kind=real32) :: valsr(2000) !!    real(kind=real64) :: valsd(2000) !!    integer           :: valsi(2000) !!    integer           :: i !!       call random_seed() !!       call random_number(valsr) !!       call random_number(valsd) !!       valsi=int(valsr*1000000.0) !!       valsr=valsr*1000000.0-500000.0 !!       valsd=valsd*1000000.0-500000.0 !!       call inssor(valsi) !!       do i=1,size(valsi)-1 !!          if (valsi(i+1).lt.valsi(i))then !!             write(*,*)'not sorted' !!             stop 1 !!          endif !!       enddo !!       call inssor(valsr) !!       do i=1,size(valsr)-1 !!          if (valsr(i+1).lt.valsr(i))then !!             write(*,*)'not sorted' !!             stop 2 !!          endif !!       enddo !!       call inssor(valsd) !!       do i=1,size(valsd)-1 !!          if (valsd(i+1).lt.valsd(i))then !!             write(*,*)'not sorted' !!             stop 3 !!          endif !!       enddo !!       write(*,*)'random arrays are now sorted' !!    end program demo_inssor !! !!   Results: !! !!     random arrays are now sorted !! !!##AUTHOR !!     Michel Olagnon - Apr. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_inssor ( XDONT ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: XDONT Real ( Kind = real64 ) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( XDONT ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( XDONT ( 1 ) < XDONT ( NDON )) Then XMIN = XDONT ( 1 ) Else XMIN = XDONT ( NDON ) XDONT ( NDON ) = XDONT ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = XDONT ( IDCR ) IF ( XWRK < XMIN ) Then XDONT ( IDCR ) = XMIN XMIN = XWRK End If End Do XDONT ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = XDONT ( ICRS ) IDCR = ICRS - 1 If ( XWRK < XDONT ( IDCR )) Then XDONT ( ICRS ) = XDONT ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) IDCR = IDCR - 1 End Do XDONT ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine real64_inssor Subroutine real32_inssor ( XDONT ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: XDONT Real ( Kind = real32 ) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( XDONT ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( XDONT ( 1 ) < XDONT ( NDON )) Then XMIN = XDONT ( 1 ) Else XMIN = XDONT ( NDON ) XDONT ( NDON ) = XDONT ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = XDONT ( IDCR ) IF ( XWRK < XMIN ) Then XDONT ( IDCR ) = XMIN XMIN = XWRK End If End Do XDONT ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = XDONT ( ICRS ) IDCR = ICRS - 1 If ( XWRK < XDONT ( IDCR )) Then XDONT ( ICRS ) = XDONT ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) IDCR = IDCR - 1 End Do XDONT ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine real32_inssor Subroutine int32_inssor ( XDONT ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: XDONT Integer ( Kind = int32 ) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( XDONT ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( XDONT ( 1 ) < XDONT ( NDON )) Then XMIN = XDONT ( 1 ) Else XMIN = XDONT ( NDON ) XDONT ( NDON ) = XDONT ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = XDONT ( IDCR ) IF ( XWRK < XMIN ) Then XDONT ( IDCR ) = XMIN XMIN = XWRK End If End Do XDONT ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = XDONT ( ICRS ) IDCR = ICRS - 1 If ( XWRK < XDONT ( IDCR )) Then XDONT ( ICRS ) = XDONT ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) IDCR = IDCR - 1 End Do XDONT ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine int32_inssor Subroutine f_char_inssor ( XDONT ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: XDONT character ( Kind = f_char , len = len ( XDONT )) :: XWRK , XMIN ! __________________________________________________________ Integer :: ICRS , IDCR , NDON ! NDON = Size ( XDONT ) ! ! We first bring the minimum to the first location in the array. ! That way, we will have a \"guard\", and when looking for the ! right place to insert a value, no loop test is necessary. ! If ( XDONT ( 1 ) < XDONT ( NDON )) Then XMIN = XDONT ( 1 ) Else XMIN = XDONT ( NDON ) XDONT ( NDON ) = XDONT ( 1 ) Endif Do IDCR = NDON - 1 , 2 , - 1 XWRK = XDONT ( IDCR ) IF ( XWRK < XMIN ) Then XDONT ( IDCR ) = XMIN XMIN = XWRK End If End Do XDONT ( 1 ) = XMIN ! ! The first value is now the minimum ! Loop over the array, and when a value is smaller than ! the previous one, loop down to insert it at its right place. ! Do ICRS = 3 , NDON XWRK = XDONT ( ICRS ) IDCR = ICRS - 1 If ( XWRK < XDONT ( IDCR )) Then XDONT ( ICRS ) = XDONT ( IDCR ) IDCR = IDCR - 1 Do If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) IDCR = IDCR - 1 End Do XDONT ( IDCR + 1 ) = XWRK End If End Do ! Return ! End Subroutine f_char_inssor end module M_inssor","tags":"","loc":"sourcefile/m_inssor.f90.html"},{"title":"M_mrgref.f90 – orderpack","text":"Contents Modules M_mrgref Source Code M_mrgref.f90 Source Code Module M_mrgref use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: mrgref interface mrgref module procedure real64_mrgref , real32_mrgref , int32_mrgref , f_char_mrgref end interface mrgref contains !> !!##NAME !!    mrgref(3f) - [orderpack:RANK] produces a sorted ranking of input array !!                 (basic merge-sort) !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_mrgref (XVALT, IRNGT) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XVALT !!       Integer, Dimension (:), Intent (Out) :: IRNGT !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Ranks array XVALT, filling array IRNGT with sorted indices. !! !!    It uses a basic merge-sort. !! !!    This version is not optimized for performance, and is thus !!    not as difficult to read as some other ones. !! !!##OPTIONS !!     XVALT      input array to rank !!     IRNGT      returned rank array !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_mrgref !!    use M_mrgref, only : mrgref !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,parameter             :: dp=kind(0.0d0) !!    integer,parameter             :: isz=10000 !!    real(kind=dp)                 :: dd(isz) !!    real(kind=dp)                 :: pp !!    integer                       :: indx(isz) !!    integer                       :: i,j,k !!    character(len=:),allocatable  :: strings(:) !!    integer,allocatable           :: cindx(:) !!       ! make some random numbers !!       call random_seed() !!       call random_number(dd) !!       dd=dd-0.50_dp !!       k=int(log(huge(0.0_dp))/log(2.0_dp))-1 !!       do i=1,isz !!          call random_number(pp) !!          j=floor((k+1)*pp) !!          dd(i)=dd(i)*(2.0_dp**j) !!       enddo !!       ! rank the numeric data !!       call mrgref(dd,indx) !!       ! check order !!       do i=1,isz-1 !!          if(dd(indx(i)).gt.dd(indx(i+1)))then !!             write(*,g)'ERROR: data not sorted i=',i,'index=',indx(i), & !!             & 'values ',dd(indx(i)),dd(indx(i+1)) !!             stop 1 !!          endif !!       enddo !!       ! sort data using rank values !!       dd=dd(indx) !!       write(*,g)'sorted ',isz,'values' !!       write(*,g)'from',dd(1),'to',dd(isz) !!       write(*,*)minval(dd).eq.dd(1) !!       write(*,*)maxval(dd).eq.dd(isz) !!       write(*,*)minloc(dd).eq.1 !!       write(*,*)maxloc(dd).eq.isz !!       ! do a character sort !!       strings= [ character(len=20) ::                               & !!       & 'red',    'green', 'blue', 'yellow', 'orange',   'black', & !!       & 'white',  'brown', 'gray', 'cyan',   'magenta',           & !!       & 'purple'] !!       if(allocated(cindx))deallocate(cindx);allocate(cindx(size(strings))) !! !!       write(*,'(a,8(a:,\",\"))')'BEFORE ',& !!               & (trim(strings(i)),i=1,size(strings)) !! !!       call mrgref(strings,cindx) !! !!       write(*,'(a,8(a:,\",\"))')'SORTED ',& !!               & (trim(strings(cindx(i))),i=1,size(strings)) !! !!       strings=strings(cindx) ! sort the array using the rank index !! !!       do i=1,size(strings)-1 !!          if(strings(i).gt.strings(i+1))then !!             write(*,*)'Error in sorting strings a-z' !!          endif !!       enddo !!    end program demo_mrgref !! !!   Results: !! !!    sorted  10000 values !!    from -.3393216923767161E+308 to .4341912370205701E+308 !!     T !!     T !!     T !!     T !!    BEFORE red,green,blue,yellow,orange,black,white,brown, !!    gray,cyan,magenta,purple !!    SORTED black,blue,brown,cyan,gray,green,magenta,orange, !!    purple,red,white,yellow !! !!##AUTHOR !!     Michel Olagnon - April 2000 !! !!     John Urban, 2022.04.16 !!         o added man-page and reduced to a template using the !!           prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_mrgref ( XVALT , IRNGT ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( XVALT ( IRNGT ( JINDA )) <= XVALT ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( XVALT ( IRNGT ( IINDA + 1 )) > XVALT ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine real64_mrgref Subroutine real32_mrgref ( XVALT , IRNGT ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( XVALT ( IRNGT ( JINDA )) <= XVALT ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( XVALT ( IRNGT ( IINDA + 1 )) > XVALT ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine real32_mrgref Subroutine int32_mrgref ( XVALT , IRNGT ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( XVALT ( IRNGT ( JINDA )) <= XVALT ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( XVALT ( IRNGT ( IINDA + 1 )) > XVALT ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine int32_mrgref Subroutine f_char_mrgref ( XVALT , IRNGT ) !!__________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ ! Integer , Dimension (:), Allocatable :: JWRKT Integer :: LMTNA , LMTNC Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) If ( NVAL <= 0 ) Then Return End If ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! Allocate ( JWRKT ( 1 : NVAL )) LMTNC = 2 LMTNA = 2 ! !  Iteration. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC IWRK = 0 ! !   Loop on merges of A and B into C ! Do IINDA = IWRKF IWRKD = IWRKF + 1 IWRKF = IINDA + LMTNC JINDA = IINDA + LMTNA If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDB = JINDA ! !   Shortcut for the case when the max of A is smaller !   than the min of B (no need to do anything) ! If ( XVALT ( IRNGT ( JINDA )) <= XVALT ( IRNGT ( JINDA + 1 ))) Then IWRK = IWRKF Cycle End If ! !  One steps in the C subset, that we create in the final rank array ! Do If ( IWRK >= IWRKF ) Then ! !  Make a copy of the rank array for next iteration ! IRNGT ( IWRKD : IWRKF ) = JWRKT ( IWRKD : IWRKF ) Exit End If ! IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( IINDA < JINDA ) Then If ( IINDB < IWRKF ) Then If ( XVALT ( IRNGT ( IINDA + 1 )) > XVALT ( IRNGT ( IINDB + 1 ))) & & Then IINDB = IINDB + 1 JWRKT ( IWRK ) = IRNGT ( IINDB ) Else IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only A still with unprocessed values ! IINDA = IINDA + 1 JWRKT ( IWRK ) = IRNGT ( IINDA ) End If Else ! !  Only B still with unprocessed values ! IRNGT ( IWRKD : IINDB ) = JWRKT ( IWRKD : IINDB ) IWRK = IWRKF Exit End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !  Clean up ! Deallocate ( JWRKT ) Return ! End Subroutine f_char_mrgref end module M_mrgref","tags":"","loc":"sourcefile/m_mrgref.f90.html"},{"title":"M_rinpar.f90 – orderpack","text":"Contents Modules M_rinpar Source Code M_rinpar.f90 Source Code Module M_rinpar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: rinpar interface rinpar module procedure real64_rinpar , real32_rinpar , int32_rinpar end interface rinpar contains !> !!##NAME !!    rinpar(3f) - [orderpack:PARTIAL_RANK] creates partial rank index of !!                 N lowest values in an array !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_rinpar (XDONT, IRNGT, NORD) !! !!      ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!      Integer, Dimension (:), Intent (Out) :: IRNGT !!      Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !!    o Real(kind=real32) !!    o Real(kind=real64) !!    o Integer(kind=int32) !! !!##DESCRIPTION !!    Returns IRNGT(1:NORD) filled with the indices of the lowest values !!    in the array XDONT. More technically, it does a partial ranking of !!    the array XDONT of order NORD. !! !!    NORD is restricted to the range 1 to size(IRNGT). !! !!    This subroutine uses an insertion sort, limiting insertion to the first !!    NORD values. It does not use any work array and is fastest when NORD is !!    very small (2-5). but worst case behavior can happen fairly probably !!    (ie. if XDONT initially is inverse sorted).  Therefore, In many cases, !!    the refined quicksort method is faster. !! !!##OPTIONS !!     XDONT   array to partially sort !!     NORD    number of indices to return, restricted to 1 to size(IRNGT) !!##RETURNS !!     IRNGT   indices of requested number (NORD) of lowest values in XDONT !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rinpar !!    use M_rinpar, only : rinpar !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: xdont(:) !!    integer,allocatable :: irngt(:) !!    integer :: nord !!    xdont=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!    allocate(irngt(nord)) !!       write(*,g)'ORIGINAL:',xdont !!       call rinpar(xdont,irngt,nord) !!       write(*,g)'NUMBER OF INDICES TO RETURN:',nord !!       write(*,g)'RETURNED INDICES:',irngt !!       write(*,g)nord,'SMALLEST VALUES:',xdont(irngt(:nord)) !!    end program demo_rinpar !! !!   Results: !! !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF INDICES TO RETURN: 5 !!    RETURNED INDICES: 4 11 5 2 6 !!    5 SMALLEST VALUES: 1 1 4 5 5 !! !!##AUTHOR !!     Michel Olagnon - Feb. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_rinpar ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( XDONT ) If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! End Subroutine real64_rinpar Subroutine real32_rinpar ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( XDONT ) If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! End Subroutine real32_rinpar Subroutine int32_rinpar ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! IRNGT ( 1 ) = 1 Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , SIZE ( XDONT ) If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ICRS XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! End Subroutine int32_rinpar end module M_rinpar","tags":"","loc":"sourcefile/m_rinpar.f90.html"},{"title":"M_mrgrnk.f90 – orderpack","text":"Contents Modules M_mrgrnk Source Code M_mrgrnk.f90 Source Code Module M_mrgrnk use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: mrgrnk interface mrgrnk module procedure real64_mrgrnk , real32_mrgrnk , int32_mrgrnk , f_char_mrgrnk end interface mrgrnk contains !> !!##NAME !!    mrgrnk(3f) - [orderpack:RANK] produces a sorted ranking of input array !!                 (optimized merge-sort) !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_mrgrnk (XDONT, IRNGT) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer, Dimension (:), Intent (Out) :: IRNGT !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!     MRGRNK produces a sorted ranking array of an input array, using an !!     optimized and modified version of merge-sort. !! !!     For performance reasons, the first 2 passes are taken out of the !!     standard loop, and use dedicated coding. !! !!##OPTIONS !!     XDONT      The array to sort !!     IRNGT      The rank index returned !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_mrgrnk !!    use M_mrgrnk, only : mrgrnk !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,parameter             :: dp=kind(0.0d0) !!    integer,parameter             :: isz=10000 !!    real(kind=dp)                 :: dd(isz) !!    real(kind=dp)                 :: pp !!    integer                       :: indx(isz) !!    integer                       :: i,j,k !!    character(len=:),allocatable  :: strings(:) !!    integer,allocatable           :: cindx(:) !!       ! make some random numbers !!       call random_seed() !!       call random_number(dd) !!       dd=dd-0.50_dp !!       k=int(log(huge(0.0_dp))/log(2.0_dp))-1 !!       do i=1,isz !!          call random_number(pp) !!          j=floor((k+1)*pp) !!          dd(i)=dd(i)*(2.0_dp**j) !!       enddo !!       ! rank the numeric data !!       call mrgrnk(dd,indx) !!       ! check order !!       do i=1,isz-1 !!          if(dd(indx(i)).gt.dd(indx(i+1)))then !!             write(*,g)'ERROR: data not sorted i=',i,'index=',indx(i), & !!             & 'values ',dd(indx(i)),dd(indx(i+1)) !!             stop 1 !!          endif !!       enddo !!       ! sort data using rank values !!       dd=dd(indx) !!       write(*,g)'sorted ',isz,'values' !!       write(*,g)'from',dd(1),'to',dd(isz) !!       write(*,*)minval(dd).eq.dd(1) !!       write(*,*)maxval(dd).eq.dd(isz) !!       write(*,*)minloc(dd).eq.1 !!       write(*,*)maxloc(dd).eq.isz !!       ! do a character sort !!       strings= [ character(len=20) ::                               & !!       & 'red',    'green', 'blue', 'yellow', 'orange',   'black', & !!       & 'white',  'brown', 'gray', 'cyan',   'magenta',           & !!       & 'purple'] !!       if(allocated(cindx))deallocate(cindx);allocate(cindx(size(strings))) !! !!       write(*,'(a,8(a:,\",\"))')'BEFORE ',& !!               & (trim(strings(i)),i=1,size(strings)) !! !!       call mrgrnk(strings,cindx) !! !!       write(*,'(a,8(a:,\",\"))')'SORTED ',& !!               & (trim(strings(cindx(i))),i=1,size(strings)) !! !!       strings=strings(cindx) ! sort the array using the rank index !! !!       do i=1,size(strings)-1 !!          if(strings(i).gt.strings(i+1))then !!             write(*,*)'Error in sorting strings a-z' !!          endif !!       enddo !!    end program demo_mrgrnk !! !!   Results: !! !!    sorted  10000 values !!    from -.4206770472235745E+308 to .3500810518521505E+308 !!     T !!     T !!     T !!     T !!    BEFORE red,green,blue,yellow,orange,black,white,brown, !!    gray,cyan,magenta,purple !!    SORTED black,blue,brown,cyan,gray,green,magenta,orange, !!    purple,red,white,yellow !! !!##AUTHOR !!     Michel Olagnon, 2000-2012 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_mrgrnk ( XDONT , IRNGT ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Real ( kind = real64 ) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) <= XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XDONT(IRNGT(JINDA)) <= XDONT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XDONT ( JWRKT ( IINDA )) XVALB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine real64_mrgrnk Subroutine real32_mrgrnk ( XDONT , IRNGT ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Real ( kind = real32 ) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) <= XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XDONT(IRNGT(JINDA)) <= XDONT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XDONT ( JWRKT ( IINDA )) XVALB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine real32_mrgrnk Subroutine int32_mrgrnk ( XDONT , IRNGT ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Integer ( kind = int32 ) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) <= XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XDONT(IRNGT(JINDA)) <= XDONT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XDONT ( JWRKT ( IINDA )) XVALB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine int32_mrgrnk Subroutine f_char_mrgrnk ( XDONT , IRNGT ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ character ( kind = f_char , len = len ( XDONT )) :: XVALA , XVALB ! Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) <= XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XDONT(IRNGT(JINDA)) <= XDONT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XDONT ( JWRKT ( IINDA )) XVALB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return ! End Subroutine f_char_mrgrnk end module M_mrgrnk","tags":"","loc":"sourcefile/m_mrgrnk.f90.html"},{"title":"M_median.f90 – orderpack","text":"Contents Modules M_median Source Code M_median.f90 Source Code Module M_median use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: median interface median module procedure real64_median , real32_median , int32_median end interface median contains !> !!##NAME !!    median(3f) - [orderpack:MEDIAN] Return median value of array. If even !!                 number of data, average of the two \"medians\". !! !!##SYNOPSIS !! !!     Function ${KIND}_median (XDONT) Result (median) !! !!      ${TYPE} (Kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!      ${TYPE} (Kind=${KIND}) :: median !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Return median value of XDONT.  If even number of data, average of !!    the two \"medians\". !! !!    This routine uses a pivoting strategy such as the one of finding the !!    median based on the quicksort algorithm, but we skew the pivot choice !!    to try to bring it to NORD as fast as possible. It uses 2 temporary !!    arrays, where it stores the indices of the values smaller than the !!    pivot (ILOWT), and the indices of values larger than the pivot that !!    we might still need later on (IHIGT). It iterates until it can bring !!    the number of values in ILOWT to exactly NORD, and then finds the !!    maximum of this set. !! !!##OPTIONS !!     XDONT      array to determine the median value of. !! !!##RETURNS !!     MEDIAN     median value. If XDONT contains an even number !!                of elements the value is the average of the !!                two \"medians\". !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_median !!    use M_median, only : median !!    implicit none !!    real,allocatable :: xdont(:) !!    integer :: ii !!       xdont=[80.0,70.0,20.0,10.0,1000.0] !!       write(*,*) median(xdont) !!       ! !!       xdont=[11, 22, 33, 44, 55, 66, 77, 88] !!       write(*,*) median(xdont) !!       ! !!       xdont=[11.0d0,22.0d0,33.0d0,66.0d0,77.0d0,88.0d0] !!       write(*,*) median(xdont) !!       ! !!    end program demo_median !! !!   Results: !! !!    > 70.00000 !!    > 49.50000 !!    > 49.50000 !! !!##AUTHOR !!     Michel Olagnon - Aug. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Function real64_median ( XDONT ) Result ( median ) Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Real ( Kind = real64 ) :: median ! __________________________________________________________ Real ( Kind = real64 ), Dimension ( SIZE ( XDONT )) :: XLOWT , XHIGT Real ( Kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX !! Logical :: IFODD Integer :: NDON , JHIG , JLOW , IHIG , NORD Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = NDON / 2 + 1 IFODD = ( 2 * INTH == NDON + 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 3 ) Then If ( NDON > 0 ) median = 0.5 * ( XDONT ( 1 ) + XDONT ( NDON )) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then XLOWT ( 1 ) = XDONT ( 2 ) XHIGT ( 1 ) = XDONT ( 1 ) Else XLOWT ( 1 ) = XDONT ( 1 ) XHIGT ( 1 ) = XDONT ( 2 ) End If ! ! If ( XDONT ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( 3 ) Else XHIGT ( 1 ) = XDONT ( 3 ) End If Else XHIGT ( 2 ) = XDONT ( 3 ) End If ! If ( NDON < 4 ) Then ! 3 values median = XHIGT ( 1 ) Return End If ! If ( XDONT ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( NDON ) Else XHIGT ( 1 ) = XDONT ( NDON ) End If Else If ( XDONT ( NDON ) < XHIGT ( 2 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XDONT ( NDON ) Else XHIGT ( 3 ) = XDONT ( NDON ) End If End If ! If ( NDON < 5 ) Then ! 4 values median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 3 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 2 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 1 ) - XLOWT ( 1 )) / 3.0 End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XMIN Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IF ( IFODD ) THEN JHIG = JLOW - INTH + 1 Else JHIG = JLOW - INTH + 2 Endif XHIGT ( 1 ) = XLOWT ( 1 ) Do ICRS = 2 , JHIG XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK End Do ! Do ICRS = JHIG + 1 , JLOW If ( XLOWT ( ICRS ) > XHIGT ( 1 )) Then XWRK = XLOWT ( ICRS ) Do IDCR = 2 , JHIG If ( XWRK >= XHIGT ( IDCR )) Then XHIGT ( IDCR - 1 ) = XHIGT ( IDCR ) else exit endif End Do XHIGT ( IDCR - 1 ) = XWRK End If End Do ! IF ( IFODD ) THEN median = XHIGT ( 1 ) Else median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Endif Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! if ( IFODD ) then median = MAXVAL ( XLOWT ( 1 : INTH )) else XWRK = MAX ( XLOWT ( 1 ), XLOWT ( 2 )) XWRK1 = MIN ( XLOWT ( 1 ), XLOWT ( 2 )) DO ICRS = 3 , INTH IF ( XLOWT ( ICRS ) > XWRK1 ) THEN IF ( XLOWT ( ICRS ) > XWRK ) THEN XWRK1 = XWRK XWRK = XLOWT ( ICRS ) Else XWRK1 = XLOWT ( ICRS ) ENDIF ENDIF ENDDO median = 0.5 * ( XWRK + XWRK1 ) endif Return ! End Function real64_median Function real32_median ( XDONT ) Result ( median ) Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Real ( Kind = real32 ) :: median ! __________________________________________________________ Real ( Kind = real32 ), Dimension ( SIZE ( XDONT )) :: XLOWT , XHIGT Real ( Kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX !! Logical :: IFODD Integer :: NDON , JHIG , JLOW , IHIG , NORD Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = NDON / 2 + 1 IFODD = ( 2 * INTH == NDON + 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 3 ) Then If ( NDON > 0 ) median = 0.5 * ( XDONT ( 1 ) + XDONT ( NDON )) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then XLOWT ( 1 ) = XDONT ( 2 ) XHIGT ( 1 ) = XDONT ( 1 ) Else XLOWT ( 1 ) = XDONT ( 1 ) XHIGT ( 1 ) = XDONT ( 2 ) End If ! ! If ( XDONT ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( 3 ) Else XHIGT ( 1 ) = XDONT ( 3 ) End If Else XHIGT ( 2 ) = XDONT ( 3 ) End If ! If ( NDON < 4 ) Then ! 3 values median = XHIGT ( 1 ) Return End If ! If ( XDONT ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( NDON ) Else XHIGT ( 1 ) = XDONT ( NDON ) End If Else If ( XDONT ( NDON ) < XHIGT ( 2 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XDONT ( NDON ) Else XHIGT ( 3 ) = XDONT ( NDON ) End If End If ! If ( NDON < 5 ) Then ! 4 values median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 3 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 2 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 1 ) - XLOWT ( 1 )) / 3.0 End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XMIN Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IF ( IFODD ) THEN JHIG = JLOW - INTH + 1 Else JHIG = JLOW - INTH + 2 Endif XHIGT ( 1 ) = XLOWT ( 1 ) Do ICRS = 2 , JHIG XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK End Do ! Do ICRS = JHIG + 1 , JLOW If ( XLOWT ( ICRS ) > XHIGT ( 1 )) Then XWRK = XLOWT ( ICRS ) Do IDCR = 2 , JHIG If ( XWRK >= XHIGT ( IDCR )) Then XHIGT ( IDCR - 1 ) = XHIGT ( IDCR ) else exit endif End Do XHIGT ( IDCR - 1 ) = XWRK End If End Do ! IF ( IFODD ) THEN median = XHIGT ( 1 ) Else median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Endif Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! if ( IFODD ) then median = MAXVAL ( XLOWT ( 1 : INTH )) else XWRK = MAX ( XLOWT ( 1 ), XLOWT ( 2 )) XWRK1 = MIN ( XLOWT ( 1 ), XLOWT ( 2 )) DO ICRS = 3 , INTH IF ( XLOWT ( ICRS ) > XWRK1 ) THEN IF ( XLOWT ( ICRS ) > XWRK ) THEN XWRK1 = XWRK XWRK = XLOWT ( ICRS ) Else XWRK1 = XLOWT ( ICRS ) ENDIF ENDIF ENDDO median = 0.5 * ( XWRK + XWRK1 ) endif Return ! End Function real32_median Function int32_median ( XDONT ) Result ( median ) Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer ( Kind = int32 ) :: median ! __________________________________________________________ Integer ( Kind = int32 ), Dimension ( SIZE ( XDONT )) :: XLOWT , XHIGT Integer ( Kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX !! Logical :: IFODD Integer :: NDON , JHIG , JLOW , IHIG , NORD Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = NDON / 2 + 1 IFODD = ( 2 * INTH == NDON + 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 3 ) Then If ( NDON > 0 ) median = 0.5 * ( XDONT ( 1 ) + XDONT ( NDON )) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then XLOWT ( 1 ) = XDONT ( 2 ) XHIGT ( 1 ) = XDONT ( 1 ) Else XLOWT ( 1 ) = XDONT ( 1 ) XHIGT ( 1 ) = XDONT ( 2 ) End If ! ! If ( XDONT ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( 3 ) Else XHIGT ( 1 ) = XDONT ( 3 ) End If Else XHIGT ( 2 ) = XDONT ( 3 ) End If ! If ( NDON < 4 ) Then ! 3 values median = XHIGT ( 1 ) Return End If ! If ( XDONT ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( NDON ) Else XHIGT ( 1 ) = XDONT ( NDON ) End If Else If ( XDONT ( NDON ) < XHIGT ( 2 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XDONT ( NDON ) Else XHIGT ( 3 ) = XDONT ( NDON ) End If End If ! If ( NDON < 5 ) Then ! 4 values median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 3 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 2 ) - XLOWT ( 1 )) / 3.0 If ( XPIV >= XHIGT ( 1 )) XPIV = XLOWT ( 1 ) + 2.0 * ( XHIGT ( 1 ) - XLOWT ( 1 )) / 3.0 End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XMIN Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IF ( IFODD ) THEN JHIG = JLOW - INTH + 1 Else JHIG = JLOW - INTH + 2 Endif XHIGT ( 1 ) = XLOWT ( 1 ) Do ICRS = 2 , JHIG XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK End Do ! Do ICRS = JHIG + 1 , JLOW If ( XLOWT ( ICRS ) > XHIGT ( 1 )) Then XWRK = XLOWT ( ICRS ) Do IDCR = 2 , JHIG If ( XWRK >= XHIGT ( IDCR )) Then XHIGT ( IDCR - 1 ) = XHIGT ( IDCR ) else exit endif End Do XHIGT ( IDCR - 1 ) = XWRK End If End Do ! IF ( IFODD ) THEN median = XHIGT ( 1 ) Else median = 0.5 * ( XHIGT ( 1 ) + XHIGT ( 2 )) Endif Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! if ( IFODD ) then median = MAXVAL ( XLOWT ( 1 : INTH )) else XWRK = MAX ( XLOWT ( 1 ), XLOWT ( 2 )) XWRK1 = MIN ( XLOWT ( 1 ), XLOWT ( 2 )) DO ICRS = 3 , INTH IF ( XLOWT ( ICRS ) > XWRK1 ) THEN IF ( XLOWT ( ICRS ) > XWRK ) THEN XWRK1 = XWRK XWRK = XLOWT ( ICRS ) Else XWRK1 = XLOWT ( ICRS ) ENDIF ENDIF ENDDO median = 0.5 * ( XWRK + XWRK1 ) endif Return ! End Function int32_median end module M_median","tags":"","loc":"sourcefile/m_median.f90.html"},{"title":"M_rapknr.f90 – orderpack","text":"Contents Modules M_rapknr Source Code M_rapknr.f90 Source Code Module M_rapknr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: rapknr interface rapknr module procedure real64_rapknr , real32_rapknr , int32_rapknr end interface rapknr contains !> !!##NAME !!    rapknr(3f) - [orderpack:PARTIAL_RANK] Ranks partially XDONT by IRNGT, !!                 up to order NORD, in decreasing order. !!                 rapknr = (rnkpar backwards) !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_rapknr (XDONT, IRNGT, NORD) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer, Dimension (:), Intent (Out) :: IRNGT !!       Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Ranks partially XDONT by IRNGT, up to order NORD, in decreasing order. !!    rapknr = (rnkpar backwards) !! !!    This routine uses a pivoting strategy such as the one of finding !!    the median based on the quicksort algorithm, but we skew the pivot !!    choice to try to bring it to NORD as fast as possible. It uses 2 !!    temporary arrays, where it stores the indices of the values larger !!    than the pivot (IHIGT), and the indices of values smaller than the !!    pivot that we might still need later on (ILOWT). It iterates until !!    it can bring the number of values in IHIGT to exactly NORD, and then !!    uses an insertion sort to rank this set, since it is supposedly small. !! !!##OPTIONS !!     XDONT      Array to rank !!     IRNGT      returned rank array, indicating order of values in !!                XDONT from largest to smallest !!     NORD       number of values to return in IRNGT !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rapknr !!    use M_rapknr, only : rapknr !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: xdont(:) !!    integer,allocatable :: irngt(:) !!    integer :: nord !!    xdont=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!    allocate(irngt(nord)) !!       write(*,g)'ORIGINAL:',xdont !!       call rapknr(xdont,irngt,nord) !!       write(*,g)'NUMBER OF INDICES TO RETURN:',nord !!       write(*,g)'RETURNED INDICES:',irngt !!       write(*,g)nord,'MAXIMUM VALUES:',xdont(irngt(:nord)) !!    end program demo_rapknr !! !!   Results: !! !!##AUTHOR !!    Michel Olagnon - Feb. 2011 !! !!    John Urban, 2022.04.16 !!    o added man-page and reduced to a template using the !!      prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_rapknr ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of high values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) Return End If ! --- If ( XDONT ( 3 ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) If ( XDONT ( 3 ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = 3 Else ILOWT ( 1 ) = 3 End If Else ILOWT ( 2 ) = 3 End If ! --- If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) Return End If ! If ( XDONT ( NDON ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = ILOWT ( 1 ) If ( XDONT ( NDON ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = NDON Else ILOWT ( 1 ) = NDON End If Else if ( XDONT ( NDON ) > XDONT ( ILOWT ( 2 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = NDON else ILOWT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = ILOWT ( 3 ) Return End If ! --- JDEB = 0 IDEB = JDEB + 1 JHIG = IDEB JLOW = 3 XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 3 )) - XDONT ( IHIGT ( IDEB ))) If ( XPIV >= XDONT ( ILOWT ( 1 ))) Then XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 2 )) - XDONT ( IHIGT ( IDEB ))) If ( XPIV >= XDONT ( ILOWT ( 1 ))) & XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 1 )) - XDONT ( IHIGT ( IDEB ))) End If XPIV0 = XPIV ! --- !  One puts values < pivot in the end and those >= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the ILOWT array as soon as we have more !  than enough values in IHIGT. ! ! If ( XDONT ( NDON ) < XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) < XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more low values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! --- Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) >= XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If End Do End If End If ! --- JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JHIG == NORD ) Exit If ( JHM2 == JHIG . And . JLM2 == JLOW ) Then ! !   We are oscillating. Perturbate by bringing JHIG closer by one !   to NORD ! If ( NORD > JHIG ) Then XMAX = XDONT ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then XMAX = XDONT ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) ILOWT ( ILOW ) = ILOWT ( JLOW ) JLOW = JLOW - 1 Else IHIG = IHIGT ( JHIG ) XMIN = XDONT ( IHIG ) Do ICRS = 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then IWRK = IHIGT ( ICRS ) XMIN = XDONT ( IWRK ) IHIGT ( ICRS ) = IHIG IHIG = IWRK End If End Do JHIG = JHIG - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! --- !   We try to bring the number of values in the high values set !   closer to NORD. ! Select Case ( NORD - JHIG ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JLOW ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the low values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( ILOWT ( 1 )) >= XDONT ( ILOWT ( 2 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) End If Exit ! --- Case ( 3 ) ! ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( 3 ) If ( XDONT ( IWRK2 ) > XDONT ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) < XDONT ( IWRK3 )) Then ILOWT ( 3 ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If JLOW = 0 Do ICRS = JHIG + 1 , NORD JLOW = JLOW + 1 IHIGT ( ICRS ) = ILOWT ( JLOW ) End Do JHIG = NORD Exit ! --- Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JLOW ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( IFIN ) If ( XDONT ( IWRK2 ) > XDONT ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) < XDONT ( IWRK3 )) Then ILOWT ( IFIN ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If ! JDEB = JHIG NWRK = NORD - JHIG IWRK1 = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = IWRK1 XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values >= pivot to IHIGT !  Again, 2 parts, one where we take care of the remaining !  low values because we might still need them, and the !  other when we know that we will have more than enough !  high values in the end. ! --- JLOW = 0 Do ICRS = 2 , IFIN If ( XDONT ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( JHIG >= NORD ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) End If End Do End Select ! --- ! Case ( 1 ) ! !  Only 1 value is missing in high part ! XMAX = XDONT ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then XMAX = XDONT ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! --- ! Case ( - 5 : - 1 ) ! !  Only few values too many in high part ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) > XWRK1 ) Then XWRK = XDONT ( IHIGT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK <= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = IHIGT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in high part ! --- IDEB = JDEB + 1 IMIL = ( JHIG + IDEB ) / 2 IFIN = JHIG ! --- !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( IHIGT ( IMIL )) > XDONT ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If If ( XDONT ( IHIGT ( IMIL )) < XDONT ( IHIGT ( IFIN ))) Then IWRK = IHIGT ( IFIN ) IHIGT ( IFIN ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK If ( XDONT ( IHIGT ( IMIL )) > XDONT ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! --- XPIV = XDONT ( IHIGT ( 1 )) + REAL ( NORD ) / REAL ( JHIG + NORD ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IHIGT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JHIG + NORD ) * & ( XDONT ( IHIGT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values < XPIV to ILOWT !  However, we do not process the first values if we have been !  through the case when we did not have enough high values ! --- JLOW = 0 JHIG = JDEB ! --- If ( XDONT ( IHIGT ( IFIN )) < XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( XDONT ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! --- If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( XDONT ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do End If ! End Select ! End Do ! --- !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! End Subroutine real64_rapknr Subroutine real32_rapknr ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of high values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) Return End If ! --- If ( XDONT ( 3 ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) If ( XDONT ( 3 ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = 3 Else ILOWT ( 1 ) = 3 End If Else ILOWT ( 2 ) = 3 End If ! --- If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) Return End If ! If ( XDONT ( NDON ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = ILOWT ( 1 ) If ( XDONT ( NDON ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = NDON Else ILOWT ( 1 ) = NDON End If Else if ( XDONT ( NDON ) > XDONT ( ILOWT ( 2 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = NDON else ILOWT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = ILOWT ( 3 ) Return End If ! --- JDEB = 0 IDEB = JDEB + 1 JHIG = IDEB JLOW = 3 XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 3 )) - XDONT ( IHIGT ( IDEB ))) If ( XPIV >= XDONT ( ILOWT ( 1 ))) Then XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 2 )) - XDONT ( IHIGT ( IDEB ))) If ( XPIV >= XDONT ( ILOWT ( 1 ))) & XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 1 )) - XDONT ( IHIGT ( IDEB ))) End If XPIV0 = XPIV ! --- !  One puts values < pivot in the end and those >= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the ILOWT array as soon as we have more !  than enough values in IHIGT. ! ! If ( XDONT ( NDON ) < XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) < XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more low values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! --- Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) >= XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If End Do End If End If ! --- JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JHIG == NORD ) Exit If ( JHM2 == JHIG . And . JLM2 == JLOW ) Then ! !   We are oscillating. Perturbate by bringing JHIG closer by one !   to NORD ! If ( NORD > JHIG ) Then XMAX = XDONT ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then XMAX = XDONT ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) ILOWT ( ILOW ) = ILOWT ( JLOW ) JLOW = JLOW - 1 Else IHIG = IHIGT ( JHIG ) XMIN = XDONT ( IHIG ) Do ICRS = 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then IWRK = IHIGT ( ICRS ) XMIN = XDONT ( IWRK ) IHIGT ( ICRS ) = IHIG IHIG = IWRK End If End Do JHIG = JHIG - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! --- !   We try to bring the number of values in the high values set !   closer to NORD. ! Select Case ( NORD - JHIG ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JLOW ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the low values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( ILOWT ( 1 )) >= XDONT ( ILOWT ( 2 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) End If Exit ! --- Case ( 3 ) ! ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( 3 ) If ( XDONT ( IWRK2 ) > XDONT ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) < XDONT ( IWRK3 )) Then ILOWT ( 3 ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If JLOW = 0 Do ICRS = JHIG + 1 , NORD JLOW = JLOW + 1 IHIGT ( ICRS ) = ILOWT ( JLOW ) End Do JHIG = NORD Exit ! --- Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JLOW ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( IFIN ) If ( XDONT ( IWRK2 ) > XDONT ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) < XDONT ( IWRK3 )) Then ILOWT ( IFIN ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If ! JDEB = JHIG NWRK = NORD - JHIG IWRK1 = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = IWRK1 XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values >= pivot to IHIGT !  Again, 2 parts, one where we take care of the remaining !  low values because we might still need them, and the !  other when we know that we will have more than enough !  high values in the end. ! --- JLOW = 0 Do ICRS = 2 , IFIN If ( XDONT ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( JHIG >= NORD ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) End If End Do End Select ! --- ! Case ( 1 ) ! !  Only 1 value is missing in high part ! XMAX = XDONT ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then XMAX = XDONT ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! --- ! Case ( - 5 : - 1 ) ! !  Only few values too many in high part ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) > XWRK1 ) Then XWRK = XDONT ( IHIGT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK <= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = IHIGT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in high part ! --- IDEB = JDEB + 1 IMIL = ( JHIG + IDEB ) / 2 IFIN = JHIG ! --- !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( IHIGT ( IMIL )) > XDONT ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If If ( XDONT ( IHIGT ( IMIL )) < XDONT ( IHIGT ( IFIN ))) Then IWRK = IHIGT ( IFIN ) IHIGT ( IFIN ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK If ( XDONT ( IHIGT ( IMIL )) > XDONT ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! --- XPIV = XDONT ( IHIGT ( 1 )) + REAL ( NORD ) / REAL ( JHIG + NORD ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IHIGT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JHIG + NORD ) * & ( XDONT ( IHIGT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values < XPIV to ILOWT !  However, we do not process the first values if we have been !  through the case when we did not have enough high values ! --- JLOW = 0 JHIG = JDEB ! --- If ( XDONT ( IHIGT ( IFIN )) < XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( XDONT ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! --- If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( XDONT ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do End If ! End Select ! End Do ! --- !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! End Subroutine real32_rapknr Subroutine int32_rapknr ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of high values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) Return End If ! --- If ( XDONT ( 3 ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) If ( XDONT ( 3 ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = 3 Else ILOWT ( 1 ) = 3 End If Else ILOWT ( 2 ) = 3 End If ! --- If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) Return End If ! If ( XDONT ( NDON ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = ILOWT ( 1 ) If ( XDONT ( NDON ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 1 ) = IHIGT ( 1 ) IHIGT ( 1 ) = NDON Else ILOWT ( 1 ) = NDON End If Else if ( XDONT ( NDON ) > XDONT ( ILOWT ( 2 ))) Then ILOWT ( 3 ) = ILOWT ( 2 ) ILOWT ( 2 ) = NDON else ILOWT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = IHIGT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = ILOWT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = ILOWT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = ILOWT ( 3 ) Return End If ! --- JDEB = 0 IDEB = JDEB + 1 JHIG = IDEB JLOW = 3 XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 3 )) - XDONT ( IHIGT ( IDEB ))) If ( XPIV >= XDONT ( ILOWT ( 1 ))) Then XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 2 )) - XDONT ( IHIGT ( IDEB ))) If ( XPIV >= XDONT ( ILOWT ( 1 ))) & XPIV = XDONT ( IHIGT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( ILOWT ( 1 )) - XDONT ( IHIGT ( IDEB ))) End If XPIV0 = XPIV ! --- !  One puts values < pivot in the end and those >= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the ILOWT array as soon as we have more !  than enough values in IHIGT. ! ! If ( XDONT ( NDON ) < XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) < XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more low values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! --- Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS If ( JHIG >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) >= XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS End If End Do End If End If ! --- JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JHIG == NORD ) Exit If ( JHM2 == JHIG . And . JLM2 == JLOW ) Then ! !   We are oscillating. Perturbate by bringing JHIG closer by one !   to NORD ! If ( NORD > JHIG ) Then XMAX = XDONT ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then XMAX = XDONT ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) ILOWT ( ILOW ) = ILOWT ( JLOW ) JLOW = JLOW - 1 Else IHIG = IHIGT ( JHIG ) XMIN = XDONT ( IHIG ) Do ICRS = 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then IWRK = IHIGT ( ICRS ) XMIN = XDONT ( IWRK ) IHIGT ( ICRS ) = IHIG IHIG = IWRK End If End Do JHIG = JHIG - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! --- !   We try to bring the number of values in the high values set !   closer to NORD. ! Select Case ( NORD - JHIG ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JLOW ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the low values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( ILOWT ( 1 )) >= XDONT ( ILOWT ( 2 ))) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 2 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( 1 ) End If Exit ! --- Case ( 3 ) ! ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( 3 ) If ( XDONT ( IWRK2 ) > XDONT ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) < XDONT ( IWRK3 )) Then ILOWT ( 3 ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) > XDONT ( ILOWT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If JLOW = 0 Do ICRS = JHIG + 1 , NORD JLOW = JLOW + 1 IHIGT ( ICRS ) = ILOWT ( JLOW ) End Do JHIG = NORD Exit ! --- Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JLOW ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = ILOWT ( 1 ) IWRK2 = ILOWT ( 2 ) IWRK3 = ILOWT ( IFIN ) If ( XDONT ( IWRK2 ) > XDONT ( IWRK1 )) Then ILOWT ( 1 ) = IWRK2 ILOWT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) < XDONT ( IWRK3 )) Then ILOWT ( IFIN ) = IWRK2 ILOWT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) > XDONT ( IHIGT ( 1 ))) Then ILOWT ( 2 ) = ILOWT ( 1 ) ILOWT ( 1 ) = IWRK2 End If End If ! JDEB = JHIG NWRK = NORD - JHIG IWRK1 = ILOWT ( 1 ) JHIG = JHIG + 1 IHIGT ( JHIG ) = IWRK1 XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values >= pivot to IHIGT !  Again, 2 parts, one where we take care of the remaining !  low values because we might still need them, and the !  other when we know that we will have more than enough !  high values in the end. ! --- JLOW = 0 Do ICRS = 2 , IFIN If ( XDONT ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( JHIG >= NORD ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) End If End Do End Select ! --- ! Case ( 1 ) ! !  Only 1 value is missing in high part ! XMAX = XDONT ( ILOWT ( 1 )) ILOW = 1 Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then XMAX = XDONT ( ILOWT ( ICRS )) ILOW = ICRS End If End Do ! JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ILOW ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! --- ! Case ( - 5 : - 1 ) ! !  Only few values too many in high part ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JHIG If ( XDONT ( IHIGT ( ICRS )) > XWRK1 ) Then XWRK = XDONT ( IHIGT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK <= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = IHIGT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in high part ! --- IDEB = JDEB + 1 IMIL = ( JHIG + IDEB ) / 2 IFIN = JHIG ! --- !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( IHIGT ( IMIL )) > XDONT ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If If ( XDONT ( IHIGT ( IMIL )) < XDONT ( IHIGT ( IFIN ))) Then IWRK = IHIGT ( IFIN ) IHIGT ( IFIN ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK If ( XDONT ( IHIGT ( IMIL )) > XDONT ( IHIGT ( IDEB ))) Then IWRK = IHIGT ( IDEB ) IHIGT ( IDEB ) = IHIGT ( IMIL ) IHIGT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! --- XPIV = XDONT ( IHIGT ( 1 )) + REAL ( NORD ) / REAL ( JHIG + NORD ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IHIGT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JHIG + NORD ) * & ( XDONT ( IHIGT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values < XPIV to ILOWT !  However, we do not process the first values if we have been !  through the case when we did not have enough high values ! --- JLOW = 0 JHIG = JDEB ! --- If ( XDONT ( IHIGT ( IFIN )) < XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( XDONT ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! --- If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( XDONT ( IHIGT ( ICRS )) < XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) If ( JHIG >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) >= XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do End If ! End Select ! End Do ! --- !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = IHIGT ( 1 ) Do ICRS = 2 , NORD IWRK = IHIGT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK > XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! End Subroutine int32_rapknr end module M_rapknr","tags":"","loc":"sourcefile/m_rapknr.f90.html"},{"title":"M_rnkpar.f90 – orderpack","text":"Contents Modules M_rnkpar Source Code M_rnkpar.f90 Source Code Module M_rnkpar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: rnkpar interface rnkpar module procedure real64_rnkpar , real32_rnkpar , int32_rnkpar end interface rnkpar contains !> !!##NAME !!    rnkpar(3f) - [orderpack:PARTIAL_RANK] Ranks partially XDONT by IRNGT, up to order NORD !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_rnkpar (XDONT, IRNGT, NORD) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer, Dimension (:), Intent (Out) :: IRNGT !!       Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Ranks partially XDONT by IRNGT, up to order NORD !! !!    This routine uses a pivoting strategy such as the one of !!    finding the median based on the quicksort algorithm, but !!    we skew the pivot choice to try to bring it to NORD as !!    fast as possible. It uses 2 temporary arrays, where it !!    stores the indices of the values smaller than the pivot !!    (ILOWT), and the indices of values larger than the pivot !!    that we might still need later on (IHIGT). It iterates !!    until it can bring the number of values in ILOWT to !!    exactly NORD, and then uses an insertion sort to rank !!    this set, since it is supposedly small. !! !!##OPTIONS !!     XDONT      array to rank the elements of !!     IRNGT      returned ranks !!     NORD       number of rank values to return !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_rnkpar !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_rnkpar, only : rnkpar !!    implicit none !!    integer,parameter :: ivals=300 !!    real(kind=real32) :: valsr(2000) !!    real(kind=real32) :: out(ivals) !!    integer           :: indx(2000) !!    integer           :: i !!       call random_seed() !!       call random_number(valsr) !!       valsr=valsr*1000000.0-500000.0 !!       call rnkpar(valsr,indx,ivals) !!       out=valsr(indx(:ivals)) !!       do i=1,ivals-1 !!          if (out(i+1).lt.out(i))then !!             write(*,*)'not sorted' !!             stop 1 !!          endif !!       enddo !!       write(*,*)'random array now sorted' !!    end program demo_rnkpar !! !!   Results: !! !!##AUTHOR !!     Michel Olagnon - Feb. 2000 !! !!     John Urban, 2022.04.16 !!         o added man-page and reduced to a template using the !!           prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_rnkpar ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) <= XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( 3 ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) <= XDONT ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else if ( XDONT ( NDON ) < XDONT ( IHIGT ( 2 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = NDON else IHIGT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB JHIG = 3 XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( JLOW ) XMAX = XDONT ( ILOW ) Do ICRS = 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. ! Select Case ( NORD - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , NORD JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = NORD Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = ( JLOW + IDEB ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( 1 )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 JLOW = JDEB ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real64_rnkpar Subroutine real32_rnkpar ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) <= XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( 3 ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) <= XDONT ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else if ( XDONT ( NDON ) < XDONT ( IHIGT ( 2 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = NDON else IHIGT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB JHIG = 3 XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( JLOW ) XMAX = XDONT ( ILOW ) Do ICRS = 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. ! Select Case ( NORD - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , NORD JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = NORD Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = ( JLOW + IDEB ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( 1 )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 JLOW = JDEB ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine real32_rnkpar Subroutine int32_rnkpar ( XDONT , IRNGT , NORD ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IDEB , JDEB , IMIL , IFIN , NWRK , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 ! NDON = SIZE ( XDONT ) ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) <= XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( 3 ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) <= XDONT ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else if ( XDONT ( NDON ) < XDONT ( IHIGT ( 2 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = NDON else IHIGT ( 3 ) = NDON endif End If ! If ( NDON < 5 ) Then If ( NORD >= 1 ) IRNGT ( 1 ) = ILOWT ( 1 ) If ( NORD >= 2 ) IRNGT ( 2 ) = IHIGT ( 1 ) If ( NORD >= 3 ) IRNGT ( 3 ) = IHIGT ( 2 ) If ( NORD >= 4 ) IRNGT ( 4 ) = IHIGT ( 3 ) Return End If ! JDEB = 0 IDEB = JDEB + 1 JLOW = IDEB JHIG = 3 XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( IDEB ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( IDEB )) + REAL ( 2 * NORD ) / REAL ( NDON + NORD ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( IDEB ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do if ( JLOW == NORD ) Exit If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to NORD ! If ( NORD > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( JLOW ) XMAX = XDONT ( ILOW ) Do ICRS = 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to NORD. ! Select Case ( NORD - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (*,*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , NORD JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = NORD Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! JDEB = JLOW NWRK = NORD - JLOW IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = XDONT ( IWRK1 ) + REAL ( NWRK ) / REAL ( NORD + NWRK ) * & ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= NORD ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) Exit ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do ! XWRK1 = XDONT ( IRNGT ( NORD )) Do ICRS = NORD + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( NORD )) End If End Do ! Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IDEB = JDEB + 1 IMIL = ( JLOW + IDEB ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( IDEB ))) Then IWRK = ILOWT ( IDEB ) ILOWT ( IDEB ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( 1 )) + REAL ( NORD ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) If ( JDEB > 0 ) Then If ( XPIV <= XPIV0 ) & XPIV = XPIV0 + REAL ( 2 * NORD - JDEB ) / REAL ( JLOW + NORD ) * & ( XDONT ( ILOWT ( IFIN )) - XPIV0 ) Else IDEB = 1 End If ! !  One takes values > XPIV to IHIGT !  However, we do not process the first values if we have been !  through the case when we did not have enough low values ! JHIG = 0 JLOW = JDEB ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = JDEB Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = IDEB , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= NORD ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! IRNGT ( 1 ) = ILOWT ( 1 ) Do ICRS = 2 , NORD IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK End Do Return ! ! End Subroutine int32_rnkpar end module M_rnkpar","tags":"","loc":"sourcefile/m_rnkpar.f90.html"},{"title":"M_valmed.f90 – orderpack","text":"Contents Modules M_valmed Source Code M_valmed.f90 Source Code Module M_valmed use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: valmed interface valmed module procedure real64_valmed , real32_valmed , int32_valmed end interface valmed contains !> !!##NAME !!    valmed(3f) - [orderpack:MEDIAN] finds the median of an array, averaging !!                 the two central values when size of array is even. !! !!##SYNOPSIS !! !!     Recursive Function ${KIND}_valmed (XDONT) Result (res_med) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       ${TYPE} (kind=${KIND}) :: res_med !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !! !!    Finds the median of XDONT using the recursive procedure described in !!    Knuth, The Art of Computer Programming, vol. 3, 5.3.3 - This procedure !!    is linear in time, and does not require to be able to interpolate !!    in the set as the one used in INDNTH. It also has better worst case !!    behavior than INDNTH, but is about 30% slower on average for random !!    uniformly distributed values. !! !!##OPTIONS !!     XDONT      input array !! !!##RETURNS !!     RES_MED    the median value of the array XDONT !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_valmed !!    use M_valmed, only : valmed !!    implicit none !!    real,parameter :: xdont(*)=[80.0,70.0,20.0,10.0,1000.0] !!    real res_med !!       write(*,*)valmed(xdont) !!       write(*, *)valmed([11, 22, 33, 44, 55, 66, 77, 88]) !!       write(*, *)valmed([11.0d0, 22.0d0, 33.0d0, 66.0d0, 77.0d0, 88.0d0]) !!    end program demo_valmed !! !!   Results: !! !!    > 70.00000 !!    >        44 !!    > 33.0000000000000 !! !!##AUTHOR !!     Michel Olagnon, 2000-2012 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Recursive Function real64_valmed ( XDONT ) Result ( res_med ) !!__________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Real ( kind = real64 ) :: res_med ! __________________________________________________________ Real ( kind = real64 ), Parameter :: XHUGE = HUGE ( XDONT ) Real ( kind = real64 ), Dimension ( SIZE ( XDONT ) + 6 ) :: XWRKT Real ( kind = real64 ) :: XWRK , XWRK1 , XMED7 ! Integer , Dimension (( SIZE ( XDONT ) + 6 ) / 7 ) :: ISTRT , IENDT , IMEDT Integer :: NDON , NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , IWRK , IDCR , ICRS , ICRS1 , ICRS2 , IMED1 ! NDON = SIZE ( XDONT ) NMED = ( NDON + 1 ) / 2 !      write(unit=*,fmt=*) NMED, NDON ! !  If the number of values is small, then use insertion sort ! If ( NDON < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDON If ( XDONT ( 1 ) < XDONT ( NDON )) Then XWRK = XDONT ( 1 ) XWRKT ( IDCR ) = XDONT ( IDCR ) Else XWRK = XDONT ( IDCR ) XWRKT ( IDCR ) = XDONT ( 1 ) Endif Do IWRK = 1 , NDON - 2 IDCR = IDCR - 1 XWRK1 = XDONT ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( 1 ) = XWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! !  Insert any value less than the current median in the first half ! Do ICRS = NMED + 1 , NDON XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( NMED )) Then IDCR = NMED - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End If End Do res_med = XWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  remove the loop test in the insertion loop. ! DO IDEB = 1 , NDON - 6 , 7 IDCR = IDEB + 6 If ( XDONT ( IDEB ) < XDONT ( IDCR )) Then XWRK = XDONT ( IDEB ) XWRKT ( IDCR ) = XDONT ( IDCR ) Else XWRK = XDONT ( IDCR ) XWRKT ( IDCR ) = XDONT ( IDEB ) Endif Do IWRK = 1 , 5 IDCR = IDCR - 1 XWRK1 = XDONT ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( IDEB ) = XWRK Do ICRS = IDEB + 2 , IDEB + 6 XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( ICRS - 1 )) Then XWRKT ( ICRS ) = XWRKT ( ICRS - 1 ) IDCR = ICRS - 1 XWRK1 = XWRKT ( IDCR - 1 ) Do If ( XWRK >= XWRK1 ) Exit XWRKT ( IDCR ) = XWRK1 IDCR = IDCR - 1 XWRK1 = XWRKT ( IDCR - 1 ) End Do XWRKT ( IDCR ) = XWRK EndIf End Do End Do ! !  Add-up alternatively + and - HUGE values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDON / 7 ) NTRI = NDON If ( IDEB < NDON ) Then ! XWRK1 = XHUGE Do ICRS = IDEB + 1 , IDEB + 7 If ( ICRS <= NDON ) Then XWRKT ( ICRS ) = XDONT ( ICRS ) Else If ( XWRK1 /= XHUGE ) NMED = NMED + 1 XWRKT ( ICRS ) = XWRK1 XWRK1 = - XWRK1 Endif End Do ! Do ICRS = IDEB + 2 , IDEB + 7 XWRK = XWRKT ( ICRS ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IDON + 3 End Do ! !  Find XMED7, the median of the medians ! XMED7 = real64_valmed ( XWRKT ( IMEDT )) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XWRKT ( IMED ) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XWRKT ( IMED ) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XWRKT (IMED) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values XWRK1 = XHUGE NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) < XWRK1 ) Then XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) >= XWRK1 ) Exit XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) End Do End If End Do res_med = XWRK1 Return Else res_med = XMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = - XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else Exit End If End Do Endif End Do ! res_med = XWRK1 Return End If ! End Function real64_valmed Recursive Function real32_valmed ( XDONT ) Result ( res_med ) !!__________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Real ( kind = real32 ) :: res_med ! __________________________________________________________ Real ( kind = real32 ), Parameter :: XHUGE = HUGE ( XDONT ) Real ( kind = real32 ), Dimension ( SIZE ( XDONT ) + 6 ) :: XWRKT Real ( kind = real32 ) :: XWRK , XWRK1 , XMED7 ! Integer , Dimension (( SIZE ( XDONT ) + 6 ) / 7 ) :: ISTRT , IENDT , IMEDT Integer :: NDON , NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , IWRK , IDCR , ICRS , ICRS1 , ICRS2 , IMED1 ! NDON = SIZE ( XDONT ) NMED = ( NDON + 1 ) / 2 !      write(unit=*,fmt=*) NMED, NDON ! !  If the number of values is small, then use insertion sort ! If ( NDON < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDON If ( XDONT ( 1 ) < XDONT ( NDON )) Then XWRK = XDONT ( 1 ) XWRKT ( IDCR ) = XDONT ( IDCR ) Else XWRK = XDONT ( IDCR ) XWRKT ( IDCR ) = XDONT ( 1 ) Endif Do IWRK = 1 , NDON - 2 IDCR = IDCR - 1 XWRK1 = XDONT ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( 1 ) = XWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! !  Insert any value less than the current median in the first half ! Do ICRS = NMED + 1 , NDON XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( NMED )) Then IDCR = NMED - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End If End Do res_med = XWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  remove the loop test in the insertion loop. ! DO IDEB = 1 , NDON - 6 , 7 IDCR = IDEB + 6 If ( XDONT ( IDEB ) < XDONT ( IDCR )) Then XWRK = XDONT ( IDEB ) XWRKT ( IDCR ) = XDONT ( IDCR ) Else XWRK = XDONT ( IDCR ) XWRKT ( IDCR ) = XDONT ( IDEB ) Endif Do IWRK = 1 , 5 IDCR = IDCR - 1 XWRK1 = XDONT ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( IDEB ) = XWRK Do ICRS = IDEB + 2 , IDEB + 6 XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( ICRS - 1 )) Then XWRKT ( ICRS ) = XWRKT ( ICRS - 1 ) IDCR = ICRS - 1 XWRK1 = XWRKT ( IDCR - 1 ) Do If ( XWRK >= XWRK1 ) Exit XWRKT ( IDCR ) = XWRK1 IDCR = IDCR - 1 XWRK1 = XWRKT ( IDCR - 1 ) End Do XWRKT ( IDCR ) = XWRK EndIf End Do End Do ! !  Add-up alternatively + and - HUGE values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDON / 7 ) NTRI = NDON If ( IDEB < NDON ) Then ! XWRK1 = XHUGE Do ICRS = IDEB + 1 , IDEB + 7 If ( ICRS <= NDON ) Then XWRKT ( ICRS ) = XDONT ( ICRS ) Else If ( XWRK1 /= XHUGE ) NMED = NMED + 1 XWRKT ( ICRS ) = XWRK1 XWRK1 = - XWRK1 Endif End Do ! Do ICRS = IDEB + 2 , IDEB + 7 XWRK = XWRKT ( ICRS ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IDON + 3 End Do ! !  Find XMED7, the median of the medians ! XMED7 = real32_valmed ( XWRKT ( IMEDT )) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XWRKT ( IMED ) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XWRKT ( IMED ) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XWRKT (IMED) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values XWRK1 = XHUGE NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) < XWRK1 ) Then XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) >= XWRK1 ) Exit XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) End Do End If End Do res_med = XWRK1 Return Else res_med = XMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = - XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else Exit End If End Do Endif End Do ! res_med = XWRK1 Return End If ! End Function real32_valmed Recursive Function int32_valmed ( XDONT ) Result ( res_med ) !!__________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer ( kind = int32 ) :: res_med ! __________________________________________________________ Integer ( kind = int32 ), Parameter :: XHUGE = HUGE ( XDONT ) Integer ( kind = int32 ), Dimension ( SIZE ( XDONT ) + 6 ) :: XWRKT Integer ( kind = int32 ) :: XWRK , XWRK1 , XMED7 ! Integer , Dimension (( SIZE ( XDONT ) + 6 ) / 7 ) :: ISTRT , IENDT , IMEDT Integer :: NDON , NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , IWRK , IDCR , ICRS , ICRS1 , ICRS2 , IMED1 ! NDON = SIZE ( XDONT ) NMED = ( NDON + 1 ) / 2 !      write(unit=*,fmt=*) NMED, NDON ! !  If the number of values is small, then use insertion sort ! If ( NDON < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDON If ( XDONT ( 1 ) < XDONT ( NDON )) Then XWRK = XDONT ( 1 ) XWRKT ( IDCR ) = XDONT ( IDCR ) Else XWRK = XDONT ( IDCR ) XWRKT ( IDCR ) = XDONT ( 1 ) Endif Do IWRK = 1 , NDON - 2 IDCR = IDCR - 1 XWRK1 = XDONT ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( 1 ) = XWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! !  Insert any value less than the current median in the first half ! Do ICRS = NMED + 1 , NDON XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( NMED )) Then IDCR = NMED - 1 Do If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) IDCR = IDCR - 1 End Do XWRKT ( IDCR + 1 ) = XWRK End If End Do res_med = XWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  remove the loop test in the insertion loop. ! DO IDEB = 1 , NDON - 6 , 7 IDCR = IDEB + 6 If ( XDONT ( IDEB ) < XDONT ( IDCR )) Then XWRK = XDONT ( IDEB ) XWRKT ( IDCR ) = XDONT ( IDCR ) Else XWRK = XDONT ( IDCR ) XWRKT ( IDCR ) = XDONT ( IDEB ) Endif Do IWRK = 1 , 5 IDCR = IDCR - 1 XWRK1 = XDONT ( IDCR ) If ( XWRK1 < XWRK ) Then XWRKT ( IDCR ) = XWRK XWRK = XWRK1 Else XWRKT ( IDCR ) = XWRK1 Endif End Do XWRKT ( IDEB ) = XWRK Do ICRS = IDEB + 2 , IDEB + 6 XWRK = XWRKT ( ICRS ) If ( XWRK < XWRKT ( ICRS - 1 )) Then XWRKT ( ICRS ) = XWRKT ( ICRS - 1 ) IDCR = ICRS - 1 XWRK1 = XWRKT ( IDCR - 1 ) Do If ( XWRK >= XWRK1 ) Exit XWRKT ( IDCR ) = XWRK1 IDCR = IDCR - 1 XWRK1 = XWRKT ( IDCR - 1 ) End Do XWRKT ( IDCR ) = XWRK EndIf End Do End Do ! !  Add-up alternatively + and - HUGE values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDON / 7 ) NTRI = NDON If ( IDEB < NDON ) Then ! XWRK1 = XHUGE Do ICRS = IDEB + 1 , IDEB + 7 If ( ICRS <= NDON ) Then XWRKT ( ICRS ) = XDONT ( ICRS ) Else If ( XWRK1 /= XHUGE ) NMED = NMED + 1 XWRKT ( ICRS ) = XWRK1 XWRK1 = - XWRK1 Endif End Do ! Do ICRS = IDEB + 2 , IDEB + 7 XWRK = XWRKT ( ICRS ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IDON + 3 End Do ! !  Find XMED7, the median of the medians ! XMED7 = int32_valmed ( XWRKT ( IMEDT )) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 2 If ( XWRKT ( IMED ) > XMED7 ) Then IMED = IMED - 1 Else If ( XWRKT ( IMED ) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XWRKT ( IMED ) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XWRKT ( IMED ) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XWRKT (IMED) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XWRKT ( IMED1 ) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values XWRK1 = XHUGE NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) < XWRK1 ) Then XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XWRKT ( ICRS ) >= XWRK1 ) Exit XWRK = XWRKT ( ICRS ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) End Do End If End Do res_med = XWRK1 Return Else res_med = XMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = - XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else If ( ICRS2 < NORD ) Then XWRKT ( ICRS1 ) = XWRKT ( ICRS ) XWRK1 = XWRKT ( ICRS1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XWRKT ( ICRS ) > XWRK1 ) Then XWRK = XWRKT ( ICRS ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( ICRS1 ) Else Exit End If End Do Endif End Do ! res_med = XWRK1 Return End If ! End Function int32_valmed end module M_valmed","tags":"","loc":"sourcefile/m_valmed.f90.html"},{"title":"M_fndnth.f90 – orderpack","text":"Contents Modules M_fndnth Source Code M_fndnth.f90 Source Code Module M_fndnth use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: fndnth interface fndnth module procedure real64_fndnth , real32_fndnth , int32_fndnth !, f_char_fndnth end interface fndnth contains !> !!##NAME !!    fndnth(3f) - [orderpack:FRACTILE] Return Nth lowest value of an array, !!                 i.e. return fractile of order N/SIZE(array) (InsertSort-like) !! !!##SYNOPSIS !! !!     Function fndnth (XDONT, NORD) Result (FNDNTH) !! !!      ${TYPE} (Kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!      Integer, Intent (In) :: NORD !!      ${TYPE} (Kind=${KIND}) :: FNDNTH !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!    o Real(kind=real32) !!    o Real(kind=real64) !!    o Integer(kind=int32) !!    o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Return NORDth lowest value of XDONT, i.e. fractile of order !!    NORD/SIZE(XDONT). !! !!    This subroutine uses an insertion sort, limiting insertion to the !!    first NORD values. It is very fast when NORD is very small (2-5), and !!    it requires only a work array of size NORD and type of XDONT, but !!    worst case behavior can happen fairly probably (initially inverse !!    sorted). In many cases, the refined quicksort method is faster. !! !!    So this should be used when NORD is small and XDONT is likely to be !!    a random array, otherwise consider using !! !!##OPTIONS !!     XDONT     input array of values !!     NORD      specify Nth value of sorted XDONT array to return, from !!               1 to size(XDONT). !!##RETURNS !!     FNDNTH    returned value !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_fndnth !!    use M_fndnth, only : fndnth !!    implicit none !!    character(len=*),parameter :: sp='(*(g0,1x))' !!    integer,allocatable :: iarr(:) !!    integer :: imiddle !!       iarr=[80,70,30,40,50,60,20,10] !!       print sp, 'ORIGINAL:',iarr !!       ! can return the same values as intrinsics minval() and maxval() !!       print sp, 'minval',fndnth(iarr,1),          minval(iarr) !!       print sp, 'maxval',fndnth(iarr,size(iarr)), maxval(iarr) !!       ! but more generally it can return the Nth lowest value. !!       print sp,'nord=',4, ' fractile=',fndnth(iarr,4) !!       ! so a value at the middle would be !!       imiddle=(size(iarr)+1)/2 !!       print sp,'median=',fndnth(iarr,imiddle) !!    end program demo_fndnth !! !!   Results: !! !!    ORIGINAL: 80 70 30 40 50 60 20 10 !!    minval 10 10 !!    maxval 80 80 !!    nord= 4 fractile= 40 !!    median= 40 !! !!##SEE ALSO !! !!    indnth(3), valnth(3) !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !! !!    John Urban, 2022.04.16 !!    o added man-page and reduced to a template using the !!      prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Function real64_fndnth ( XDONT , NORD ) Result ( FNDNTH ) ! __________________________________________________________ Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Real ( Kind = real64 ) :: FNDNTH Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( Kind = real64 ), Dimension ( NORD ) :: XWRKT Real ( Kind = real64 ) :: XWRK , XWRK1 ! Integer :: ICRS , IDCR , ILOW , NDON ! XWRKT ( 1 ) = XDONT ( 1 ) Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NDON = SIZE ( XDONT ) XWRK1 = XWRKT ( NORD ) ILOW = 2 * NORD - NDON Do ICRS = NORD + 1 , NDON If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) Do IDCR = NORD - 1 , MAX ( 1 , ILOW ) , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( NORD ) End If ILOW = ILOW + 1 End Do FNDNTH = XWRK1 ! End Function real64_fndnth Function real32_fndnth ( XDONT , NORD ) Result ( FNDNTH ) ! __________________________________________________________ Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Real ( Kind = real32 ) :: FNDNTH Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( Kind = real32 ), Dimension ( NORD ) :: XWRKT Real ( Kind = real32 ) :: XWRK , XWRK1 ! Integer :: ICRS , IDCR , ILOW , NDON ! XWRKT ( 1 ) = XDONT ( 1 ) Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NDON = SIZE ( XDONT ) XWRK1 = XWRKT ( NORD ) ILOW = 2 * NORD - NDON Do ICRS = NORD + 1 , NDON If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) Do IDCR = NORD - 1 , MAX ( 1 , ILOW ) , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( NORD ) End If ILOW = ILOW + 1 End Do FNDNTH = XWRK1 ! End Function real32_fndnth Function int32_fndnth ( XDONT , NORD ) Result ( FNDNTH ) ! __________________________________________________________ Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer ( Kind = int32 ) :: FNDNTH Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( Kind = int32 ), Dimension ( NORD ) :: XWRKT Integer ( Kind = int32 ) :: XWRK , XWRK1 ! Integer :: ICRS , IDCR , ILOW , NDON ! XWRKT ( 1 ) = XDONT ( 1 ) Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK End Do ! NDON = SIZE ( XDONT ) XWRK1 = XWRKT ( NORD ) ILOW = 2 * NORD - NDON Do ICRS = NORD + 1 , NDON If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) Do IDCR = NORD - 1 , MAX ( 1 , ILOW ) , - 1 If ( XWRK >= XWRKT ( IDCR )) Exit XWRKT ( IDCR + 1 ) = XWRKT ( IDCR ) End Do XWRKT ( IDCR + 1 ) = XWRK XWRK1 = XWRKT ( NORD ) End If ILOW = ILOW + 1 End Do FNDNTH = XWRK1 ! End Function int32_fndnth end module M_fndnth","tags":"","loc":"sourcefile/m_fndnth.f90.html"},{"title":"M_indnth.f90 – orderpack","text":"Contents Modules M_indnth Source Code M_indnth.f90 Source Code Module M_indnth use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: indnth interface indnth module procedure real64_indnth , real32_indnth , int32_indnth !, f_char_indnth end interface indnth contains !> !!##NAME !!    indnth(3f) - [orderpack:FRACTILE] Return INDEX of Nth value of !!                 array, i.e fractile of order N/SIZE(array) (QuickSort-like) !! !!##SYNOPSIS !! !!     Function ${KIND}_indnth (XDONT, NORD) Result (INDNTH) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer :: INDNTH !!       Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Return index of NORDth value of XDONT, i.e fractile of order !!    NORD/SIZE(XDONT). !! !!    This routine uses a pivoting strategy such as the one of finding the !!    median based on the quicksort algorithm, but we skew the pivot choice !!    to try to bring it to NORD as fast as possible. It uses 2 temporary !!    arrays, where it stores the indices of the values smaller than the !!    pivot (ILOWT), and the indices of values larger than the pivot that !!    we might still need later on (IHIGT). It iterates until it can bring !!    the number of values in ILOWT to exactly NORD, and then finds the !!    maximum of this set. !! !!##OPTIONS !!     XDONT      array to search !!     NORD       Nth value to search for !! !!##RETURNS !!     INDNTH     the index of XDONT that contains the requested value !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_indnth !!    ! find Nth lowest value in an array without sorting entire array !!    use M_indnth, only : indnth !!    implicit none !!    integer,allocatable :: iarr(:) !!    character(len=*),parameter :: list= '(*(g0:,\", \"))',sp='(*(g0,1x))' !!    integer :: i !!       iarr=[80,70,30,40,50,60,20,10,0,-100] !!       print list, 'ORIGINAL:',iarr !!       ! like minloc() and maxloc() !!       print sp,'minloc',indnth(iarr,1),minloc(iarr) !!       print sp,'maxloc',indnth(iarr,size(iarr)),maxloc(iarr) !!       ! but more general so can find location of the Nth lowest value ... !!       call printme(3) ! find location of Nth lowest value !!       call printme(1) !!       call printme(7) !!       ! sort the hard way, one value at a time !!       do i=1,size(iarr) !!          write(*,sp,advance='no') iarr(indnth(iarr,i)) !!       enddo !!       print * !!    contains !!    subroutine printme(n) !!    integer,intent(in) :: n !!    integer :: ii !!       ! !!       ii=indnth(iarr,n) !!       ! !!       print sp,'nord=',n,' index=',ii,' fractile=',iarr(ii) !!    end subroutine printme !!    end program demo_indnth !! !!   Results: !! !!    ORIGINAL:, 80, 70, 30, 40, 50, 60, 20, 10, 0, -100 !!    minloc 10 10 !!    maxloc 1 1 !!    nord= 3  index= 8  fractile= 10 !!    nord= 1  index= 10  fractile= -100 !!    nord= 7  index= 5  fractile= 50 !!    -100 0 10 20 30 40 50 60 70 80 !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !! !!    John Urban, 2022.04.16 !!    o added man-page and reduced to a template using the !!      prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Function real64_indnth ( XDONT , NORD ) Result ( INDNTH ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( In ) :: NORD Integer :: INDNTH ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( NORD ) :: IRNGT Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = NORD ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) INDNTH = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( 3 ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else IHIGT ( 3 ) = NDON End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) If ( INTH == 4 ) INDNTH = IHIGT ( 3 ) Return End If ! JLOW = 1 JHIG = 3 XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( 1 ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( 1 ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( 1 ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( 1 ) XMAX = XDONT ( ILOW ) Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = XDONT ( IWRK1 ) + 0.5 * ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! INDNTH = IHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK ILOW = ILOW + 1 End Do ! XWRK1 = XDONT ( IRNGT ( INTH )) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( INTH )) End If ILOW = ILOW + 1 End Do ! INDNTH = IRNGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( 1 )) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) ! !  One takes values > XPIV to IHIGT ! JHIG = 0 JLOW = 0 ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! IWRK1 = ILOWT ( 1 ) XWRK1 = XDONT ( IWRK1 ) Do ICRS = 1 + 1 , INTH IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) If ( XWRK > XWRK1 ) Then XWRK1 = XWRK IWRK1 = IWRK End If End Do INDNTH = IWRK1 Return ! ! End Function real64_indnth Function real32_indnth ( XDONT , NORD ) Result ( INDNTH ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( In ) :: NORD Integer :: INDNTH ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( NORD ) :: IRNGT Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = NORD ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) INDNTH = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( 3 ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else IHIGT ( 3 ) = NDON End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) If ( INTH == 4 ) INDNTH = IHIGT ( 3 ) Return End If ! JLOW = 1 JHIG = 3 XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( 1 ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( 1 ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( 1 ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( 1 ) XMAX = XDONT ( ILOW ) Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = XDONT ( IWRK1 ) + 0.5 * ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! INDNTH = IHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK ILOW = ILOW + 1 End Do ! XWRK1 = XDONT ( IRNGT ( INTH )) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( INTH )) End If ILOW = ILOW + 1 End Do ! INDNTH = IRNGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( 1 )) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) ! !  One takes values > XPIV to IHIGT ! JHIG = 0 JLOW = 0 ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! IWRK1 = ILOWT ( 1 ) XWRK1 = XDONT ( IWRK1 ) Do ICRS = 1 + 1 , INTH IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) If ( XWRK > XWRK1 ) Then XWRK1 = XWRK IWRK1 = IWRK End If End Do INDNTH = IWRK1 Return ! ! End Function real32_indnth Function int32_indnth ( XDONT , NORD ) Result ( INDNTH ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( In ) :: NORD Integer :: INDNTH ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XMIN , XMAX ! Integer , Dimension ( NORD ) :: IRNGT Integer , Dimension ( SIZE ( XDONT )) :: ILOWT , IHIGT Integer :: NDON , JHIG , JLOW , IHIG , IWRK , IWRK1 , IWRK2 , IWRK3 Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = NORD ! !    First loop is used to fill-in ILOWT, IHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) INDNTH = 1 Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then ILOWT ( 1 ) = 2 IHIGT ( 1 ) = 1 Else ILOWT ( 1 ) = 1 IHIGT ( 1 ) = 2 End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( 3 ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = 3 Else IHIGT ( 1 ) = 3 End If Else IHIGT ( 2 ) = 3 End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) Return End If ! If ( XDONT ( NDON ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 3 ) = IHIGT ( 2 ) IHIGT ( 2 ) = IHIGT ( 1 ) If ( XDONT ( NDON ) < XDONT ( ILOWT ( 1 ))) Then IHIGT ( 1 ) = ILOWT ( 1 ) ILOWT ( 1 ) = NDON Else IHIGT ( 1 ) = NDON End If Else IHIGT ( 3 ) = NDON End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) INDNTH = ILOWT ( 1 ) If ( INTH == 2 ) INDNTH = IHIGT ( 1 ) If ( INTH == 3 ) INDNTH = IHIGT ( 2 ) If ( INTH == 4 ) INDNTH = IHIGT ( 3 ) Return End If ! JLOW = 1 JHIG = 3 XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 3 )) - XDONT ( ILOWT ( 1 ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) Then XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 2 )) - XDONT ( ILOWT ( 1 ))) If ( XPIV >= XDONT ( IHIGT ( 1 ))) & XPIV = XDONT ( ILOWT ( 1 )) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XDONT ( IHIGT ( 1 )) - XDONT ( ILOWT ( 1 ))) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the IHIGT array as soon as we have more !  than enough values in ILOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ICRS Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 ILOWT ( JLOW ) = ICRS End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( IHIG ) IHIGT ( IHIG ) = IHIGT ( JHIG ) JHIG = JHIG - 1 Else ILOW = ILOWT ( 1 ) XMAX = XDONT ( ILOW ) Do ICRS = 2 , JLOW If ( XDONT ( ILOWT ( ICRS )) > XMAX ) Then IWRK = ILOWT ( ICRS ) XMAX = XDONT ( IWRK ) ILOWT ( ICRS ) = ILOW ILOW = IWRK End If End Do JLOW = JLOW - 1 End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XDONT ( IHIGT ( 1 )) <= XDONT ( IHIGT ( 2 ))) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 2 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( 3 ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( 3 ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 ILOWT ( ICRS ) = IHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! IWRK1 = IHIGT ( 1 ) IWRK2 = IHIGT ( 2 ) IWRK3 = IHIGT ( IFIN ) If ( XDONT ( IWRK2 ) < XDONT ( IWRK1 )) Then IHIGT ( 1 ) = IWRK2 IHIGT ( 2 ) = IWRK1 IWRK2 = IWRK1 End If If ( XDONT ( IWRK2 ) > XDONT ( IWRK3 )) Then IHIGT ( IFIN ) = IWRK2 IHIGT ( 2 ) = IWRK3 IWRK2 = IWRK3 If ( XDONT ( IWRK2 ) < XDONT ( IHIGT ( 1 ))) Then IHIGT ( 2 ) = IHIGT ( 1 ) IHIGT ( 1 ) = IWRK2 End If End If ! IWRK1 = IHIGT ( 1 ) JLOW = JLOW + 1 ILOWT ( JLOW ) = IWRK1 XPIV = XDONT ( IWRK1 ) + 0.5 * ( XDONT ( IHIGT ( IFIN )) - XDONT ( IWRK1 )) ! !  One takes values <= pivot to ILOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 IHIGT ( JHIG ) = IHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( IHIGT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = IHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XDONT ( IHIGT ( 1 )) IHIG = 1 Do ICRS = 2 , JHIG If ( XDONT ( IHIGT ( ICRS )) < XMIN ) Then XMIN = XDONT ( IHIGT ( ICRS )) IHIG = ICRS End If End Do ! INDNTH = IHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! IRNGT ( 1 ) = ILOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XDONT ( IRNGT ( IDCR ))) Then IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) Else Exit End If End Do IRNGT ( IDCR + 1 ) = IWRK ILOW = ILOW + 1 End Do ! XWRK1 = XDONT ( IRNGT ( INTH )) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XDONT ( ILOWT ( ICRS )) < XWRK1 ) Then XWRK = XDONT ( ILOWT ( ICRS )) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XDONT ( IRNGT ( IDCR ))) Exit IRNGT ( IDCR + 1 ) = IRNGT ( IDCR ) End Do IRNGT ( IDCR + 1 ) = ILOWT ( ICRS ) XWRK1 = XDONT ( IRNGT ( INTH )) End If ILOW = ILOW + 1 End Do ! INDNTH = IRNGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If If ( XDONT ( ILOWT ( IMIL )) > XDONT ( ILOWT ( IFIN ))) Then IWRK = ILOWT ( IFIN ) ILOWT ( IFIN ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK If ( XDONT ( ILOWT ( IMIL )) < XDONT ( ILOWT ( 1 ))) Then IWRK = ILOWT ( 1 ) ILOWT ( 1 ) = ILOWT ( IMIL ) ILOWT ( IMIL ) = IWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XDONT ( ILOWT ( 1 )) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XDONT ( ILOWT ( IFIN )) - XDONT ( ILOWT ( 1 ))) ! !  One takes values > XPIV to IHIGT ! JHIG = 0 JLOW = 0 ! If ( XDONT ( ILOWT ( IFIN )) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) > XPIV ) Then JHIG = JHIG + 1 IHIGT ( JHIG ) = ILOWT ( ICRS ) Else JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XDONT ( ILOWT ( ICRS )) <= XPIV ) Then JLOW = JLOW + 1 ILOWT ( JLOW ) = ILOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! IWRK1 = ILOWT ( 1 ) XWRK1 = XDONT ( IWRK1 ) Do ICRS = 1 + 1 , INTH IWRK = ILOWT ( ICRS ) XWRK = XDONT ( IWRK ) If ( XWRK > XWRK1 ) Then XWRK1 = XWRK IWRK1 = IWRK End If End Do INDNTH = IWRK1 Return ! ! End Function int32_indnth end module M_indnth","tags":"","loc":"sourcefile/m_indnth.f90.html"},{"title":"M_ctrper.f90 – orderpack","text":"Contents Modules M_ctrper Source Code M_ctrper.f90 Source Code Module M_ctrper use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 Use M_mrgrnk implicit none Private public :: ctrper private :: real64_ctrper , real32_ctrper , int32_ctrper interface ctrper module procedure real64_ctrper , real32_ctrper , int32_ctrper end interface ctrper contains !> !!##NAME !!    ctrper(3f) - [orderpack:PERMUTATION] generate a random permutation !!                 of an array leaving elements close to initial locations !! !!##SYNOPSIS !! !!     Subroutine ctrper (XDONT, PCLS) !! !!      ${TYPE} (kind=${KIND}), Intent (InOut) :: XDONT(:) !!      Real, Intent (In) :: PCLS !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!   Permute array XDONT randomly, but leaving elements close to their !!   initial locations (nearbyness is controlled by PCLS). !! !!   The routine creates a real array of the indices of XDONT() perturbed !!   by random values that are based on the size of PCLS. The new array is !!   then ranked and the resulting index is used to permute the input array. !! !!   The relative proportion of initial order and random order is defined !!   as 1-PCLS / PCLS, thus when PCLS = 0, there is no change in the order !!   whereas the new order is fully random when PCLS = 1. !! !!   Note this differs from adding random noise to the values. The original !!   values remain unchanged, their order is just perturbed. !! !!##OPTIONS !!     XDONT      Array of values to perturb. !!     PCLS       Proportion of closeness, constrained to the range 0.0(no !!                change) to 1.0(fully random). !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_ctrper !!    use M_ctrper, only : ctrper !!    implicit none !!    integer,allocatable :: xdont(:) !!    integer,allocatable :: xout(:,:) !!    real             :: pcls !!    integer          :: isz, i, j !!    isz=200 !!       if(allocated(xout))deallocate(xout) !!       allocate(xout(3,isz)) !! !!       xdont=[(i,i=1,isz)]*10 !!       call ctrper(xdont,0.0) !!       xout(1,:)=xdont !! !!       xdont=[(i,i=1,isz)]*10 !!       call ctrper(xdont,0.1) !!       xout(2,:)=xdont !! !!       xdont=[(i,i=1,isz)]*10 !!       call ctrper(xdont,1.0) !!       xout(3,:)=xdont !! !!       write(*,'(a)')'count    unchanged  perturbed  random' !!       do i=1,size(xdont) !!          write(*,'(*(i8,1x))')i,xout(:,i) !!       enddo !! !!    end program demo_ctrper !! !!   Results: !! !!    > count unchanged  perturbed  random !!    >     1       10       30     1930 !!    >     2       20       20     1430 !!    >     3       30      120      320 !!    >     4       40      110      670 !!    >     5       50       90      750 !!    >     6       60       60      790 !!    >     7       70      130     1850 !!    >     8       80       50      390 !!    >     9       90      150     1470 !!    >    10      100       80      710 !!    >    11      110       70      820 !!    >    12      120       10      680 !!    >    .       .         .       . !!    >    .       .         .       . !!    >    .       .         .       . !!    >    .       .         .       . !!    >   190     1900     1860     1210 !!    >   191     1910     1890      580 !!    >   192     1920     1840      600 !!    >   193     1930     1870     1640 !!    >   194     1940     1920      290 !!    >   195     1950     2000     1180 !!    >   196     1960     1910      340 !!    >   197     1970     1990     1540 !!    >   198     1980     1940      990 !!    >   199     1990     1950      470 !!    >   200     2000     1980      200 !! !!##AUTHOR !!     Michel Olagnon, 2000-2012 !! !!     John Urban, 2022.04.16 !!         o added man-page and reduced to a template using the !!           prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_ctrper ( XDONT , PCLS ) ! _________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: XDONT Real , Intent ( In ) :: PCLS ! __________________________________________________________ ! Real , Dimension ( Size ( XDONT )) :: XINDT Integer , Dimension ( Size ( XDONT )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , PCLS ), 1.0 ) XINDT = Real ( Size ( XDONT )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( XDONT )) ] Call MRGRNK ( XINDT , JWRKT ) XDONT = XDONT ( JWRKT ) ! End Subroutine real64_ctrper Subroutine real32_ctrper ( XDONT , PCLS ) ! _________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: XDONT Real , Intent ( In ) :: PCLS ! __________________________________________________________ ! Real , Dimension ( Size ( XDONT )) :: XINDT Integer , Dimension ( Size ( XDONT )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , PCLS ), 1.0 ) XINDT = Real ( Size ( XDONT )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( XDONT )) ] Call MRGRNK ( XINDT , JWRKT ) XDONT = XDONT ( JWRKT ) ! End Subroutine real32_ctrper Subroutine int32_ctrper ( XDONT , PCLS ) ! _________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: XDONT Real , Intent ( In ) :: PCLS ! __________________________________________________________ ! Real , Dimension ( Size ( XDONT )) :: XINDT Integer , Dimension ( Size ( XDONT )) :: JWRKT Real :: PWRK Integer :: I ! Call Random_Number ( XINDT (:)) PWRK = Min ( Max ( 0.0 , PCLS ), 1.0 ) XINDT = Real ( Size ( XDONT )) * XINDT XINDT = PWRK * XINDT + ( 1.0 - PWRK ) * [ ( Real ( I ), I = 1 , size ( XDONT )) ] Call MRGRNK ( XINDT , JWRKT ) XDONT = XDONT ( JWRKT ) ! End Subroutine int32_ctrper end module M_ctrper","tags":"","loc":"sourcefile/m_ctrper.f90.html"},{"title":"M_uniinv.f90 – orderpack","text":"Contents Modules M_uniinv Source Code M_uniinv.f90 Source Code Module M_uniinv use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: uniinv interface uniinv module procedure real64_uniinv , real32_uniinv , int32_uniinv , f_char_uniinv end interface uniinv interface nearless module procedure real64_nearless , real32_nearless , int32_nearless , f_char_nearless end interface nearless contains !> !!##NAME !!    uniinv(3f) - [orderpack:RANK_UNIQUE] a merge-sort inverse ranking of !!    an array, with duplicate entries assigned the same rank. !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_uniinv (XDONT, IGOEST) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer, Dimension (:), Intent (Out) :: IGOEST !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !! !!    UNIINV(3f) is a merge-sort inverse ranking of an array, but with !!    duplicate entries receiving the same rank. !! !!    The routine is similar to pure merge-sort ranking, but on the last !!    pass, it sets indices in IGOEST to the rank of the value in the ordered !!    set with duplicates ignored.  For performance reasons, the first 2 !!    passes are taken out of the standard loop, and use dedicated coding. !! !!##OPTIONS !!     XDONT      array to rank !!     IGOEST     returned rank array !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_uniinv !!    use M_uniinv, only : uniinv !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: xdont(:) !!    character(len=20),allocatable :: strings(:) !!    integer,allocatable :: cindx(:) !!       ! all values unique !!       xdont=[0,11,22,33,44,55,66,77,88,99] !!       xdont=xdont(size(xdont):1:-1) ! reverse it !!       call printme() !!       ! duplicate values !!       xdont=[-1.0, 0.0, -1.0, 0.0, -1.0, 0.0, -1.0] !!       call printme() !!       xdont=[10.0, 5.0, 7.0, 1.0, 4.0, 5.0, 6.0, 8.0, 9.0, 10.0, 1.0] !!       call printme() !!       xdont=[10.0,20.0,30.0,10.0,20.0,30.0,10.0,20.0,30.0] !!       call printme() !! !!       strings= [ character(len=20) ::                             & !!       & 'red',    'green', 'blue', 'yellow', 'orange',   'black'] !!       call printme_char() !!       strings= [ character(len=20) ::                             & !!       & 'white',  'brown', 'gray', 'cyan',   'magenta',           & !!       & 'white',  'brown', 'gray', 'cyan',   'magenta',           & !!       & 'brown',  'brown', 'gray', 'green',  'magenta'] !!       call printme_char() !!       strings=['purple', 'purple', 'purple', 'purple'] !!       call printme_char() !!    contains !! !!    subroutine printme_char() !!    integer,allocatable :: igoest(:) !!    character(len=20),allocatable :: out(:) !!    integer :: imx !!    integer :: i !!    integer :: isz !!       isz=size(strings) !!       write(*,g)'Original:                 ',(trim(strings(i)),i=1,isz) !!       write(*,g)'Number of indices to sort:',isz !!       if(allocated(igoest))deallocate(igoest) !!       allocate(igoest(size(strings))) !!       call uniinv(strings,igoest) !!       imx=maxval(igoest) !!       write(*,g)'Returned Indices:         ',igoest(:) !!       write(*,g)'Number of unique indices :',imx !!       if(allocated(out))deallocate(out) !!       allocate(out(imx)) !!       do i=1,size(strings) !!          out(igoest(i))=strings(i) !!       enddo !!       write(*,g)'Sorted unique values:     ',(trim(out(i)),i=1,size(out)) !!       write(*,g) !!    end subroutine printme_char !! !!    subroutine printme() !!    integer,allocatable :: igoest(:) !!    integer,allocatable :: out(:) !!    integer :: imx !!    integer :: i !!       write(*,g)'Original:                 ',xdont !!       write(*,g)'Number of indices to sort:',size(xdont) !!       if(allocated(igoest))deallocate(igoest) !!       allocate(igoest(size(xdont))) !!       call uniinv(xdont,igoest) !!       imx=maxval(igoest) !!       write(*,g)'Returned Indices:         ',igoest(:) !!       write(*,g)'Number of unique indices :',imx !!       if(allocated(out))deallocate(out) !!       allocate(out(imx)) !!       do i=1,size(xdont) !!          out(igoest(i))=xdont(i) !!       enddo !!       write(*,g)'Sorted unique values:     ',out !!       write(*,g) !!    end subroutine printme !! !!    end program demo_uniinv !! !!   Results: !! !!    Original:                  99 88 77 66 55 44 33 22 11 0 !!    Number of indices to sort: 10 !!    Returned Indices:          10 9 8 7 6 5 4 3 2 1 !!    Number of unique indices : 10 !!    Sorted unique values:      0 11 22 33 44 55 66 77 88 99 !! !!    Original:                  -1 0 -1 0 -1 0 -1 !!    Number of indices to sort: 7 !!    Returned Indices:          1 2 1 2 1 2 1 !!    Number of unique indices : 2 !!    Sorted unique values:      -1 0 !! !!    Original:                  10 5 7 1 4 5 6 8 9 10 1 !!    Number of indices to sort: 11 !!    Returned Indices:          8 3 5 1 2 3 4 6 7 8 1 !!    Number of unique indices : 8 !!    Sorted unique values:      1 4 5 6 7 8 9 10 !! !!    Original:                  10 20 30 10 20 30 10 20 30 !!    Number of indices to sort: 9 !!    Returned Indices:          1 2 3 1 2 3 1 2 3 !!    Number of unique indices : 3 !!    Sorted unique values:      10 20 30 !! !!    Original:                  red green blue yellow orange black !!    Number of indices to sort: 6 !!    Returned Indices:          5 3 2 6 4 1 !!    Number of unique indices : 6 !!    Sorted unique values:      black blue green orange red yellow !! !!    Original:                  white brown gray cyan magenta white brown !!                        gray cyan magenta brown brown gray green magenta !!    Number of indices to sort: 15 !!    Returned Indices:          6 1 3 2 5 6 1 3 2 5 1 1 3 4 5 !!    Number of unique indices : 6 !!    Sorted unique values:      brown cyan gray green magenta white !! !!    Original:                  purple purple purple purple !!    Number of indices to sort: 4 !!    Returned Indices:          1 1 1 1 !!    Number of unique indices : 1 !!    Sorted unique values:      purple !! !!##AUTHOR !!     Michel Olagnon, 2000-2012 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_uniinv ( XDONT , IGOEST ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ Real ( kind = real64 ) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) < XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = XDONT ( JWRKT ( IINDA )) XDONB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XDONT ( JWRKT ( 1 )), XDONT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XDONT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XDONT ( JWRKT ( IINDA )) > XDONT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XDONT ( IRNG ) > XTST ) Then XTST = XDONT ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! End Subroutine real64_uniinv Function real64_nearless ( XVAL ) result ( real64_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real64 ), Intent ( In ) :: XVAL Real ( kind = real64 ) :: real64_nl ! __________________________________________________________ real64_nl = nearest ( XVAL , - 1.0_real64 ) ! End Function real64_nearless Subroutine real32_uniinv ( XDONT , IGOEST ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ Real ( kind = real32 ) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) < XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = XDONT ( JWRKT ( IINDA )) XDONB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XDONT ( JWRKT ( 1 )), XDONT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XDONT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XDONT ( JWRKT ( IINDA )) > XDONT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XDONT ( IRNG ) > XTST ) Then XTST = XDONT ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! End Subroutine real32_uniinv Function real32_nearless ( XVAL ) result ( real32_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real32 ), Intent ( In ) :: XVAL Real ( kind = real32 ) :: real32_nl ! __________________________________________________________ real32_nl = nearest ( XVAL , - 1.0_real32 ) ! End Function real32_nearless Subroutine int32_uniinv ( XDONT , IGOEST ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ Integer ( kind = int32 ) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) < XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = XDONT ( JWRKT ( IINDA )) XDONB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XDONT ( JWRKT ( 1 )), XDONT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XDONT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XDONT ( JWRKT ( IINDA )) > XDONT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XDONT ( IRNG ) > XTST ) Then XTST = XDONT ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! End Subroutine int32_uniinv Function int32_nearless ( XVAL ) result ( int32_nl ) !! Nearest value less than given value ! __________________________________________________________ Integer ( kind = int32 ), Intent ( In ) :: XVAL Integer ( kind = int32 ) :: int32_nl ! __________________________________________________________ int32_nl = XVAL - 1_int32 ! End Function int32_nearless Subroutine f_char_uniinv ( XDONT , IGOEST ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IGOEST ! __________________________________________________________ character ( kind = f_char , len = len ( XDONT )) :: XTST , XDONA , XDONB ! ! __________________________________________________________ Integer , Dimension ( SIZE ( IGOEST )) :: JWRKT , IRNGT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 , NUNI Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB ! NVAL = Min ( SIZE ( XDONT ), SIZE ( IGOEST )) ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IGOEST ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XDONT ( IIND - 1 ) < XDONT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XDONT ( IRNGT ( IWRKD + 2 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XDONT ( IRNGT ( IWRKD + 1 )) <= XDONT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XDONT ( IRNG1 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XDONT ( IRNG2 ) <= XDONT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XDONA = XDONT ( JWRKT ( IINDA )) XDONB = XDONT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XDONA > XDONB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XDONB = XDONT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XDONA = XDONT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XDONT ( JWRKT ( 1 )), XDONT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XDONT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XDONT ( JWRKT ( IINDA )) > XDONT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XDONT ( IRNG ) > XTST ) Then XTST = XDONT ( IRNG ) NUNI = NUNI + 1 End If IGOEST ( IRNG ) = NUNI ! End Do ! IGOEST = IGOEST + 1 ! End Subroutine f_char_uniinv Function f_char_nearless ( XVAL ) result ( f_char_nl ) !! Nearest value less than given value ! __________________________________________________________ character ( kind = f_char , len =* ), Intent ( In ) :: XVAL character ( kind = f_char , len = len ( XVAL )) :: f_char_nl ! __________________________________________________________ f_char_nl = XVAL ! End Function f_char_nearless end module M_uniinv","tags":"","loc":"sourcefile/m_uniinv.f90.html"},{"title":"M_refsor.f90 – orderpack","text":"Contents Modules M_refsor Source Code M_refsor.f90 Source Code Module M_refsor use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: refsor private :: real64_inssor , real32_inssor , int32_inssor , f_char_inssor private :: real64_subsor , real32_subsor , int32_subsor , f_char_subsor interface refsor module procedure real64_refsor , real32_refsor , int32_refsor , f_char_refsor end interface refsor contains !> !!##NAME !!    refsor(3f) - [orderpack:SORT] Sorts array into ascending order !!                 (Quicksort) !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_refsor (XDONT) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (InOut) :: XDONT !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Sorts XDONT into ascending order using the Quicksort method !! !!    Quicksort chooses a \"pivot\" in the set, and explores the array from !!    both ends, looking for a value > pivot with the increasing index, !!    for a value <= pivot with the decreasing index, and swapping them !!    when it has found one of each.  The array is then subdivided in 2 !!    ([3]) subsets: !! !!        { values <= pivot} {pivot} {values > pivot} !! !!    One then call recursively the program to sort each subset. !!    When the size of the subarray is small enough, one uses an !!    insertion sort that is faster for very small sets. !! !!##OPTIONS !!     XDONT      array to sort !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_refsor !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_refsor, only : refsor !!    implicit none !!    ! an insertion sort is very efficient for very small arrays !!    ! but generally slower than methods like quicksort and mergesort. !!    real(kind=real32) :: valsr(2000) !!    real(kind=real64) :: valsd(2000) !!    integer           :: valsi(2000) !!    integer           :: i !!       call random_seed() !!       call random_number(valsr) !!       call random_number(valsd) !!       valsi=int(valsr*1000000.0) !!       valsr=valsr*1000000.0-500000.0 !!       valsd=valsd*1000000.0-500000.0 !!       call refsor(valsi) !!       do i=1,size(valsi)-1 !!          if (valsi(i+1).lt.valsi(i))then !!             write(*,*)'not sorted' !!             stop 1 !!          endif !!       enddo !!       call refsor(valsr) !!       do i=1,size(valsr)-1 !!          if (valsr(i+1).lt.valsr(i))then !!             write(*,*)'not sorted' !!             stop 2 !!          endif !!       enddo !!       call refsor(valsd) !!       do i=1,size(valsd)-1 !!          if (valsd(i+1).lt.valsd(i))then !!             write(*,*)'not sorted' !!             stop 3 !!          endif !!       enddo !!       write(*,*)'random arrays are now sorted' !!    end program demo_refsor !! !!   Results: !! !!##AUTHOR !!     Michel Olagnon - Apr. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_refsor ( XDONT ) ! __________________________________________________________ Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Call real64_subsor ( XDONT , 1 , Size ( XDONT )) Call real64_inssor ( XDONT ) End Subroutine real64_refsor Recursive Subroutine real64_subsor ( XDONT , IDEB1 , IFIN1 ) !  Sorts XDONT from IDEB1 to IFIN1 ! __________________________________________________________ Real ( kind = real64 ), dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If If ( XDONT ( IMIL ) > XDONT ( IFIN )) Then XWRK = XDONT ( IFIN ) XDONT ( IFIN ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If End If XPIV = XDONT ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IFIN) > XPIV ! Exit ECH2 ! End If If ( XDONT ( ICRS ) > XPIV ) Exit End Do Do If ( XDONT ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = XDONT ( IDCR ) XDONT ( IDCR ) = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call real64_subsor ( XDONT , IDEB1 , ICRS - 1 ) Call real64_subsor ( XDONT , IDCR , IFIN1 ) End If End Subroutine real64_subsor Subroutine real64_inssor ( XDONT ) !  Sorts XDONT into increasing order (Insertion sort) ! __________________________________________________________ Real ( kind = real64 ), dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Integer :: ICRS , IDCR Real ( kind = real64 ) :: XWRK ! Do ICRS = 2 , Size ( XDONT ) XWRK = XDONT ( ICRS ) If ( XWRK >= XDONT ( ICRS - 1 )) Cycle XDONT ( ICRS ) = XDONT ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! End Subroutine real64_inssor Subroutine real32_refsor ( XDONT ) ! __________________________________________________________ Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Call real32_subsor ( XDONT , 1 , Size ( XDONT )) Call real32_inssor ( XDONT ) End Subroutine real32_refsor Recursive Subroutine real32_subsor ( XDONT , IDEB1 , IFIN1 ) !  Sorts XDONT from IDEB1 to IFIN1 ! __________________________________________________________ Real ( kind = real32 ), dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If If ( XDONT ( IMIL ) > XDONT ( IFIN )) Then XWRK = XDONT ( IFIN ) XDONT ( IFIN ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If End If XPIV = XDONT ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IFIN) > XPIV ! Exit ECH2 ! End If If ( XDONT ( ICRS ) > XPIV ) Exit End Do Do If ( XDONT ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = XDONT ( IDCR ) XDONT ( IDCR ) = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call real32_subsor ( XDONT , IDEB1 , ICRS - 1 ) Call real32_subsor ( XDONT , IDCR , IFIN1 ) End If End Subroutine real32_subsor Subroutine real32_inssor ( XDONT ) !  Sorts XDONT into increasing order (Insertion sort) ! __________________________________________________________ Real ( kind = real32 ), dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Integer :: ICRS , IDCR Real ( kind = real32 ) :: XWRK ! Do ICRS = 2 , Size ( XDONT ) XWRK = XDONT ( ICRS ) If ( XWRK >= XDONT ( ICRS - 1 )) Cycle XDONT ( ICRS ) = XDONT ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! End Subroutine real32_inssor Subroutine int32_refsor ( XDONT ) ! __________________________________________________________ Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Call int32_subsor ( XDONT , 1 , Size ( XDONT )) Call int32_inssor ( XDONT ) End Subroutine int32_refsor Recursive Subroutine int32_subsor ( XDONT , IDEB1 , IFIN1 ) !  Sorts XDONT from IDEB1 to IFIN1 ! __________________________________________________________ Integer ( kind = int32 ), dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If If ( XDONT ( IMIL ) > XDONT ( IFIN )) Then XWRK = XDONT ( IFIN ) XDONT ( IFIN ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If End If XPIV = XDONT ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IFIN) > XPIV ! Exit ECH2 ! End If If ( XDONT ( ICRS ) > XPIV ) Exit End Do Do If ( XDONT ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = XDONT ( IDCR ) XDONT ( IDCR ) = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call int32_subsor ( XDONT , IDEB1 , ICRS - 1 ) Call int32_subsor ( XDONT , IDCR , IFIN1 ) End If End Subroutine int32_subsor Subroutine int32_inssor ( XDONT ) !  Sorts XDONT into increasing order (Insertion sort) ! __________________________________________________________ Integer ( kind = int32 ), dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Integer :: ICRS , IDCR Integer ( kind = int32 ) :: XWRK ! Do ICRS = 2 , Size ( XDONT ) XWRK = XDONT ( ICRS ) If ( XWRK >= XDONT ( ICRS - 1 )) Cycle XDONT ( ICRS ) = XDONT ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! End Subroutine int32_inssor Subroutine f_char_refsor ( XDONT ) ! __________________________________________________________ character ( kind = f_char , len =* ), Dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Call f_char_subsor ( XDONT , 1 , Size ( XDONT )) Call f_char_inssor ( XDONT ) End Subroutine f_char_refsor Recursive Subroutine f_char_subsor ( XDONT , IDEB1 , IFIN1 ) !  Sorts XDONT from IDEB1 to IFIN1 ! __________________________________________________________ character ( kind = f_char , len =* ), dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: IDEB1 , IFIN1 ! __________________________________________________________ character ( kind = f_char , len = len ( XDONT )) :: XPIV , XWRK Integer , Parameter :: NINS = 16 ! Max for insertion sort Integer :: ICRS , IDEB , IDCR , IFIN , IMIL ! IDEB = IDEB1 IFIN = IFIN1 ! !  If we don't have enough values to make it worth while, we leave !  them unsorted, and the final insertion sort will take care of them ! If (( IFIN - IDEB ) > NINS ) Then IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If If ( XDONT ( IMIL ) > XDONT ( IFIN )) Then XWRK = XDONT ( IFIN ) XDONT ( IFIN ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK If ( XDONT ( IMIL ) < XDONT ( IDEB )) Then XWRK = XDONT ( IDEB ) XDONT ( IDEB ) = XDONT ( IMIL ) XDONT ( IMIL ) = XWRK End If End If XPIV = XDONT ( IMIL ) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IDCR !  the last   <= pivot is ICRS-1 !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IFIN) > XPIV ! Exit ECH2 ! End If If ( XDONT ( ICRS ) > XPIV ) Exit End Do Do If ( XDONT ( IDCR ) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always ICRS-1 ! Exit ECH2 End If End Do ! XWRK = XDONT ( IDCR ) XDONT ( IDCR ) = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK End Do ECH2 ! !  One now sorts each of the two sub-intervals ! Call f_char_subsor ( XDONT , IDEB1 , ICRS - 1 ) Call f_char_subsor ( XDONT , IDCR , IFIN1 ) End If End Subroutine f_char_subsor Subroutine f_char_inssor ( XDONT ) !  Sorts XDONT into increasing order (Insertion sort) ! __________________________________________________________ character ( kind = f_char , len =* ), dimension (:), Intent ( InOut ) :: XDONT ! __________________________________________________________ Integer :: ICRS , IDCR character ( kind = f_char , len = len ( XDONT )) :: XWRK ! Do ICRS = 2 , Size ( XDONT ) XWRK = XDONT ( ICRS ) If ( XWRK >= XDONT ( ICRS - 1 )) Cycle XDONT ( ICRS ) = XDONT ( ICRS - 1 ) Do IDCR = ICRS - 2 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! End Subroutine f_char_inssor end module M_refsor","tags":"","loc":"sourcefile/m_refsor.f90.html"},{"title":"M_inspar.f90 – orderpack","text":"Contents Modules M_inspar Source Code M_inspar.f90 Source Code Module M_inspar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: inspar private :: real64_inspar , real32_inspar , int32_inspar interface inspar module procedure real64_inspar , real32_inspar , int32_inspar end interface inspar contains !> !!##NAME !!    inspar(3f) - [orderpack:PARTIAL_SORT] partially sorts an array, !!                 bringing the N lowest values to the beginning of the array !! !!##SYNOPSIS !! !! !!     Subroutine inspar (XDONT, NORD) !!      ${TYPE} (kind=${KIND}), Dimension (:), Intent (InOut) :: XDONT !!      Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    INSPAR partially sorts XDONT, bringing the NORD lowest values to the !!    beginning of the array. !! !!    This subroutine uses an insertion sort, limiting insertion to the !!    first NORD values. It does not use any work array and is faster when !!    NORD is very small (2-5), but worst case behavior can happen fairly !!    probably (initially inverse sorted). Therefore, in many cases, the !!    refined quicksort method is faster. !! !!##OPTIONS !!     XDONT      The array to partially sort !!     NORD       number of sorted values to return. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_inspar !!    use M_inspar, only : inspar !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: xdont(:) !!    integer :: nord !!    xdont=[10,5,7,1,4,5,6,8,9,10,1] !!    nord=5 !!       write(*,g)'ORIGINAL:',xdont !!       call inspar(xdont,nord) !!       write(*,g)'NUMBER OF INDICES TO SORT:',nord !!       write(*,g)nord,'LOWEST VALUES:',xdont(:nord) !!       write(*,g)'ENTIRE ARRAY:',xdont !!    end program demo_inspar !! !!   Results: !! !!    ORIGINAL: 10 5 7 1 4 5 6 8 9 10 1 !!    NUMBER OF INDICES TO SORT: 5 !!    5 LOWEST VALUES: 1 1 4 5 5 !!    ENTIRE ARRAY: 1 1 4 5 5 10 7 8 9 10 6 !! !!##AUTHOR !!     Michel Olagnon - Feb. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_inspar ( XDONT , NORD ) Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! XWRK1 = XDONT ( NORD ) Do ICRS = NORD + 1 , SIZE ( XDONT ) If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK XWRK1 = XDONT ( NORD ) End If End Do ! End Subroutine real64_inspar Subroutine real32_inspar ( XDONT , NORD ) Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! XWRK1 = XDONT ( NORD ) Do ICRS = NORD + 1 , SIZE ( XDONT ) If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK XWRK1 = XDONT ( NORD ) End If End Do ! End Subroutine real32_inspar Subroutine int32_inspar ( XDONT , NORD ) Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XWRK , XWRK1 Integer :: ICRS , IDCR ! Do ICRS = 2 , NORD XWRK = XDONT ( ICRS ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK End Do ! XWRK1 = XDONT ( NORD ) Do ICRS = NORD + 1 , SIZE ( XDONT ) If ( XDONT ( ICRS ) < XWRK1 ) Then XWRK = XDONT ( ICRS ) XDONT ( ICRS ) = XWRK1 Do IDCR = NORD - 1 , 1 , - 1 If ( XWRK >= XDONT ( IDCR )) Exit XDONT ( IDCR + 1 ) = XDONT ( IDCR ) End Do XDONT ( IDCR + 1 ) = XWRK XWRK1 = XDONT ( NORD ) End If End Do ! End Subroutine int32_inspar end module M_inspar","tags":"","loc":"sourcefile/m_inspar.f90.html"},{"title":"M_refpar.f90 – orderpack","text":"Contents Modules M_refpar Source Code M_refpar.f90 Source Code Module M_refpar use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: refpar interface refpar module procedure real64_refpar , real32_refpar , int32_refpar end interface refpar contains !> !!##NAME !!    refpar(3f) - [orderpack:PARTIAL_RANK] partially ranks any array up !!                 to specified number of elements !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_refpar (XDONT, IRNGT, NORD) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer, Dimension (:), Intent (Out) :: IRNGT !!       Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    Ranks partially XDONT by IRNGT, up to order NORD !! !!    This routine uses a pivoting strategy such as the one used in !!    finding the median based on the quicksort algorithm. It uses !!    a temporary array, where it stores the partially ranked indices !!    of the values. It iterates until it can bring the number of !!    values lower than the pivot to exactly NORD, and then uses an !!    insertion sort to rank this set, since it is supposedly small. !! !!##OPTIONS !!     XDONT      array to partially rank !!     IRNGT      array to hold indices of ranked elements !!     NORD       number of elements to rank !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_refpar !!    use,intrinsic :: iso_fortran_env, only : int32, real32, real64 !!    use M_refpar, only : refpar !!    implicit none !!    real(kind=real32) :: valsr(2000) !!    integer           :: indx(2000) !!    integer           :: i !!       call random_seed() !!       call random_number(valsr) !!       valsr=valsr*1000000.0-500000.0 !!       call refpar(valsr,indx,300) !!       valsr(:300)=valsr(indx(:300)) !!       do i=1,300-1 !!          if (valsr(i+1).lt.valsr(i))then !!             write(*,*)'not sorted' !!             stop 1 !!          endif !!       enddo !!       write(*,*)'random array now sorted' !!    end program demo_refpar !! !!   Results: !! !!##AUTHOR !!     Michel Olagnon - Feb. 2000 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_refpar ( XDONT , IRNGT , NORD ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real64 ) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( XDONT )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( XDONT ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IWRKT ( IMIL )) < XDONT ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( XDONT ( IWRKT ( IMIL )) > XDONT ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( XDONT ( IWRKT ( IMIL )) < XDONT ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = XDONT ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( XDONT ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( XDONT ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= XDONT ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine real64_refpar Subroutine real32_refpar ( XDONT , IRNGT , NORD ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( kind = real32 ) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( XDONT )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( XDONT ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IWRKT ( IMIL )) < XDONT ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( XDONT ( IWRKT ( IMIL )) > XDONT ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( XDONT ( IWRKT ( IMIL )) < XDONT ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = XDONT ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( XDONT ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( XDONT ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= XDONT ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine real32_refpar Subroutine int32_refpar ( XDONT , IRNGT , NORD ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( kind = int32 ) :: XPIV , XWRK ! __________________________________________________________ ! Integer , Dimension ( SIZE ( XDONT )) :: IWRKT Integer :: NDON , ICRS , IDEB , IDCR , IFIN , IMIL , IWRK ! NDON = SIZE ( XDONT ) ! Do ICRS = 1 , NDON IWRKT ( ICRS ) = ICRS End Do IDEB = 1 IFIN = NDON Do If ( IDEB >= IFIN ) Exit IMIL = ( IDEB + IFIN ) / 2 ! !  One chooses a pivot, median of 1st, last, and middle values ! If ( XDONT ( IWRKT ( IMIL )) < XDONT ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If If ( XDONT ( IWRKT ( IMIL )) > XDONT ( IWRKT ( IFIN ))) Then IWRK = IWRKT ( IFIN ) IWRKT ( IFIN ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK If ( XDONT ( IWRKT ( IMIL )) < XDONT ( IWRKT ( IDEB ))) Then IWRK = IWRKT ( IDEB ) IWRKT ( IDEB ) = IWRKT ( IMIL ) IWRKT ( IMIL ) = IWRK End If End If If (( IFIN - IDEB ) < 3 ) Exit XPIV = XDONT ( IWRKT ( IMIL )) ! !  One exchanges values to put those > pivot in the end and !  those <= pivot at the beginning ! ICRS = IDEB IDCR = IFIN ECH2 : Do Do ICRS = ICRS + 1 If ( ICRS >= IDCR ) Then ! !  the first  >  pivot is IWRKT(IDCR) !  the last   <= pivot is IWRKT(ICRS-1) !  Note: If one arrives here on the first iteration, then !        the pivot is the maximum of the set, the last value is equal !        to it, and one can reduce by one the size of the set to process, !        as if XDONT (IWRKT(IFIN)) > XPIV ! Exit ECH2 ! End If If ( XDONT ( IWRKT ( ICRS )) > XPIV ) Exit End Do Do If ( XDONT ( IWRKT ( IDCR )) <= XPIV ) Exit IDCR = IDCR - 1 If ( ICRS >= IDCR ) Then ! !  The last value < pivot is always IWRKT(ICRS-1) ! Exit ECH2 End If End Do ! IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( ICRS ) IWRKT ( ICRS ) = IWRK End Do ECH2 ! !  One restricts further processing to find the fractile value ! If ( ICRS <= NORD ) IDEB = ICRS If ( ICRS > NORD ) IFIN = ICRS - 1 End Do ! !  Now, we only need to complete ranking of the 1:NORD set !  Assuming NORD is small, we use a simple insertion sort ! Do ICRS = 2 , NORD IWRK = IWRKT ( ICRS ) XWRK = XDONT ( IWRK ) Do IDCR = ICRS - 1 , 1 , - 1 If ( XWRK <= XDONT ( IWRKT ( IDCR ))) Then IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) Else Exit End If End Do IWRKT ( IDCR + 1 ) = IWRK End Do IRNGT ( 1 : NORD ) = IWRKT ( 1 : NORD ) Return ! End Subroutine int32_refpar end module M_refpar","tags":"","loc":"sourcefile/m_refpar.f90.html"},{"title":"M_valnth.f90 – orderpack","text":"Contents Modules M_valnth Source Code M_valnth.f90 Source Code Module M_valnth use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) Private public :: valnth interface valnth module procedure real64_valnth , real32_valnth , int32_valnth !, f_char_valnth end interface valnth contains !> !!##NAME !!    valnth(3f) - [orderpack:FRACTILE] Return VALUE of Nth value of !!                 array, i.e fractile of order N/SIZE(array) (QuickSort-like) !! !!##SYNOPSIS !! !!     Function ${KIND}_valnth (XDONT, NORD) Result (valnth) !! !!      ${TYPE} (Kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!      ${TYPE} (Kind=${KIND}) :: valnth !!      Integer, Intent (In) :: NORD !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!   Return NORDth value of XDONT, i.e fractile of order NORD/SIZE(XDONT). !! !!   This routine uses a pivoting strategy such as the one of finding the !!   median based on the quicksort algorithm, but we skew the pivot choice !!   to try to bring it to NORD as fast as possible. It uses 2 temporary !!   arrays, where it stores the indices of the values smaller than the !!   pivot (ILOWT), and the indices of values larger than the pivot that we !!   might still need later on (IHIGT). It iterates until it can bring the !!   number of values in ILOWT to exactly NORD, and then finds the maximum !!   of this set. !! !!##OPTIONS !!     XDONT    array to search !!     NORD     Nth lowest value to find !!##RETURNS !!     VALNTH   Nth lowest value !!##EXAMPLES !! !!   Sample program: !! !!    program demo_valnth !!    use M_valnth, only : valnth !!    implicit none !!    character(len=*),parameter :: list= '(*(g0:,\", \"))' !!    character(len=*),parameter :: sp='(*(g0,1x))' !!    real,parameter ::  xdont(*)=[1.1,20.20,3.3,10.10,5.5,4.4,2.2] !!    integer :: i !!    integer :: imiddle !!       write(*,list) 'ORIGINAL:',xdont !!       ! can return the same values as intrinsics minval() and maxval() !!       print sp, 'minval',valnth(xdont,1),          minval(xdont) !!       print sp, 'maxval',valnth(xdont,size(xdont)), maxval(xdont) !!       ! but more generally it can return the Nth lowest value. !!       print sp,'nord=',4, ' fractile=',valnth(xdont,4) !!       ! so a value at the middle would be !!       imiddle=(size(xdont)+1)/2 !!       print sp,'median=',valnth(xdont,imiddle) !!       ! sorting the hard way !!       do i=1,size(xdont) !!          write(*,list)i,valnth(xdont,i) !!       enddo !!    end program demo_valnth !! !!   Results: !! !!    ORIGINAL:, 1.1000, 20.200, 3.300, 10.100, 5.500, 4.400, 2.200 !!    minval 1.100 1.100 !!    maxval 20.200 20.200 !!    nord= 4  fractile= 4.400 !!    median= 4.400 !!    1, 1.100 !!    2, 2.200 !!    3, 3.300 !!    4, 4.400 !!    5, 5.500 !!    6, 10.100 !!    7, 20.200 !! !!##AUTHOR !!    Michel Olagnon - Aug. 2000 !! !!    John Urban, 2022.04.16 !!    o added man-page and reduced to a template using the !!      prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Function real64_valnth ( XDONT , NORD ) Result ( valnth ) ! __________________________________________________________ Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Real ( Kind = real64 ) :: valnth Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( Kind = real64 ), Dimension ( SIZE ( XDONT )) :: XLOWT , XHIGT Real ( Kind = real64 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX ! Integer :: NDON , JHIG , JLOW , IHIG Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = MAX ( MIN ( NORD , NDON ), 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) VALNTH = XDONT ( 1 ) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then XLOWT ( 1 ) = XDONT ( 2 ) XHIGT ( 1 ) = XDONT ( 1 ) Else XLOWT ( 1 ) = XDONT ( 1 ) XHIGT ( 1 ) = XDONT ( 2 ) End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) VALNTH = XLOWT ( 1 ) If ( INTH == 2 ) VALNTH = XHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( 3 ) Else XHIGT ( 1 ) = XDONT ( 3 ) End If Else XHIGT ( 2 ) = XDONT ( 3 ) End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! If ( XDONT ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( NDON ) Else XHIGT ( 1 ) = XDONT ( NDON ) End If Else XHIGT ( 3 ) = XDONT ( NDON ) End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * ( XHIGT ( 3 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 2 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) & XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 1 ) - XLOWT ( 1 )) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! VALNTH = XHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! XHIGT ( 1 ) = XLOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK ILOW = ILOW + 1 End Do ! XWRK1 = XHIGT ( INTH ) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XLOWT ( ICRS ) < XWRK1 ) Then XWRK = XLOWT ( ICRS ) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XHIGT ( IDCR )) Exit XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) End Do XHIGT ( IDCR + 1 ) = XLOWT ( ICRS ) XWRK1 = XHIGT ( INTH ) End If ILOW = ILOW + 1 End Do ! VALNTH = XHIGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! VALNTH = MAXVAL ( XLOWT ( 1 : INTH )) ! End Function real64_valnth Function real32_valnth ( XDONT , NORD ) Result ( valnth ) ! __________________________________________________________ Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Real ( Kind = real32 ) :: valnth Integer , Intent ( In ) :: NORD ! __________________________________________________________ Real ( Kind = real32 ), Dimension ( SIZE ( XDONT )) :: XLOWT , XHIGT Real ( Kind = real32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX ! Integer :: NDON , JHIG , JLOW , IHIG Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = MAX ( MIN ( NORD , NDON ), 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) VALNTH = XDONT ( 1 ) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then XLOWT ( 1 ) = XDONT ( 2 ) XHIGT ( 1 ) = XDONT ( 1 ) Else XLOWT ( 1 ) = XDONT ( 1 ) XHIGT ( 1 ) = XDONT ( 2 ) End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) VALNTH = XLOWT ( 1 ) If ( INTH == 2 ) VALNTH = XHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( 3 ) Else XHIGT ( 1 ) = XDONT ( 3 ) End If Else XHIGT ( 2 ) = XDONT ( 3 ) End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! If ( XDONT ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( NDON ) Else XHIGT ( 1 ) = XDONT ( NDON ) End If Else XHIGT ( 3 ) = XDONT ( NDON ) End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * ( XHIGT ( 3 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 2 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) & XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 1 ) - XLOWT ( 1 )) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! VALNTH = XHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! XHIGT ( 1 ) = XLOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK ILOW = ILOW + 1 End Do ! XWRK1 = XHIGT ( INTH ) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XLOWT ( ICRS ) < XWRK1 ) Then XWRK = XLOWT ( ICRS ) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XHIGT ( IDCR )) Exit XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) End Do XHIGT ( IDCR + 1 ) = XLOWT ( ICRS ) XWRK1 = XHIGT ( INTH ) End If ILOW = ILOW + 1 End Do ! VALNTH = XHIGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! VALNTH = MAXVAL ( XLOWT ( 1 : INTH )) ! End Function real32_valnth Function int32_valnth ( XDONT , NORD ) Result ( valnth ) ! __________________________________________________________ Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer ( Kind = int32 ) :: valnth Integer , Intent ( In ) :: NORD ! __________________________________________________________ Integer ( Kind = int32 ), Dimension ( SIZE ( XDONT )) :: XLOWT , XHIGT Integer ( Kind = int32 ) :: XPIV , XPIV0 , XWRK , XWRK1 , XWRK2 , XWRK3 , XMIN , XMAX ! Integer :: NDON , JHIG , JLOW , IHIG Integer :: IMIL , IFIN , ICRS , IDCR , ILOW Integer :: JLM2 , JLM1 , JHM2 , JHM1 , INTH ! NDON = SIZE ( XDONT ) INTH = MAX ( MIN ( NORD , NDON ), 1 ) ! !    First loop is used to fill-in XLOWT, XHIGT at the same time ! If ( NDON < 2 ) Then If ( INTH == 1 ) VALNTH = XDONT ( 1 ) Return End If ! !  One chooses a pivot, best estimate possible to put fractile near !  mid-point of the set of low values. ! If ( XDONT ( 2 ) < XDONT ( 1 )) Then XLOWT ( 1 ) = XDONT ( 2 ) XHIGT ( 1 ) = XDONT ( 1 ) Else XLOWT ( 1 ) = XDONT ( 1 ) XHIGT ( 1 ) = XDONT ( 2 ) End If ! If ( NDON < 3 ) Then If ( INTH == 1 ) VALNTH = XLOWT ( 1 ) If ( INTH == 2 ) VALNTH = XHIGT ( 1 ) Return End If ! If ( XDONT ( 3 ) < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( 3 ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( 3 ) Else XHIGT ( 1 ) = XDONT ( 3 ) End If Else XHIGT ( 2 ) = XDONT ( 3 ) End If ! If ( NDON < 4 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! If ( XDONT ( NDON ) < XHIGT ( 1 )) Then XHIGT ( 3 ) = XHIGT ( 2 ) XHIGT ( 2 ) = XHIGT ( 1 ) If ( XDONT ( NDON ) < XLOWT ( 1 )) Then XHIGT ( 1 ) = XLOWT ( 1 ) XLOWT ( 1 ) = XDONT ( NDON ) Else XHIGT ( 1 ) = XDONT ( NDON ) End If Else XHIGT ( 3 ) = XDONT ( NDON ) End If ! If ( NDON < 5 ) Then If ( INTH == 1 ) Then VALNTH = XLOWT ( 1 ) Else VALNTH = XHIGT ( INTH - 1 ) End If Return End If ! JLOW = 1 JHIG = 3 XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * ( XHIGT ( 3 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) Then XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 2 ) - XLOWT ( 1 )) If ( XPIV >= XHIGT ( 1 )) & XPIV = XLOWT ( 1 ) + REAL ( 2 * INTH ) / REAL ( NDON + INTH ) * & ( XHIGT ( 1 ) - XLOWT ( 1 )) End If XPIV0 = XPIV ! !  One puts values > pivot in the end and those <= pivot !  at the beginning. This is split in 2 cases, so that !  we can skip the loop test a number of times. !  As we are also filling in the work arrays at the same time !  we stop filling in the XHIGT array as soon as we have more !  than enough values in XLOWT. ! ! If ( XDONT ( NDON ) > XPIV ) Then ICRS = 3 Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) > XPIV ) Then If ( ICRS >= NDON ) Exit JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! !  One restricts further processing because it is no use !  to store more high values ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) Else If ( ICRS >= NDON ) Then Exit End If End Do End If ! ! Else ! !  Same as above, but this is not as easy to optimize, so the !  DO-loop is kept ! Do ICRS = 4 , NDON - 1 If ( XDONT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XDONT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < NDON - 1 ) Then Do ICRS = ICRS + 1 If ( XDONT ( ICRS ) <= XPIV ) Then If ( ICRS >= NDON ) Exit JLOW = JLOW + 1 XLOWT ( JLOW ) = XDONT ( ICRS ) End If End Do End If End If ! JLM2 = 0 JLM1 = 0 JHM2 = 0 JHM1 = 0 Do If ( JLM2 == JLOW . And . JHM2 == JHIG ) Then ! !   We are oscillating. Perturbate by bringing JLOW closer by one !   to INTH ! If ( INTH > JLOW ) Then XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( IHIG ) XHIGT ( IHIG ) = XHIGT ( JHIG ) JHIG = JHIG - 1 Else XMAX = XLOWT ( JLOW ) JLOW = JLOW - 1 Do ICRS = 1 , JLOW If ( XLOWT ( ICRS ) > XMAX ) Then XWRK = XMAX XMAX = XLOWT ( ICRS ) XLOWT ( ICRS ) = XWRK End If End Do End If End If JLM2 = JLM1 JLM1 = JLOW JHM2 = JHM1 JHM1 = JHIG ! !   We try to bring the number of values in the low values set !   closer to INTH. ! Select Case ( INTH - JLOW ) Case ( 2 :) ! !   Not enough values in low part, at least 2 are missing ! INTH = INTH - JLOW JLOW = 0 Select Case ( JHIG ) !!!!!           CASE DEFAULT !!!!!              write (unit=*,fmt=*) \"Assertion failed\" !!!!!              STOP ! !   We make a special case when we have so few values in !   the high values set that it is bad performance to choose a pivot !   and apply the general algorithm. ! Case ( 2 ) If ( XHIGT ( 1 ) <= XHIGT ( 2 )) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 2 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( 1 ) End If Exit ! Case ( 3 ) ! ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( 3 ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( 3 ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If JHIG = 0 Do ICRS = JLOW + 1 , INTH JHIG = JHIG + 1 XLOWT ( ICRS ) = XHIGT ( JHIG ) End Do JLOW = INTH Exit ! Case ( 4 :) ! ! XPIV0 = XPIV IFIN = JHIG ! !  One chooses a pivot from the 2 first values and the last one. !  This should ensure sufficient renewal between iterations to !  avoid worst case behavior effects. ! XWRK1 = XHIGT ( 1 ) XWRK2 = XHIGT ( 2 ) XWRK3 = XHIGT ( IFIN ) If ( XWRK2 < XWRK1 ) Then XHIGT ( 1 ) = XWRK2 XHIGT ( 2 ) = XWRK1 XWRK2 = XWRK1 End If If ( XWRK2 > XWRK3 ) Then XHIGT ( IFIN ) = XWRK2 XHIGT ( 2 ) = XWRK3 XWRK2 = XWRK3 If ( XWRK2 < XHIGT ( 1 )) Then XHIGT ( 2 ) = XHIGT ( 1 ) XHIGT ( 1 ) = XWRK2 End If End If ! XWRK1 = XHIGT ( 1 ) JLOW = JLOW + 1 XLOWT ( JLOW ) = XWRK1 XPIV = XWRK1 + 0.5 * ( XHIGT ( IFIN ) - XWRK1 ) ! !  One takes values <= pivot to XLOWT !  Again, 2 parts, one where we take care of the remaining !  high values because we might still need them, and the !  other when we know that we will have more than enough !  low values in the end. ! JHIG = 0 Do ICRS = 2 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) If ( JLOW >= INTH ) Exit Else JHIG = JHIG + 1 XHIGT ( JHIG ) = XHIGT ( ICRS ) End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XHIGT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XHIGT ( ICRS ) End If End Do End Select ! ! Case ( 1 ) ! !  Only 1 value is missing in low part ! XMIN = XHIGT ( 1 ) IHIG = 1 Do ICRS = 2 , JHIG If ( XHIGT ( ICRS ) < XMIN ) Then XMIN = XHIGT ( ICRS ) IHIG = ICRS End If End Do ! VALNTH = XHIGT ( IHIG ) Return ! ! Case ( 0 ) ! !  Low part is exactly what we want ! Exit ! ! Case ( - 5 : - 1 ) ! !  Only few values too many in low part ! XHIGT ( 1 ) = XLOWT ( 1 ) ILOW = 1 + INTH - JLOW Do ICRS = 2 , INTH XWRK = XLOWT ( ICRS ) Do IDCR = ICRS - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK < XHIGT ( IDCR )) Then XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) Else Exit End If End Do XHIGT ( IDCR + 1 ) = XWRK ILOW = ILOW + 1 End Do ! XWRK1 = XHIGT ( INTH ) ILOW = 2 * INTH - JLOW Do ICRS = INTH + 1 , JLOW If ( XLOWT ( ICRS ) < XWRK1 ) Then XWRK = XLOWT ( ICRS ) Do IDCR = INTH - 1 , MAX ( 1 , ILOW ), - 1 If ( XWRK >= XHIGT ( IDCR )) Exit XHIGT ( IDCR + 1 ) = XHIGT ( IDCR ) End Do XHIGT ( IDCR + 1 ) = XLOWT ( ICRS ) XWRK1 = XHIGT ( INTH ) End If ILOW = ILOW + 1 End Do ! VALNTH = XHIGT ( INTH ) Return ! ! Case (: - 6 ) ! ! last case: too many values in low part ! IMIL = ( JLOW + 1 ) / 2 IFIN = JLOW ! !  One chooses a pivot from 1st, last, and middle values ! If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If If ( XLOWT ( IMIL ) > XLOWT ( IFIN )) Then XWRK = XLOWT ( IFIN ) XLOWT ( IFIN ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK If ( XLOWT ( IMIL ) < XLOWT ( 1 )) Then XWRK = XLOWT ( 1 ) XLOWT ( 1 ) = XLOWT ( IMIL ) XLOWT ( IMIL ) = XWRK End If End If If ( IFIN <= 3 ) Exit ! XPIV = XLOWT ( 1 ) + REAL ( INTH ) / REAL ( JLOW + INTH ) * & ( XLOWT ( IFIN ) - XLOWT ( 1 )) ! !  One takes values > XPIV to XHIGT ! JHIG = 0 JLOW = 0 ! If ( XLOWT ( IFIN ) > XPIV ) Then ICRS = 0 Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) If ( ICRS >= IFIN ) Exit Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! If ( ICRS < IFIN ) Then Do ICRS = ICRS + 1 If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) Else If ( ICRS >= IFIN ) Exit End If End Do End If Else Do ICRS = 1 , IFIN If ( XLOWT ( ICRS ) > XPIV ) Then JHIG = JHIG + 1 XHIGT ( JHIG ) = XLOWT ( ICRS ) Else JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) If ( JLOW >= INTH ) Exit End If End Do ! Do ICRS = ICRS + 1 , IFIN If ( XLOWT ( ICRS ) <= XPIV ) Then JLOW = JLOW + 1 XLOWT ( JLOW ) = XLOWT ( ICRS ) End If End Do End If ! End Select ! End Do ! !  Now, we only need to find maximum of the 1:INTH set ! VALNTH = MAXVAL ( XLOWT ( 1 : INTH )) ! End Function int32_valnth end module M_valnth","tags":"","loc":"sourcefile/m_valnth.f90.html"},{"title":"M_unista.f90 – orderpack","text":"Contents Modules M_unista Source Code M_unista.f90 Source Code Module M_unista use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 Use M_uniinv implicit none Private public :: unista private :: real64_unista , real32_unista , int32_unista interface unista module procedure real64_unista , real32_unista , int32_unista end interface unista contains !> !!##NAME !!    unista(3f) - [orderpack:UNIQUE] (Stable unique) Removes duplicates from an !!                 array otherwise retaining original order !! !!##SYNOPSIS !! !!     Subroutine unista (XDONT, NUNI) !! !!      ${TYPE} (kind=${KIND}), Dimension (:), Intent (InOut) :: XDONT !!      Integer, Intent (Out) :: NUNI !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !!    UNISTA (\"Stable Unique\") removes duplicates from an array, leaving !!    unique entries in the order of their first appearance in the initial !!    set. !! !!##OPTIONS !!     XDONT   input array to reduce to unique values !!     NUNI    number of values comprising the returned set of unique !!             values !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unista !!    use M_unista, only : unista !!    implicit none !!    character(len=*),parameter :: list= '(*(g0:,\",\"))' !!    real,allocatable :: xdont(:) !!    integer :: nuni !!       xdont=[4.4,3.3,3.3,3.3,2.2,1.1,3.3,4.4,5.5,3.3] !!       print list,'ORIGINAL:',xdont !!       print * !!       call unista(xdont,nuni) !!       xdont=xdont(:nuni) !!       print list,'UNIQUE:',xdont !!    end program demo_unista !! !!   Results: !! !!     ORIGINAL:,4.400000,3.300000,3.300000,3.300000,2.200000, !!     1.100000,3.300000,4.400000,5.500000,3.300000 !! !!     UNIQUE:,4.400000,3.300000,2.200000,1.100000,5.500000 !! !!##AUTHOR !!   Michel Olagnon - Feb. 2000 !! !!   John Urban, 2022.04.16 !!   o added man-page and reduced to a template using the !!     prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_unista ( XDONT , NUNI ) Real ( kind = real64 ), Dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Logical , Dimension ( Size ( XDONT )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( XDONT ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 XDONT ( NUNI ) = XDONT ( ICRS ) End If End Do ! End Subroutine real64_unista Subroutine real32_unista ( XDONT , NUNI ) Real ( kind = real32 ), Dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Logical , Dimension ( Size ( XDONT )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( XDONT ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 XDONT ( NUNI ) = XDONT ( ICRS ) End If End Do ! End Subroutine real32_unista Subroutine int32_unista ( XDONT , NUNI ) Integer ( kind = int32 ), Dimension (:), Intent ( InOut ) :: XDONT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( Size ( XDONT )) :: IWRKT Logical , Dimension ( Size ( XDONT )) :: IFMPTYT Integer :: ICRS ! __________________________________________________________ Call UNIINV ( XDONT , IWRKT ) IFMPTYT = . True . NUNI = 0 Do ICRS = 1 , Size ( XDONT ) If ( IFMPTYT ( IWRKT ( ICRS ))) Then IFMPTYT ( IWRKT ( ICRS )) = . False . NUNI = NUNI + 1 XDONT ( NUNI ) = XDONT ( ICRS ) End If End Do ! End Subroutine int32_unista end module M_unista","tags":"","loc":"sourcefile/m_unista.f90.html"},{"title":"M_indmed.f90 – orderpack","text":"Contents Modules M_indmed Source Code M_indmed.f90 Source Code Module M_indmed use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private integer , parameter :: f_char = selected_char_kind ( \"DEFAULT\" ) public :: indmed Integer , Allocatable , Dimension (:), Private , Save :: IDONT interface indmed module procedure real64_indmed , real32_indmed , int32_indmed , f_char_indmed end interface indmed contains !> !!##NAME !!    indmed(3f) - [orderpack:MEDIAN] Returns index of median value of !!                 an array. !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_indmed (XDONT, INDM) !! !!       ${TYPE} (kind=${KIND}), Dimension (:), Intent (In) :: XDONT !!       Integer, Intent (Out) :: INDM !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !!       o Character(kind=selected_char_kind(\"DEFAULT\"),len=*) !! !!##DESCRIPTION !!    Finds the index of the median of XDONT using the recursive procedure !!    described in Knuth, The Art of Computer Programming, vol. 3, 5.3.3 - !!    This procedure is linear in time, and does not require to be able to !!    interpolate in the set as the one used in INDNTH. It also has better !!    worst case behavior than INDNTH, but is about 30% slower in average !!    for random uniformly distributed values. !! !!##OPTIONS !!     XDONT     array to find the median value of. !!     INDM      index of the median value. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_indmed !!    use M_indmed, only : indmed !!    implicit none !!    real,allocatable :: xdont(:) !!    character(len=:),allocatable :: cdont(:) !!    integer :: ii !!       xdont=[80.0,70.0,20.0,10.0,1000.0] !!       call indmed(xdont,ii) !!       write(*,*) ii,xdont(ii) !!       ! !!       xdont=[11, 22, 33, 44, 55, 66, 77, 88] !!       call indmed(xdont,ii) !!       write(*,*) ii,xdont(ii) !!       ! !!       xdont=[11.0d0,77.0d0,22.0d0,66.0d0,33.0d0,88.0d0] !!       call indmed(xdont,ii) !!       write(*,*) ii,xdont(ii) !!       ! !!       cdont=[character(len=20) :: 'apple','bee','cherry','duck','elephant','finger','goose','h','insect','j'] !!       call indmed(cdont,ii) !!       write(*,*) ii,cdont(ii) !!       ! !!    end program demo_indmed !! !!   Results: !!     > 2   70.0000000 !!     > 4   44.0000000 !!     > 5   33.0000000 !!     > 5   elephant !! !!##AUTHOR !!     Michel Olagnon, 2000-2012 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_indmed ( XDONT , INDM ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( Out ) :: INDM ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( XDONT ))) Do IDON = 1 , SIZE ( XDONT ) IDONT ( IDON ) = IDON End Do ! Call real64_med ( XDONT , IDONT , INDM ) ! Deallocate ( IDONT ) End Subroutine real64_indmed Recursive Subroutine real64_med ( XDATT , IDATT , ires_med ) Real ( kind = real64 ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! Real ( kind = real64 ), Parameter :: XHUGE = - HUGE ( XDATT ) Real ( kind = real64 ) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call real64_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine real64_med Subroutine real32_indmed ( XDONT , INDM ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( Out ) :: INDM ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( XDONT ))) Do IDON = 1 , SIZE ( XDONT ) IDONT ( IDON ) = IDON End Do ! Call real32_med ( XDONT , IDONT , INDM ) ! Deallocate ( IDONT ) End Subroutine real32_indmed Recursive Subroutine real32_med ( XDATT , IDATT , ires_med ) Real ( kind = real32 ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! Real ( kind = real32 ), Parameter :: XHUGE = - HUGE ( XDATT ) Real ( kind = real32 ) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call real32_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine real32_med Subroutine int32_indmed ( XDONT , INDM ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( Out ) :: INDM ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( XDONT ))) Do IDON = 1 , SIZE ( XDONT ) IDONT ( IDON ) = IDON End Do ! Call int32_med ( XDONT , IDONT , INDM ) ! Deallocate ( IDONT ) End Subroutine int32_indmed Recursive Subroutine int32_med ( XDATT , IDATT , ires_med ) Integer ( kind = int32 ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! Integer ( kind = int32 ), Parameter :: XHUGE = - HUGE ( XDATT ) Integer ( kind = int32 ) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call int32_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine int32_med Subroutine f_char_indmed ( XDONT , INDM ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XDONT Integer , Intent ( Out ) :: INDM ! __________________________________________________________ Integer :: IDON ! Allocate ( IDONT ( SIZE ( XDONT ))) Do IDON = 1 , SIZE ( XDONT ) IDONT ( IDON ) = IDON End Do ! Call f_char_med ( XDONT , IDONT , INDM ) ! Deallocate ( IDONT ) End Subroutine f_char_indmed Recursive Subroutine f_char_med ( XDATT , IDATT , ires_med ) character ( kind = f_char , len =* ), Dimension (:), Intent ( In ) :: XDATT Integer , Dimension (:), Intent ( In ) :: IDATT Integer , Intent ( Out ) :: ires_med ! __________________________________________________________ ! character ( kind = f_char , len = len ( XDATT )) :: XHUGE character ( kind = f_char , len = len ( XDATT )) :: XWRK , XWRK1 , XMED7 , XMAX , XMIN ! Integer , Dimension ( 7 * ((( Size ( IDATT ) + 6 ) / 7 + 6 ) / 7 )) :: ISTRT , IENDT , IMEDT Integer , Dimension ( 7 * (( Size ( IDATT ) + 6 ) / 7 )) :: IWRKT Integer :: NTRI , NMED , NORD , NEQU , NLEQ , IMED , IDON , IDON1 Integer :: IDEB , ITMP , IDCR , ICRS , ICRS1 , ICRS2 , IMAX , IMIN Integer :: IWRK , IWRK1 , IMED1 , IMED7 , NDAT ! XHUGE = repeat ( char ( 0 ), len ( xdatt )) NDAT = Size ( IDATT ) NMED = ( NDAT + 1 ) / 2 IWRKT (: size ( idatt )) = IDATT ! !  If the number of values is small, then use insertion sort ! If ( NDAT < 35 ) Then ! !  Bring minimum to first location to save test in decreasing loop ! IDCR = NDAT If ( XDATT ( IWRKT ( 1 )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( 1 ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( 1 ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , NDAT - 2 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK XWRK = XWRK1 IWRK = IWRK1 Endif End Do IWRKT ( 1 ) = IWRK ! ! Sort the first half, until we have NMED sorted values ! Do ICRS = 3 , NMED XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) IDCR = ICRS - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! !  Insert any value less than the current median in the first half ! XWRK1 = XDATT ( IWRKT ( NMED )) Do ICRS = NMED + 1 , NDAT XWRK = XDATT ( IWRKT ( ICRS )) IWRK = IWRKT ( ICRS ) If ( XWRK < XWRK1 ) Then IDCR = NMED - 1 Do If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) IDCR = IDCR - 1 End Do IWRKT ( IDCR + 1 ) = IWRK XWRK1 = XDATT ( IWRKT ( NMED )) End If End Do ires_med = IWRKT ( NMED ) Return End If ! !  Make sorted subsets of 7 elements !  This is done by a variant of insertion sort where a first !  pass is used to bring the smallest element to the first position !  decreasing disorder at the same time, so that we may remove !  the loop test in the insertion loop. ! IMAX = 1 IMIN = 1 XMAX = XDATT ( IWRKT ( IMAX )) XMIN = XDATT ( IWRKT ( IMIN )) DO IDEB = 1 , NDAT - 6 , 7 IDCR = IDEB + 6 If ( XDATT ( IWRKT ( IDEB )) < XDATT ( IWRKT ( IDCR ))) Then IWRK = IWRKT ( IDEB ) Else IWRK = IWRKT ( IDCR ) IWRKT ( IDCR ) = IWRKT ( IDEB ) Endif XWRK = XDATT ( IWRK ) Do ITMP = 1 , 5 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR ) XWRK1 = XDATT ( IWRK1 ) If ( XWRK1 < XWRK ) Then IWRKT ( IDCR ) = IWRK IWRK = IWRK1 XWRK = XWRK1 Endif End Do IWRKT ( IDEB ) = IWRK If ( XWRK < XMIN ) Then IMIN = IWRK XMIN = XWRK End If Do ICRS = IDEB + 1 , IDEB + 5 IWRK = IWRKT ( ICRS + 1 ) XWRK = XDATT ( IWRK ) IDON = IWRKT ( ICRS ) If ( XWRK < XDATT ( IDON )) Then IWRKT ( ICRS + 1 ) = IDON IDCR = ICRS IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) Do If ( XWRK >= XWRK1 ) Exit IWRKT ( IDCR ) = IWRK1 IDCR = IDCR - 1 IWRK1 = IWRKT ( IDCR - 1 ) XWRK1 = XDATT ( IWRK1 ) End Do IWRKT ( IDCR ) = IWRK EndIf End Do If ( XWRK > XMAX ) Then IMAX = IWRK XMAX = XWRK End If End Do ! !  Add-up alternatively MAX and MIN values to make the number of data !  an exact multiple of 7. ! IDEB = 7 * ( NDAT / 7 ) NTRI = NDAT If ( IDEB < NDAT ) Then ! Do ICRS = IDEB + 1 , NDAT XWRK1 = XDATT ( IWRKT ( ICRS )) IF ( XWRK1 > XMAX ) Then IMAX = IWRKT ( ICRS ) XMAX = XWRK1 End If IF ( XWRK1 < XMIN ) Then IMIN = IWRKT ( ICRS ) XMIN = XWRK1 End If End Do IWRK1 = IMAX Do ICRS = NDAT + 1 , IDEB + 7 IWRKT ( ICRS ) = IWRK1 If ( IWRK1 == IMAX ) Then IWRK1 = IMIN Else NMED = NMED + 1 IWRK1 = IMAX End If End Do ! Do ICRS = IDEB + 2 , IDEB + 7 IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS - 1 , IDEB + 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK End Do ! NTRI = IDEB + 7 End If ! !  Make the set of the indices of median values of each sorted subset ! IDON1 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 IMEDT ( IDON1 ) = IWRKT ( IDON + 3 ) End Do ! !  Find XMED7, the median of the medians ! Call f_char_med ( XDATT , IMEDT ( 1 : IDON1 ), IMED7 ) XMED7 = XDATT ( IMED7 ) ! !  Count how many values are not higher than (and how many equal to) XMED7 !  This number is at least 4 * 1/2 * (N/7) : 4 values in each of the !  subsets where the median is lower than the median of medians. For similar !  reasons, we also have at least 2N/7 values not lower than XMED7. At the !  same time, we find in each subset the index of the last value < XMED7, !  and that of the first > XMED7. These indices will be used to restrict the !  search for the median as the Kth element in the subset (> or <) where !  we know it to be. ! IDON1 = 1 NLEQ = 0 NEQU = 0 Do IDON = 1 , NTRI , 7 IMED = IDON + 3 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 2 If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then IMED = IMED - 1 Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then IMED = IMED + 1 Endif Endif If ( XDATT ( IWRKT ( IMED )) > XMED7 ) Then NLEQ = NLEQ + IMED - IDON IENDT ( IDON1 ) = IMED - 1 ISTRT ( IDON1 ) = IMED Else If ( XDATT ( IWRKT ( IMED )) < XMED7 ) Then NLEQ = NLEQ + IMED - IDON + 1 IENDT ( IDON1 ) = IMED ISTRT ( IDON1 ) = IMED + 1 Else !       If (XDATT (IWRKT (IMED)) == XMED7) NLEQ = NLEQ + IMED - IDON + 1 NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED - 1 Do IMED1 = IMED - 1 , IDON , - 1 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 IENDT ( IDON1 ) = IMED1 - 1 Else Exit End If End Do ISTRT ( IDON1 ) = IMED + 1 Do IMED1 = IMED + 1 , IDON + 6 If ( XDATT ( IWRKT ( IMED1 )) == XMED7 ) Then NEQU = NEQU + 1 NLEQ = NLEQ + 1 ISTRT ( IDON1 ) = IMED1 + 1 Else Exit End If End Do Endif IDON1 = IDON1 + 1 End Do ! !  Carry out a partial insertion sort to find the Kth smallest of the !  large values, or the Kth largest of the small values, according to !  what is needed. ! ! If ( NLEQ - NEQU + 1 <= NMED ) Then If ( NLEQ < NMED ) Then !      Not enough low values IWRK1 = IMAX XWRK1 = XDATT ( IWRK1 ) NORD = NMED - NLEQ IDON1 = 0 ICRS1 = 1 ICRS2 = 0 IDCR = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) < XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Endif End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = ISTRT ( IDON1 ), IDON + 6 If ( XDATT ( IWRKT ( ICRS )) >= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK >= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do End If End Do ires_med = IWRK1 Return Else ires_med = IMED7 Return End If Else !      If (NLEQ > NMED) !                                          Not enough high values XWRK1 = XHUGE NORD = NLEQ - NEQU - NMED + 1 IDON1 = 0 ICRS1 = 1 ICRS2 = 0 Do IDON = 1 , NTRI , 7 IDON1 = IDON1 + 1 If ( ICRS2 < NORD ) Then ! Do ICRS = IDON , IENDT ( IDON1 ) If ( XDATT ( IWRKT ( ICRS )) > XWRK1 ) Then IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) Else If ( ICRS2 < NORD ) Then IWRKT ( ICRS1 ) = IWRKT ( ICRS ) IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End If End If ICRS1 = MIN ( NORD , ICRS1 + 1 ) ICRS2 = MIN ( NORD , ICRS2 + 1 ) End Do Else Do ICRS = IENDT ( IDON1 ), IDON , - 1 If ( XDATT ( IWRKT ( ICRS )) <= XWRK1 ) Exit IWRK = IWRKT ( ICRS ) XWRK = XDATT ( IWRK ) IDCR = ICRS1 - 1 Do IDCR = ICRS1 - 1 , 1 , - 1 If ( XWRK <= XDATT ( IWRKT ( IDCR ))) Exit IWRKT ( IDCR + 1 ) = IWRKT ( IDCR ) End Do IWRKT ( IDCR + 1 ) = IWRK IWRK1 = IWRKT ( ICRS1 ) XWRK1 = XDATT ( IWRK1 ) End Do Endif End Do ! ires_med = IWRK1 Return End If ! END Subroutine f_char_med end module M_indmed","tags":"","loc":"sourcefile/m_indmed.f90.html"},{"title":"M_unirnk.f90 – orderpack","text":"Contents Modules M_unirnk Source Code M_unirnk.f90 Source Code Module M_unirnk use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none Private public :: unirnk interface unirnk module procedure real64_unirnk , real32_unirnk , int32_unirnk end interface unirnk interface nearless module procedure real64_nearless , real32_nearless , int32_nearless end interface nearless contains !> !!##NAME !!    unirnk(3f) - [orderpack:RANK_UNIQUE] performs a Merge-sort ranking !!                 of an array, with removal of duplicate entries. !! !!##SYNOPSIS !! !!     Subroutine ${KIND}_unirnk (XVALT, IRNGT, NUNI) !! !!       ${TYPE} (Kind=${KIND}), Dimension (:), Intent (In) :: XVALT !!       Integer, Dimension (:), Intent (Out) :: IRNGT !!       Integer, Intent (Out) :: NUNI !! !!    Where ${TYPE}(kind=${KIND}) may be !! !!       o Real(kind=real32) !!       o Real(kind=real64) !!       o Integer(kind=int32) !! !!##DESCRIPTION !! !!    UNIRNK performs a Merge-sort ranking of an array, with removal of !!    duplicate entries. !! !!    The routine is similar to pure merge-sort ranking, but on !!    the last pass, it discards indices that correspond to !!    duplicate entries. !! !!    For performance reasons, the first 2 passes are taken !!    out of the standard loop, and use dedicated coding. !! !!##OPTIONS !!     XVALT      array to index !!     IRNGT      rank index returned pointing to unique values !!     NUNI       the number of unique values found !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unirnk !!    use M_unirnk, only : unirnk !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable :: xvalt(:) !!    ! !!    xvalt=[10,5,7,1,4,5,6,8,9,10,1] !!    call printme() !!    xvalt=[-1,0,-2,0,-3,0,-4] !!    call printme() !!    contains !!    subroutine printme() !!    integer,allocatable :: irngt(:) !!    integer :: nuni !!       if(allocated(irngt))deallocate(irngt) !!       allocate(irngt(size(xvalt))) !!       write(*,g)'ORIGINAL:',xvalt !!       call unirnk(xvalt,irngt,nuni) !!       write(*,g)'NUMBER OF UNIQUE INDICES:',nuni !!       write(*,g)'RETURNED INDICES:',irngt(:nuni) !!       write(*,g)'SORTED DATA:',xvalt(irngt(:nuni)) !!    end subroutine !!    end program demo_unirnk !! !!   Results: !! !!##AUTHOR !!     Michel Olagnon, 2000-2012 !! !!     John Urban, 2022.04.16 !!     o added man-page and reduced to a template using the !!       prep(1) preprocessor. !! !!##LICENSE !!    CC0-1.0 Subroutine real64_unirnk ( XVALT , IRNGT , NUNI ) Real ( Kind = real64 ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind = real64 ) :: XTST , XVALA , XVALB ! ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) NUNI = NVAL ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG1 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XVALA = XVALT ( JWRKT ( IINDA )) XVALB = XVALT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XVALT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XVALT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XVALT ( JWRKT ( 1 )), XVALT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XVALT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XVALT ( JWRKT ( IINDA )) > XVALT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XVALT ( IRNG ) > XTST ) Then XTST = XVALT ( IRNG ) NUNI = NUNI + 1 IRNGT ( NUNI ) = IRNG End If ! End Do ! Return ! End Subroutine real64_unirnk Function real64_nearless ( XVAL ) result ( real64_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real64 ), Intent ( In ) :: XVAL Real ( kind = real64 ) :: real64_nl ! __________________________________________________________ real64_nl = nearest ( XVAL , - 1.0_real64 ) ! End Function real64_nearless Subroutine real32_unirnk ( XVALT , IRNGT , NUNI ) Real ( Kind = real32 ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind = real32 ) :: XTST , XVALA , XVALB ! ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) NUNI = NVAL ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG1 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XVALA = XVALT ( JWRKT ( IINDA )) XVALB = XVALT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XVALT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XVALT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XVALT ( JWRKT ( 1 )), XVALT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XVALT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XVALT ( JWRKT ( IINDA )) > XVALT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XVALT ( IRNG ) > XTST ) Then XTST = XVALT ( IRNG ) NUNI = NUNI + 1 IRNGT ( NUNI ) = IRNG End If ! End Do ! Return ! End Subroutine real32_unirnk Function real32_nearless ( XVAL ) result ( real32_nl ) !! Nearest value less than given value ! __________________________________________________________ Real ( kind = real32 ), Intent ( In ) :: XVAL Real ( kind = real32 ) :: real32_nl ! __________________________________________________________ real32_nl = nearest ( XVAL , - 1.0_real32 ) ! End Function real32_nearless Subroutine int32_unirnk ( XVALT , IRNGT , NUNI ) Integer ( Kind = int32 ), Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT Integer , Intent ( Out ) :: NUNI ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Integer ( Kind = int32 ) :: XTST , XVALA , XVALB ! ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) NUNI = NVAL ! Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) < XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Modulo ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 4 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG1 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( 2 * LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !  One steps in the C subset, that we create in the final rank array ! !  Make a copy of the rank array for the iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) XVALA = XVALT ( JWRKT ( IINDA )) XVALB = XVALT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XVALT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XVALT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! !   Last merge of A and B into C, with removal of duplicates. ! IINDA = 1 IINDB = LMTNA + 1 NUNI = 0 ! !  One steps in the C subset, that we create in the final rank array ! JWRKT ( 1 : LMTNA ) = IRNGT ( 1 : LMTNA ) If ( IINDB <= NVAL ) Then XTST = NEARLESS ( Min ( XVALT ( JWRKT ( 1 )), XVALT ( IRNGT ( IINDB )))) Else XTST = NEARLESS ( XVALT ( JWRKT ( 1 ))) Endif Do IWRK = 1 , NVAL ! !  We still have unprocessed values in both A and B ! If ( IINDA <= LMTNA ) Then If ( IINDB <= NVAL ) Then If ( XVALT ( JWRKT ( IINDA )) > XVALT ( IRNGT ( IINDB ))) Then IRNG = IRNGT ( IINDB ) IINDB = IINDB + 1 Else IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only A still with unprocessed values ! IRNG = JWRKT ( IINDA ) IINDA = IINDA + 1 End If Else ! !  Only B still with unprocessed values ! IRNG = IRNGT ( IWRK ) End If If ( XVALT ( IRNG ) > XTST ) Then XTST = XVALT ( IRNG ) NUNI = NUNI + 1 IRNGT ( NUNI ) = IRNG End If ! End Do ! Return ! End Subroutine int32_unirnk Function int32_nearless ( XVAL ) result ( int32_nl ) !! Nearest value less than given value ! __________________________________________________________ Integer ( kind = int32 ), Intent ( In ) :: XVAL Integer ( kind = int32 ) :: int32_nl ! __________________________________________________________ int32_nl = XVAL - 1_int32 ! End Function int32_nearless end module M_unirnk","tags":"","loc":"sourcefile/m_unirnk.f90.html"},{"title":"demo_rapknr.f90 – orderpack","text":"Contents Programs demo_rapknr Source Code demo_rapknr.f90 Source Code program demo_rapknr use M_rapknr , only : rapknr implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , xdont call rapknr ( xdont , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'MAXIMUM VALUES:' , xdont ( irngt (: nord )) end program demo_rapknr","tags":"","loc":"sourcefile/demo_rapknr.f90.html"},{"title":"demo_indnth.f90 – orderpack","text":"Contents Programs demo_indnth Source Code demo_indnth.f90 Source Code program demo_indnth ! find Nth lowest value in an array without sorting entire array use M_indnth , only : indnth implicit none integer , allocatable :: iarr (:) character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer :: i iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 , 0 , - 100 ] print list , 'ORIGINAL:' , iarr ! like minloc() and maxloc() print sp , 'minloc' , indnth ( iarr , 1 ), minloc ( iarr ) print sp , 'maxloc' , indnth ( iarr , size ( iarr )), maxloc ( iarr ) ! but more general so can find location of the Nth lowest value ... call printme ( 3 ) ! find location of Nth lowest value call printme ( 1 ) call printme ( 7 ) ! sort the hard way, one value at a time do i = 1 , size ( iarr ) write ( * , sp , advance = 'no' ) iarr ( indnth ( iarr , i )) enddo print * contains subroutine printme ( n ) integer , intent ( in ) :: n integer :: ii ! ii = indnth ( iarr , n ) ! print sp , 'nord=' , n , ' index=' , ii , ' fractile=' , iarr ( ii ) end subroutine printme end program demo_indnth","tags":"","loc":"sourcefile/demo_indnth.f90.html"},{"title":"demo_mrgref.f90 – orderpack","text":"Contents Programs demo_mrgref Source Code demo_mrgref.f90 Source Code program demo_mrgref use M_mrgref , only : mrgref implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call mrgref ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ); allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call mrgref ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_mrgref","tags":"","loc":"sourcefile/demo_mrgref.f90.html"},{"title":"demo_inssor.f90 – orderpack","text":"Contents Programs demo_inssor Source Code demo_inssor.f90 Source Code program demo_inssor use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_inssor , only : inssor implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real64 ) :: valsd ( 2000 ) integer :: valsi ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) call random_number ( valsd ) valsi = int ( valsr * 100000 0.0 ) valsr = valsr * 100000 0.0 - 50000 0.0 valsd = valsd * 100000 0.0 - 50000 0.0 call inssor ( valsi ) do i = 1 , size ( valsi ) - 1 if ( valsi ( i + 1 ). lt . valsi ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo call inssor ( valsr ) do i = 1 , size ( valsr ) - 1 if ( valsr ( i + 1 ). lt . valsr ( i )) then write ( * , * ) 'not sorted' stop 2 endif enddo call inssor ( valsd ) do i = 1 , size ( valsd ) - 1 if ( valsd ( i + 1 ). lt . valsd ( i )) then write ( * , * ) 'not sorted' stop 3 endif enddo write ( * , * ) 'random arrays are now sorted' end program demo_inssor","tags":"","loc":"sourcefile/demo_inssor.f90.html"},{"title":"sort7.f90 – orderpack","text":"Contents Programs sort7 Subroutines oldsub7 newsub7 Source Code sort7.f90 Source Code Program sort7 ! ! This program is used to compare 2 algorithms for sorting ! every successive subset of 7 elements in an array. ! It shows how to call a subroutine with the correct interface ! block in the main program. Interfaces for ORDERPACK routines ! can be found in file interfaces.f90 ! Interface Subroutine oldsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt End Subroutine oldsub7 Subroutine newsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt End Subroutine newsub7 End Interface ! Real , Dimension ( 35280 ) :: xvalt Real , Dimension ( 35280 ) :: xwrkt Real , Dimension ( 7 ) :: xval7t Real , Dimension ( 6 ) :: xval6t Real , Dimension ( 5 ) :: xval5t Real , Dimension ( 4 ) :: xval4t Real , Dimension ( 3 ) :: xval3t Real , Dimension ( 2 ) :: xval2t Real , Dimension ( 1 ) :: xval1t Real :: x1 , x2 , x3 , x4 , x5 , x6 , x7 Integer :: i1 , i2 , i3 , i4 , i5 , i6 , ival ! ! generate all 5040 possible permutations of elements 1,...,7 ! xval7t = ( / 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 / ) ival = 0 Do i1 = 1 , 7 x1 = xval7t ( i1 ) xval6t = pack ( xval7t , ( xval7t /= x1 )) Do i2 = 1 , 6 x2 = xval6t ( i2 ) xval5t = pack ( xval6t , ( xval6t /= x2 )) Do i3 = 1 , 5 x3 = xval5t ( i3 ) xval4t = pack ( xval5t , ( xval5t /= x3 )) Do i4 = 1 , 4 x4 = xval4t ( i4 ) xval3t = pack ( xval4t , ( xval4t /= x4 )) Do i5 = 1 , 3 x5 = xval3t ( i5 ) xval2t = pack ( xval3t , ( xval3t /= x5 )) Do i6 = 1 , 2 x6 = xval2t ( i6 ) xval1t = pack ( xval2t , ( xval2t /= x6 )) x7 = xval1t ( 1 ) xvalt ( ival + 1 : ival + 7 ) = ( / x1 , x2 , x3 , x4 , x5 , & & x6 , x7 / ) ival = ival + 7 End Do End Do End Do End Do End Do End Do Call newsub7 ( xvalt , xwrkt ) Do i1 = 1 , 35280 , 7 If ( any ( xwrkt ( i1 : i1 + 6 ) /= xval7t )) Then Write ( * , * ) \"newsub KO\" , i1 , xwrkt ( i1 : i1 + 6 ) Exit End If End Do Call oldsub7 ( xvalt , xwrkt ) Do i1 = 1 , 35280 , 7 If ( any ( xwrkt ( i1 : i1 + 6 ) /= xval7t )) Then Write ( * , * ) \"oldsub KO\" , i1 , xwrkt ( i1 : i1 + 6 ) End If End Do End Program sort7 Subroutine oldsub7 ( xdont , xwrkt ) ! ! This subroutine is based on insertion sort, with a first ! pass of selection to bring the smallest value in first ! location, thus avoiding a test in the insertion phase ! Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt Real :: xwrk , xwrk1 Integer :: ndon , ideb , iwrk , idcr , icrs ! ndon = size ( xdont ) ! Do ideb = 1 , ndon - 6 , 7 idcr = ideb + 6 If ( xdont ( ideb ) < xdont ( idcr )) Then xwrk = xdont ( ideb ) xwrkt ( idcr ) = xdont ( idcr ) Else xwrk = xdont ( idcr ) xwrkt ( idcr ) = xdont ( ideb ) End If Do iwrk = 1 , 5 idcr = idcr - 1 xwrk1 = xdont ( idcr ) If ( xwrk1 < xwrk ) Then xwrkt ( idcr ) = xwrk xwrk = xwrk1 Else xwrkt ( idcr ) = xwrk1 End If End Do xwrkt ( ideb ) = xwrk Do icrs = ideb + 2 , ideb + 6 xwrk = xwrkt ( icrs ) If ( xwrk < xwrkt ( icrs - 1 )) Then xwrkt ( icrs ) = xwrkt ( icrs - 1 ) idcr = icrs - 1 xwrk1 = xwrkt ( idcr - 1 ) Do If ( xwrk >= xwrk1 ) Exit xwrkt ( idcr ) = xwrk1 idcr = idcr - 1 xwrk1 = xwrkt ( idcr - 1 ) End Do xwrkt ( idcr ) = xwrk End If End Do End Do End Subroutine oldsub7 Subroutine newsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt Real :: xwrk1 , xwrk2 , xwrk3 , xwrk4 , xwrk5 , xwrk6 Real :: xwrk , xwrki , xwrks Integer :: ndon , ideb , ideba ! ! This routine uses a sort of Shellsort in a first pass ! trying to bring the set to the following form: ! {minimum} {X1 . . } {X4 . .} with X1 <= X4 ! then ! {minimum} {X1 X2 . } {X4 X5 .} with X2 <= X5 ! then sort each of the subsets, and then ! {minimum} {second minimum X2 X3 } {X4 X5 X6=maximum} with X2 <= X3 and !                                                           X4 <= X5 !  and lastly merge the two subsets. ! ! ndon = size ( xdont ) xwrkt = 0.0 ! Do ideb = 1 , ndon - 6 , 7 xwrk = xdont ( ideb ) ! !  First pair ! ideba = ideb + 1 If ( xdont ( ideba ) < xdont ( ideba + 3 )) Then xwrks = xdont ( ideba + 3 ) xwrki = xdont ( ideba ) Else xwrki = xdont ( ideba + 3 ) xwrks = xdont ( ideba ) End If If ( xwrki < xwrk ) Then If ( xwrks < xwrk ) Then xwrk1 = xwrks xwrk4 = xwrk Else xwrk1 = xwrk xwrk4 = xwrks End If xwrk = xwrki Else xwrk1 = xwrki xwrk4 = xwrks End If ! !  Second pair ! ideba = ideba + 1 If ( xdont ( ideba ) < xdont ( ideba + 3 )) Then xwrks = xdont ( ideba + 3 ) xwrki = xdont ( ideba ) Else xwrki = xdont ( ideba + 3 ) xwrks = xdont ( ideba ) End If If ( xwrki < xwrk ) Then xwrk2 = xwrk1 If ( xwrks < xwrk ) Then xwrk1 = xwrks xwrks = xwrk Else xwrk1 = xwrk End If xwrk = xwrki Else If ( xwrki >= xwrk1 ) Then xwrk2 = xwrki Else xwrk2 = xwrk1 xwrk1 = xwrki End If End If If ( xwrks >= xwrk4 ) Then xwrk5 = xwrks Else xwrk5 = xwrk4 xwrk4 = xwrks End If ! !  Third pair ! ideba = ideba + 1 If ( xdont ( ideba ) < xdont ( ideba + 3 )) Then xwrks = xdont ( ideba + 3 ) xwrki = xdont ( ideba ) Else xwrki = xdont ( ideba + 3 ) xwrks = xdont ( ideba ) End If If ( xwrki <= xwrk ) Then xwrk3 = xwrk2 xwrk2 = xwrk1 If ( xwrks < xwrk ) Then xwrk1 = xwrks xwrks = xwrk Else xwrk1 = xwrk End If xwrk = xwrki Else If ( xwrki >= xwrk2 ) Then xwrk3 = xwrki Else xwrk3 = xwrk2 If ( xwrki >= xwrk1 ) Then xwrk2 = xwrki Else xwrk2 = xwrk1 xwrk1 = xwrki End If End If End If If ( xwrks >= xwrk5 ) Then xwrk6 = xwrks Else xwrk6 = xwrk5 If ( xwrks >= xwrk4 ) Then xwrk5 = xwrks Else xwrk5 = xwrk4 xwrk4 = xwrks End If End If ! ! Merge the two subsets into their final location ! xwrkt ( ideb ) = xwrk xwrkt ( ideb + 1 ) = xwrk1 If ( xwrk4 >= xwrk3 ) Then xwrkt ( ideb + 2 ) = xwrk2 xwrkt ( ideb + 3 ) = xwrk3 xwrkt ( ideb + 4 ) = xwrk4 xwrkt ( ideb + 5 ) = xwrk5 Else If ( xwrk4 >= xwrk2 ) Then xwrkt ( ideb + 2 ) = xwrk2 xwrkt ( ideb + 3 ) = xwrk4 Else xwrkt ( ideb + 2 ) = xwrk4 xwrkt ( ideb + 3 ) = xwrk2 End If If ( xwrk3 <= xwrk5 ) Then xwrkt ( ideb + 4 ) = xwrk3 xwrkt ( ideb + 5 ) = xwrk5 Else xwrkt ( ideb + 4 ) = xwrk5 xwrkt ( ideb + 5 ) = xwrk3 End If End If xwrkt ( ideb + 6 ) = xwrk6 End Do End Subroutine newsub7","tags":"","loc":"sourcefile/sort7.f90.html"},{"title":"demo_fndnth.f90 – orderpack","text":"Contents Programs demo_fndnth Source Code demo_fndnth.f90 Source Code program demo_fndnth use M_fndnth , only : fndnth implicit none character ( len =* ), parameter :: sp = '(*(g0,1x))' integer , allocatable :: iarr (:) integer :: imiddle iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] print sp , 'ORIGINAL:' , iarr ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , fndnth ( iarr , 1 ), minval ( iarr ) print sp , 'maxval' , fndnth ( iarr , size ( iarr )), maxval ( iarr ) ! but more generally it can return the Nth lowest value. print sp , 'nord=' , 4 , ' fractile=' , fndnth ( iarr , 4 ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 print sp , 'median=' , fndnth ( iarr , imiddle ) end program demo_fndnth","tags":"","loc":"sourcefile/demo_fndnth.f90.html"},{"title":"demo_valnth.f90 – orderpack","text":"Contents Programs demo_valnth Source Code demo_valnth.f90 Source Code program demo_valnth use M_valnth , only : valnth implicit none character ( len =* ), parameter :: list = '(*(g0:,\", \"))' character ( len =* ), parameter :: sp = '(*(g0,1x))' real , parameter :: xdont ( * ) = [ 1.1 , 2 0.20 , 3.3 , 1 0.10 , 5.5 , 4.4 , 2.2 ] integer :: i integer :: imiddle write ( * , list ) 'ORIGINAL:' , xdont ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , valnth ( xdont , 1 ), minval ( xdont ) print sp , 'maxval' , valnth ( xdont , size ( xdont )), maxval ( xdont ) ! but more generally it can return the Nth lowest value. print sp , 'nord=' , 4 , ' fractile=' , valnth ( xdont , 4 ) ! so a value at the middle would be imiddle = ( size ( xdont ) + 1 ) / 2 print sp , 'median=' , valnth ( xdont , imiddle ) ! sorting the hard way do i = 1 , size ( xdont ) write ( * , list ) i , valnth ( xdont , i ) enddo end program demo_valnth","tags":"","loc":"sourcefile/demo_valnth.f90.html"},{"title":"demo_median.f90 – orderpack","text":"Contents Programs demo_median Source Code demo_median.f90 Source Code program demo_median use M_median , only : median implicit none real , allocatable :: xdont (:) integer :: ii xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] write ( * , * ) median ( xdont ) ! xdont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] write ( * , * ) median ( xdont ) ! xdont = [ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ] write ( * , * ) median ( xdont ) ! end program demo_median","tags":"","loc":"sourcefile/demo_median.f90.html"},{"title":"demo_rinpar.f90 – orderpack","text":"Contents Programs demo_rinpar Source Code demo_rinpar.f90 Source Code program demo_rinpar use M_rinpar , only : rinpar implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , xdont call rinpar ( xdont , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'SMALLEST VALUES:' , xdont ( irngt (: nord )) end program demo_rinpar","tags":"","loc":"sourcefile/demo_rinpar.f90.html"},{"title":"demo_ctrper.f90 – orderpack","text":"Contents Programs demo_ctrper Source Code demo_ctrper.f90 Source Code program demo_ctrper use M_ctrper , only : ctrper implicit none integer , allocatable :: xdont (:) integer , allocatable :: xout (:,:) real :: pcls integer :: isz , i , j isz = 200 if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) xdont = [( i , i = 1 , isz )] * 10 call ctrper ( xdont , 0.0 ) xout ( 1 ,:) = xdont xdont = [( i , i = 1 , isz )] * 10 call ctrper ( xdont , 0.1 ) xout ( 2 ,:) = xdont xdont = [( i , i = 1 , isz )] * 10 call ctrper ( xdont , 1.0 ) xout ( 3 ,:) = xdont write ( * , '(a)' ) 'count    unchanged  perturbed  random' do i = 1 , size ( xdont ) write ( * , '(*(i8,1x))' ) i , xout (:, i ) enddo end program demo_ctrper","tags":"","loc":"sourcefile/demo_ctrper.f90.html"},{"title":"demo_uniinv.f90 – orderpack","text":"Contents Programs demo_uniinv Source Code demo_uniinv.f90 Source Code program demo_uniinv use M_uniinv , only : uniinv implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) ! all values unique xdont = [ 0 , 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 , 99 ] xdont = xdont ( size ( xdont ): 1 : - 1 ) ! reverse it call printme () ! duplicate values xdont = [ - 1.0 , 0.0 , - 1.0 , 0.0 , - 1.0 , 0.0 , - 1.0 ] call printme () xdont = [ 1 0.0 , 5.0 , 7.0 , 1.0 , 4.0 , 5.0 , 6.0 , 8.0 , 9.0 , 1 0.0 , 1.0 ] call printme () xdont = [ 1 0.0 , 2 0.0 , 3 0.0 , 1 0.0 , 2 0.0 , 3 0.0 , 1 0.0 , 2 0.0 , 3 0.0 ] call printme () strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' ] call printme_char () strings = [ character ( len = 20 ) :: & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'brown' , 'brown' , 'gray' , 'green' , 'magenta' ] call printme_char () strings = [ 'purple' , 'purple' , 'purple' , 'purple' ] call printme_char () contains subroutine printme_char () integer , allocatable :: igoest (:) character ( len = 20 ), allocatable :: out (:) integer :: imx integer :: i integer :: isz isz = size ( strings ) write ( * , g ) 'Original:                 ' ,( trim ( strings ( i )), i = 1 , isz ) write ( * , g ) 'Number of indices to sort:' , isz if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( strings ))) call uniinv ( strings , igoest ) imx = maxval ( igoest ) write ( * , g ) 'Returned Indices:         ' , igoest (:) write ( * , g ) 'Number of unique indices :' , imx if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( strings ) out ( igoest ( i )) = strings ( i ) enddo write ( * , g ) 'Sorted unique values:     ' ,( trim ( out ( i )), i = 1 , size ( out )) write ( * , g ) end subroutine printme_char subroutine printme () integer , allocatable :: igoest (:) integer , allocatable :: out (:) integer :: imx integer :: i write ( * , g ) 'Original:                 ' , xdont write ( * , g ) 'Number of indices to sort:' , size ( xdont ) if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( xdont ))) call uniinv ( xdont , igoest ) imx = maxval ( igoest ) write ( * , g ) 'Returned Indices:         ' , igoest (:) write ( * , g ) 'Number of unique indices :' , imx if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( xdont ) out ( igoest ( i )) = xdont ( i ) enddo write ( * , g ) 'Sorted unique values:     ' , out write ( * , g ) end subroutine printme end program demo_uniinv","tags":"","loc":"sourcefile/demo_uniinv.f90.html"},{"title":"demo_unista.f90 – orderpack","text":"Contents Programs demo_unista Source Code demo_unista.f90 Source Code program demo_unista use M_unista , only : unista implicit none character ( len =* ), parameter :: list = '(*(g0:,\",\"))' real , allocatable :: xdont (:) integer :: nuni xdont = [ 4.4 , 3.3 , 3.3 , 3.3 , 2.2 , 1.1 , 3.3 , 4.4 , 5.5 , 3.3 ] print list , 'ORIGINAL:' , xdont print * call unista ( xdont , nuni ) xdont = xdont (: nuni ) print list , 'UNIQUE:' , xdont end program demo_unista","tags":"","loc":"sourcefile/demo_unista.f90.html"},{"title":"demo_rnkpar.f90 – orderpack","text":"Contents Programs demo_rnkpar Source Code demo_rnkpar.f90 Source Code program demo_rnkpar use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_rnkpar , only : rnkpar implicit none integer , parameter :: ivals = 300 real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real32 ) :: out ( ivals ) integer :: indx ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rnkpar ( valsr , indx , ivals ) out = valsr ( indx (: ivals )) do i = 1 , ivals - 1 if ( out ( i + 1 ). lt . out ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_rnkpar","tags":"","loc":"sourcefile/demo_rnkpar.f90.html"},{"title":"demo_refsor.f90 – orderpack","text":"Contents Programs demo_refsor Source Code demo_refsor.f90 Source Code program demo_refsor use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_refsor , only : refsor implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real64 ) :: valsd ( 2000 ) integer :: valsi ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) call random_number ( valsd ) valsi = int ( valsr * 100000 0.0 ) valsr = valsr * 100000 0.0 - 50000 0.0 valsd = valsd * 100000 0.0 - 50000 0.0 call refsor ( valsi ) do i = 1 , size ( valsi ) - 1 if ( valsi ( i + 1 ). lt . valsi ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo call refsor ( valsr ) do i = 1 , size ( valsr ) - 1 if ( valsr ( i + 1 ). lt . valsr ( i )) then write ( * , * ) 'not sorted' stop 2 endif enddo call refsor ( valsd ) do i = 1 , size ( valsd ) - 1 if ( valsd ( i + 1 ). lt . valsd ( i )) then write ( * , * ) 'not sorted' stop 3 endif enddo write ( * , * ) 'random arrays are now sorted' end program demo_refsor","tags":"","loc":"sourcefile/demo_refsor.f90.html"},{"title":"tstvalnth.f90 – orderpack","text":"Contents Programs chrono Source Code tstvalnth.f90 Source Code program chrono use M_valnth use M_mrgrnk Integer , Parameter :: nbcl = 10000 Integer , Parameter :: nth = 31 Integer , Parameter :: kdp = selected_real_kind ( 15 ) Real ( kind = kdp ), Dimension ( 5001 ) :: dvalt Real , Dimension ( 5001 ) :: xvalt Integer , Dimension ( 5001 ) :: jvalt Integer , Dimension ( 5001 ) :: jrnkt Integer , Dimension (:), Allocatable :: jseet Integer :: nsee , ibcl , lrnk , jres Real :: tdep1 , tdep2 , tfin1 , tfin2 Real :: xres Real ( kind = kdp ) :: dres ! Call random_seed ( size = nsee ) Allocate ( jseet ( 1 : nsee )) ! Call random_seed ( get = jseet ) !      write (unit=*, fmt=*) jseet ! Call cpu_time ( tdep1 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) jvalt = Nint ( 100 0.0 * xvalt ) End Do Call cpu_time ( tfin1 ) Call random_seed ( put = jseet ) Call cpu_time ( tdep2 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) jvalt = Nint ( 100 0.0 * xvalt ) lrnk = 10 + modulo ( ibcl , 10 ) jres = valnth ( jvalt , lrnk ) End Do Call cpu_time ( tfin2 ) write ( unit =* , fmt =* ) \"Integer: \" ,(( tfin2 - tdep2 ) - ( tfin1 - tdep1 )) * 100 0.0 / real ( nbcl ), \" ms\" Call random_seed ( put = jseet ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) jvalt = Nint ( 100 0.0 * xvalt ) lrnk = 10 + modulo ( ibcl , 10 ) jres = valnth ( jvalt , lrnk ) Call mrgrnk ( jvalt , jrnkt ) If ( jvalt ( jrnkt ( lrnk )) /= jres ) then write ( unit =* , fmt =* ) \"*** Check Failed\" write ( unit =* , fmt =* ) jvalt ( jrnkt ( lrnk )) write ( unit =* , fmt =* ) jres write ( unit =* , fmt =* ) ibcl , \"seed \" , jseet stop End If End Do ! Call random_seed ( put = jseet ) Call cpu_time ( tdep1 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) End Do Call cpu_time ( tfin1 ) Call random_seed ( put = jseet ) Call cpu_time ( tdep2 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) lrnk = 10 + modulo ( ibcl , 10 ) xres = valnth ( xvalt , lrnk ) End Do Call cpu_time ( tfin2 ) write ( unit =* , fmt =* ) \"Real:    \" ,(( tfin2 - tdep2 ) - ( tfin1 - tdep1 )) * 100 0.0 / real ( nbcl ), \" ms\" Call random_seed ( put = jseet ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) lrnk = 10 + modulo ( ibcl , 10 ) xres = valnth ( xvalt , lrnk ) Call mrgrnk ( xvalt , jrnkt ) If ( xvalt ( jrnkt ( lrnk )) /= xres ) then write ( unit =* , fmt =* ) \"*** Check Failed\" write ( unit =* , fmt =* ) xvalt ( jrnkt ( lrnk )) write ( unit =* , fmt =* ) xres write ( unit =* , fmt =* ) ibcl , \"seed \" , jseet stop End If End Do ! Call random_seed ( put = jseet ) Call cpu_time ( tdep1 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) dvalt = xvalt End Do Call cpu_time ( tfin1 ) Call random_seed ( put = jseet ) Call cpu_time ( tdep2 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) dvalt = xvalt lrnk = 10 + modulo ( ibcl , 10 ) dres = valnth ( dvalt , lrnk ) End Do Call cpu_time ( tfin2 ) write ( unit =* , fmt =* ) \"Double:  \" ,(( tfin2 - tdep2 ) - ( tfin1 - tdep1 )) * 100 0.0 / real ( nbcl ), \" ms\" Call random_seed ( put = jseet ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) dvalt = xvalt lrnk = 10 + modulo ( ibcl , 10 ) dres = valnth ( dvalt , lrnk ) Call mrgrnk ( dvalt , jrnkt ) If ( dvalt ( jrnkt ( lrnk )) /= dres ) then write ( unit =* , fmt =* ) \"*** Check Failed\" write ( unit =* , fmt =* ) dvalt ( jrnkt ( lrnk )) write ( unit =* , fmt =* ) dres write ( unit =* , fmt =* ) ibcl , \"seed \" , jseet stop End If End Do ! end program chrono","tags":"","loc":"sourcefile/tstvalnth.f90.html"},{"title":"demo_mrgrnk.f90 – orderpack","text":"Contents Programs demo_mrgrnk Source Code demo_mrgrnk.f90 Source Code program demo_mrgrnk use M_mrgrnk , only : mrgrnk implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call mrgrnk ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ); allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call mrgrnk ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_mrgrnk","tags":"","loc":"sourcefile/demo_mrgrnk.f90.html"},{"title":"givcor.f90 – orderpack","text":"Contents Programs givcor Source Code givcor.f90 Source Code program givcor !   Given two arrays of equal length of unordered values, find a !   \"matching value\" in the second array for each value in the !   first so that the global correlation coefficient reaches !   exactly a given target. ! _________________________________________________________________ !   The routine first sorts the two arrays, so as to get the !   match of maximum correlation. !   It then will iterate, applying the random permutation algorithm !   of controlled disorder ctrper to the second array. When the !   resulting correlation goes beyond (lower than) the target !   correlation, one steps back and reduces the disorder parameter !   of the permutation. When the resulting correlation lies between !   the current one and the target, one replaces the array with !   the newly permuted one. When the resulting correlation increases !   from the current value, one increases the disorder parameter. !   That way, the target correlation is approached from above, by !   a controlled increase in randomness. !   The example is two arrays representing parents' incomes and !   children's incomes, but where it is not known which parents !   correspond to which children. The output is a list of pairs !   {parents' income, children's income} such that the target !   correlation is approached. !   Michel Olagnon - December 2001. !   Corrected August 2007 (dot_product (xnewt, xpart) line 87, !             and negative correlation targets). ! _________________________________________________________________ use M_ctrper use M_refsor ! Integer , Parameter :: ndim = 21571 ! Number of pairs Integer , Parameter :: kdp = selected_real_kind ( 15 ) Real ( kind = kdp ), Parameter :: dtar = 0.1654_kdp ! Target correlation Real ( kind = kdp ) :: dsum , dref , dmoyp , dsigp , dmoyc , dsigc , dtarw Real ( kind = kdp ), Dimension ( ndim ) :: xpart , xchit , xnewt Real :: xper = 0.25 Real :: xdec = 0.997 Integer , Dimension (:), Allocatable :: jseet , jsavt Integer :: nsee , ibcl ! Call random_seed ( size = nsee ) Allocate ( jseet ( 1 : nsee ), jsavt ( 1 : nsee )) ! !   Read parent's incomes ! Open ( unit = 11 , file = \"parents.dat\" , form = \"formatted\" , status = \"old\" , action = \"read\" ) Do ibcl = 1 , ndim read ( unit = 11 , fmt =* ) xpart ( ibcl ) End Do Close ( unit = 11 ) ! !   Sort, and normalize to make further correlation computations faster ! call refsor ( xpart ) dmoyp = sum ( xpart ) / real ( ndim , kind = kdp ) xpart = xpart - dmoyp dsigp = sqrt ( dot_product ( xpart , xpart )) xpart = xpart * ( 1.0_kdp / dsigp ) ! !   Read children's incomes ! Open ( unit = 12 , file = \"children.dat\" , form = \"formatted\" , status = \"old\" , action = \"read\" ) Do ibcl = 1 , ndim read ( unit = 12 , fmt =* ) xchit ( ibcl ) End Do Close ( unit = 12 ) ! !   Sort, and normalize ! call refsor ( xchit ) dmoyc = sum ( xchit ) / real ( ndim , kind = kdp ) xchit = xchit - dmoyc dsigc = sqrt ( dot_product ( xchit , xchit )) if ( dtar < 0.0_kdp ) then xchit = - xchit * ( 1.0_kdp / dsigc ) else xchit = xchit * ( 1.0_kdp / dsigc ) endif dtarw = abs ( dtar ) ! !   Compute starting value, maximum correlation ! dref = dot_product ( xpart , xchit ) !      write (unit=*, fmt=\"(f8.6)\") dref ! !   Iterate ! Do ibcl = 1 , 100000 xnewt = xchit ! !   Add some randomness to the current order ! Call ctrper ( xnewt , xper ) dsum = dot_product ( xnewt , xpart ) !    if (modulo (ibcl,100) == 1) write (unit=*, fmt=*) ibcl, dref, dsum, xper ! !   Check for hit of target ! if ( abs ( dsum - dtarw ) < 0.00001_kdp ) then dref = dsum xchit = xnewt exit End If ! !   Better, but not yet reached target: take new set as current one ! if ( dsum < dref . and . dsum > dtarw ) then dref = dsum xchit = xnewt ! !   We went too far, beyond the target: try to be a little less random ! elseif ( dsum < dtarw ) then xper = max ( xper * xdec , 0.5 / Real ( ndim )) ! !   We are going in the ordered direction: try to be a little more random ! elseif ( dsum > dref ) then xper = min ( xper / xdec , 0.25 ) endif End Do ! !   Unnormalize and output pairs ! write ( unit =* , fmt = \"(a,f10.8,a,i8)\" ) \"Reached \" , dref , & \"after iteration \" , ibcl xpart = dmoyp + dsigp * xpart if ( dtar < 0.0_kdp ) then xchit = dmoyc - dsigc * xchit else xchit = dmoyc + dsigc * xchit endif Open ( unit = 13 , file = \"corchild.dat\" , form = \"formatted\" , status = \"unknown\" ,& action = \"write\" ) Do ibcl = 1 , ndim write ( unit = 13 , fmt =* ) nint ( xpart ( ibcl )), nint ( xchit ( ibcl )) End Do Close ( unit = 13 ) ! end program givcor","tags":"","loc":"sourcefile/givcor.f90.html"},{"title":"demo_unirnk.f90 – orderpack","text":"Contents Programs demo_unirnk Source Code demo_unirnk.f90 Source Code program demo_unirnk use M_unirnk , only : unirnk implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xvalt (:) ! xvalt = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] call printme () xvalt = [ - 1 , 0 , - 2 , 0 , - 3 , 0 , - 4 ] call printme () contains subroutine printme () integer , allocatable :: irngt (:) integer :: nuni if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( xvalt ))) write ( * , g ) 'ORIGINAL:' , xvalt call unirnk ( xvalt , irngt , nuni ) write ( * , g ) 'NUMBER OF UNIQUE INDICES:' , nuni write ( * , g ) 'RETURNED INDICES:' , irngt (: nuni ) write ( * , g ) 'SORTED DATA:' , xvalt ( irngt (: nuni )) end subroutine end program demo_unirnk","tags":"","loc":"sourcefile/demo_unirnk.f90.html"},{"title":"demo_unipar.f90 – orderpack","text":"Contents Programs demo_unipar Source Code demo_unipar.f90 Source Code program demo_unipar use M_unipar , only : unipar implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord ! write ( * , g ) 'If enough values are unique, will return NORD indices' if ( allocated ( irngt )) deallocate ( irngt ) xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) call printme () ! !BUG!write(*,g)'If not enough values are unique, will change NORD' !BUG!xdont=[-1,0,-1,0,-1,0,-1] !BUG!nord=5 !BUG!if(allocated(irngt))deallocate(irngt) !BUG!allocate(irngt(nord)) !BUG!call printme() contains subroutine printme () write ( * , g ) 'ORIGINAL:' , xdont write ( * , g ) 'NUMBER OF INDICES TO SORT:' , nord call unipar ( xdont , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES RETURNED:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt (: nord ) write ( * , g ) nord , 'SMALLEST UNIQUE VALUES:' , xdont ( irngt (: nord )) end subroutine end program demo_unipar","tags":"","loc":"sourcefile/demo_unipar.f90.html"},{"title":"demo_indmed.f90 – orderpack","text":"Contents Programs demo_indmed Source Code demo_indmed.f90 Source Code program demo_indmed use M_indmed , only : indmed implicit none real , allocatable :: xdont (:) character ( len = :), allocatable :: cdont (:) integer :: ii xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call indmed ( xdont , ii ) write ( * , * ) ii , xdont ( ii ) ! xdont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call indmed ( xdont , ii ) write ( * , * ) ii , xdont ( ii ) ! xdont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call indmed ( xdont , ii ) write ( * , * ) ii , xdont ( ii ) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' , 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call indmed ( cdont , ii ) write ( * , * ) ii , cdont ( ii ) ! end program demo_indmed","tags":"","loc":"sourcefile/demo_indmed.f90.html"},{"title":"demo_refpar.f90 – orderpack","text":"Contents Programs demo_refpar Source Code demo_refpar.f90 Source Code program demo_refpar use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_refpar , only : refpar implicit none real ( kind = real32 ) :: valsr ( 2000 ) integer :: indx ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call refpar ( valsr , indx , 300 ) valsr (: 300 ) = valsr ( indx (: 300 )) do i = 1 , 300 - 1 if ( valsr ( i + 1 ). lt . valsr ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_refpar","tags":"","loc":"sourcefile/demo_refpar.f90.html"},{"title":"demo_valmed.f90 – orderpack","text":"Contents Programs demo_valmed Source Code demo_valmed.f90 Source Code program demo_valmed use M_valmed , only : valmed implicit none real , parameter :: xdont ( * ) = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] real res_med write ( * , * ) valmed ( xdont ) write ( * , * ) valmed ([ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ]) write ( * , * ) valmed ([ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ]) end program demo_valmed","tags":"","loc":"sourcefile/demo_valmed.f90.html"},{"title":"follow.f90 – orderpack","text":"Contents Programs follow Source Code follow.f90 Source Code Program follow !  Question From Colin Thefleau: ! ! I have a small problem that my cloudy brain can't solve: ! Say I have a bunch of coordinates (realx(i), realy(i)) that form a circle ! (or any closed form) if every point is plotted. I have to sort them so that ! they \"ride\" the circle in one direction. For example beginning at one point ! (the highest point for example), and go in the clock drive direction. ! Has someone an idea how this is to be done?  Or where can I find a sample ! code for inspiration? I am really new to fortran and really can't find a ! solution. ! -------------------------------------------------------------------------- ! The following program is an attempt to answer that question for a ! \"reasonable\" profile. From the current point, it finds the \"nearest\" ! point in the set of remaining ones according to some weighted distance, ! weights penalizing the direction that one is coming from. ! integer , parameter :: nmax = 200 real , dimension ( nmax ) :: xptst , yptst , xtmpt , ytmpt , xrndt integer , dimension ( nmax ) :: irndt real :: t , xtmp , ytmp , xunt , yunt , xori , yori , xvec , yvec , wdst , wdst0 , & xlen , xang , xunt1 , yunt1 integer :: imin , imax , ipnt , inxt , itst ! !  take a continuous curve and make the order random ! call random_number ( xrndt ) call mrgrnk ( xrndt , irndt ) ! do ipnt = 1 , nmax t = 6.28318 * real ( ipnt ) / real ( nmax ) xtmpt ( ipnt ) = ( 5. + 2 * cos ( 4. * t )) * cos ( t ) ytmpt ( ipnt ) = - ( 5. + 2 * cos ( 4. * t )) * sin ( t ) enddo xptst = xtmpt ( irndt ) yptst = ytmpt ( irndt ) ! ! Bring starting point (Northmost) to first position ! imin = sum ( maxloc ( yptst )) xtmp = xptst ( 1 ) ytmp = yptst ( 1 ) xptst ( 1 ) = xptst ( imin ) yptst ( 1 ) = yptst ( imin ) xptst ( imin ) = xtmp yptst ( imin ) = ytmp ! ! unit vector in the current direction (east) ! xunt = 1. yunt = 0. ! ! Find next point in line ! nextpoint : do inxt = 2 , nmax - 1 xori = xptst ( inxt - 1 ) yori = yptst ( inxt - 1 ) wdst0 = huge ( wdst ) do itst = inxt , nmax xvec = xptst ( itst ) - xori yvec = yptst ( itst ) - yori xlen = sqrt ( xvec * xvec + yvec * yvec ) if ( xlen < epsilon ( 1.0 )) then imin = itst xunt1 = xunt yunt1 = xunt exit endif ! !  Compute distance, weighted by a cosine function of the angle !  with the last segment. Weight is 1 when straight ahead, !  3 when going backwards, 2 if transverse. By using some !  power of the cosine, one may increase or decrease the pressure !  to go straight ahead with respect to transverse directions. ! xang = acos ( 0.9999 * ( xvec * xunt + yvec * yunt ) / xlen ) wdst = xlen * ( 3.0 - 2.0 * cos ( 0.5 * xang )) ! !  Retain minimum distance ! if ( wdst <= wdst0 ) then wdst0 = wdst imin = itst xunt1 = xvec / xlen yunt1 = yvec / xlen endif enddo ! !  Exchange retained point with current one ! xtmp = xptst ( inxt ) ytmp = yptst ( inxt ) xptst ( inxt ) = xptst ( imin ) yptst ( inxt ) = yptst ( imin ) xptst ( imin ) = xtmp yptst ( imin ) = ytmp xunt = xunt1 yunt = yunt1 enddo nextpoint ! ! Output ! imax = sum ( maxloc ( ytmpt )) do ipnt = 1 , nmax write ( * , * ) ipnt , xptst ( ipnt ), yptst ( ipnt ), xtmpt ( imax ), ytmpt ( imax ) imax = mod ( imax , nmax ) + 1 enddo contains Subroutine MRGRNK ( XVALT , IRNGT ) ! __________________________________________________________ !   MRGRNK = Merge-sort ranking of an array !   For performance reasons, the first 2 passes are taken !   out of the standard loop, and use dedicated coding. ! __________________________________________________________ Real , Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind ( XVALT )) :: XVALA , XVALB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) <= XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Mod ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG1 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XVALT(IRNGT(JINDA)) <= XVALT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XVALT ( JWRKT ( IINDA )) XVALB = XVALT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XVALT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XVALT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return End Subroutine MRGRNK end Program follow","tags":"","loc":"sourcefile/follow.f90.html"},{"title":"demo_mulcnt.f90 – orderpack","text":"Contents Programs demo_mulcnt Source Code demo_mulcnt.f90 Source Code program demo_mulcnt use M_mulcnt , only : mulcnt implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' real , parameter :: xdont ( * ) = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 4 , 5 , 6 , 6 , 2 ] integer , dimension ( size ( xdont )) :: imult character ( len = 20 ), allocatable :: strings (:) ! call mulcnt ( xdont , imult ) write ( * , * ) xdont write ( * , g ) imult ! strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' ] call printme () ! strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] call printme () ! strings = [ 'purple' , 'purple' , 'purple' , 'purple' ] call printme () contains subroutine printme () integer , allocatable :: cindx (:) integer :: csz integer :: i csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call mulcnt ( strings , cindx ) write ( * , g )( trim ( strings ( i )), i = 1 , csz ) write ( * , g ) cindx end subroutine printme end program demo_mulcnt","tags":"","loc":"sourcefile/demo_mulcnt.f90.html"},{"title":"test_suite_orderpack.f90 – orderpack","text":"Contents Programs runtest Source Code test_suite_orderpack.f90 Source Code !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT program runtest use M_msg use M_msg , only : str use M_verify use M_verify , only : unit_check_level use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_stop ! full ranking use M_mrgref , only : mrgref use M_mrgrnk , only : mrgrnk ! full sorting use M_inssor , only : inssor use M_refsor , only : refsor use M_ctrper use M_fndnth use M_indmed use M_indnth use M_inspar use M_median use M_mulcnt use M_rapknr use M_refpar use M_rinpar use M_rnkpar use M_uniinv use M_unipar use M_unirnk use M_unista use M_valmed use M_valnth implicit none integer , parameter :: dp = kind ( 0.0d0 ) unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_gen ( 'mrgref' ) call test_gen ( 'mrgrnk' ) call test_gen ( 'inssor' ) call test_gen ( 'refsor' ) call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_gen ( name ) character ( len =* ), intent ( in ) :: name integer , parameter :: isz = 10000 real :: rr ( isz ) real ( kind = dp ) :: dd ( isz ) integer :: ii ( isz ) character ( len = 10 ) :: cc ( isz ) integer :: indx ( isz ) integer :: i call unit_check_start ( name , '-library orderpack' ) ! start tests CALL RANDOM_NUMBER ( RR ) rr = rr * huge ( 0.0 ) select case ( name ) case ( 'inssor' ); call inssor ( rr ) case ( 'refsor' ); call refsor ( rr ) case ( 'mrgrnk' ); call mrgrnk ( rr , indx ); rr = rr ( indx ) case ( 'mrgref' ); call mrgref ( rr , indx ); rr = rr ( indx ) endselect call unit_check ( name , all ( rr ( 1 : isz - 1 ) . le . rr ( 2 : isz )), 'real test' , isz , 'values' ) CALL RANDOM_NUMBER ( RR ) ii = rr * huge ( 0 ) select case ( name ) case ( 'inssor' ); call inssor ( ii ) case ( 'refsor' ); call refsor ( ii ) case ( 'mrgrnk' ); call mrgrnk ( ii , indx ); ii = ii ( indx ) case ( 'mrgref' ); call mrgref ( ii , indx ); ii = ii ( indx ) endselect call unit_check ( name , all ( ii ( 1 : isz - 1 ) . le . ii ( 2 : isz )), 'integer test' , isz , 'values' ) CALL RANDOM_NUMBER ( DD ) dd = dd * huge ( 0.0_dp ) select case ( name ) case ( 'inssor' ); call inssor ( dd ) case ( 'refsor' ); call refsor ( dd ) case ( 'mrgrnk' ); call mrgrnk ( dd , indx ); dd = dd ( indx ) case ( 'mrgref' ); call mrgref ( dd , indx ); dd = dd ( indx ) endselect call unit_check ( name , all ( dd ( 1 : isz - 1 ) . le . dd ( 2 : isz )), 'double test' , isz , 'values' ) do i = 1 , isz cc ( i ) = random_string ( 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 10 ) enddo select case ( name ) case ( 'inssor' ); call inssor ( cc ) case ( 'refsor' ); call refsor ( cc ) case ( 'mrgrnk' ); call mrgrnk ( cc , indx ); cc = cc ( indx ) case ( 'mrgref' ); call mrgref ( cc , indx ); cc = cc ( indx ) endselect call unit_check ( name , all ( cc ( 1 : isz - 1 ) . le . cc ( 2 : isz )), 'string test, random' , isz , 'values' ) call unit_check_done ( name , msg = 'test completed' ) end subroutine test_gen !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT function random_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","loc":"sourcefile/test_suite_orderpack.f90.html"},{"title":"test_mrgrnk.f90 – orderpack","text":"Contents Programs test_mrgrnk Source Code test_mrgrnk.f90 Source Code program test_mrgrnk use M_mrgrnk , only : mrgrnk implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 1000000 real ( kind = dp ), allocatable :: dd (:) real ( kind = dp ) :: pp integer , allocatable :: indx (:) integer :: i , j , k , m ! ! set up storage ! if ( allocated ( indx )) deallocate ( indx ) allocate ( indx ( isz )) if ( allocated ( dd )) deallocate ( dd ) allocate ( dd ( isz )) ! ! make some random numbers ! call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! ! sort data ! call mrgrnk ( dd , indx ) ! ! do some checks ! m = 0 do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , * ) 'ERROR: data not sorted i=' , i , 'indx=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) m = m + 1 endif enddo !do i=1,isz !   write(*,*)i,indx(i),dd(indx(i)) !enddo write ( * , * ) 'lowest                  ' , dd ( indx ( 1 )), minval ( dd ),& & dd ( indx ( 1 )). eq . minval ( dd ) write ( * , * ) 'highest                 ' , dd ( indx ( size ( indx ))), maxval ( dd ),& & dd ( indx ( size ( indx ))). eq . maxval ( dd ) write ( * , * ) 'smallest absolute value ' , minval ( abs ( dd )) write ( * , * ) 'huge                    ' , huge ( 0.0_dp ) write ( * , * ) 'tiny                    ' , tiny ( 0.0_dp ) if ( m . eq . 0 ) then write ( * , * ) 'sort passed' else write ( * , * ) 'sort failed, bad=' , m endif end program test_mrgrnk","tags":"","loc":"sourcefile/test_mrgrnk.f90.html"},{"title":"oldsub7 – orderpack","text":"subroutine oldsub7(xdont, xwrkt) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: xdont real, intent(out), Dimension (:) :: xwrkt Contents Variables icrs idcr ideb iwrk ndon xwrk xwrk1 Source Code oldsub7 Variables Type Visibility Attributes Name Initial integer, public :: icrs integer, public :: idcr integer, public :: ideb integer, public :: iwrk integer, public :: ndon real, public :: xwrk real, public :: xwrk1 Source Code Subroutine oldsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt End Subroutine oldsub7","tags":"","loc":"proc/oldsub7.html"},{"title":"newsub7 – orderpack","text":"subroutine newsub7(xdont, xwrkt) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: xdont real, intent(out), Dimension (:) :: xwrkt Contents Variables ideb ideba ndon xwrk xwrk1 xwrk2 xwrk3 xwrk4 xwrk5 xwrk6 xwrki xwrks Source Code newsub7 Variables Type Visibility Attributes Name Initial integer, public :: ideb integer, public :: ideba integer, public :: ndon real, public :: xwrk real, public :: xwrk1 real, public :: xwrk2 real, public :: xwrk3 real, public :: xwrk4 real, public :: xwrk5 real, public :: xwrk6 real, public :: xwrki real, public :: xwrks Source Code Subroutine newsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt End Subroutine newsub7","tags":"","loc":"proc/newsub7.html"},{"title":"mulcnt – orderpack","text":"public interface mulcnt Contents Module Procedures real64_mulcnt real32_mulcnt int32_mulcnt f_char_mulcnt Module Procedures private subroutine real64_mulcnt(XDONT, IMULT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT private subroutine real32_mulcnt(XDONT, IMULT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT private subroutine int32_mulcnt(XDONT, IMULT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT private subroutine f_char_mulcnt(XDONT, IMULT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT","tags":"","loc":"interface/mulcnt.html"},{"title":"unipar – orderpack","text":"public interface unipar Contents Module Procedures real64_unipar real32_unipar int32_unipar Module Procedures private subroutine real64_unipar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine real32_unipar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine int32_unipar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD","tags":"","loc":"interface/unipar.html"},{"title":"inssor – orderpack","text":"public interface inssor Contents Module Procedures real64_inssor real32_inssor int32_inssor f_char_inssor Module Procedures private subroutine real64_inssor(XDONT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT private subroutine real32_inssor(XDONT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT private subroutine int32_inssor(XDONT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT private subroutine f_char_inssor(XDONT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: XDONT","tags":"","loc":"interface/inssor.html"},{"title":"mrgref – orderpack","text":"public interface mrgref Contents Module Procedures real64_mrgref real32_mrgref int32_mrgref f_char_mrgref Module Procedures private subroutine real64_mrgref(XVALT, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgref(XVALT, IRNGT) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgref(XVALT, IRNGT) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgref(XVALT, IRNGT) Read more… Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"interface/mrgref.html"},{"title":"rinpar – orderpack","text":"public interface rinpar Contents Module Procedures real64_rinpar real32_rinpar int32_rinpar Module Procedures private subroutine real64_rinpar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rinpar(XDONT, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rinpar(XDONT, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/rinpar.html"},{"title":"mrgrnk – orderpack","text":"public interface mrgrnk Contents Module Procedures real64_mrgrnk real32_mrgrnk int32_mrgrnk f_char_mrgrnk Module Procedures private subroutine real64_mrgrnk(XDONT, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgrnk(XDONT, IRNGT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgrnk(XDONT, IRNGT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgrnk(XDONT, IRNGT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"interface/mrgrnk.html"},{"title":"median – orderpack","text":"public interface median Contents Module Procedures real64_median real32_median int32_median Module Procedures private function real64_median(XDONT) result(median) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT Return Value real(kind=real64) private function real32_median(XDONT) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT Return Value real(kind=real32) private function int32_median(XDONT) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT Return Value integer(kind=int32)","tags":"","loc":"interface/median.html"},{"title":"rapknr – orderpack","text":"public interface rapknr Contents Module Procedures real64_rapknr real32_rapknr int32_rapknr Module Procedures private subroutine real64_rapknr(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rapknr(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rapknr(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/rapknr.html"},{"title":"rnkpar – orderpack","text":"public interface rnkpar Contents Module Procedures real64_rnkpar real32_rnkpar int32_rnkpar Module Procedures private subroutine real64_rnkpar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rnkpar(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rnkpar(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/rnkpar.html"},{"title":"valmed – orderpack","text":"public interface valmed Contents Module Procedures real64_valmed real32_valmed int32_valmed Module Procedures private recursive function real64_valmed(XDONT) result(res_med) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT Return Value real(kind=real64) private recursive function real32_valmed(XDONT) result(res_med) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT Return Value real(kind=real32) private recursive function int32_valmed(XDONT) result(res_med) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT Return Value integer(kind=int32)","tags":"","loc":"interface/valmed.html"},{"title":"fndnth – orderpack","text":"public interface fndnth Contents Module Procedures real64_fndnth real32_fndnth int32_fndnth Module Procedures private function real64_fndnth(XDONT, NORD) result(FNDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real64) private function real32_fndnth(XDONT, NORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real32) private function int32_fndnth(XDONT, NORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer(kind=int32)","tags":"","loc":"interface/fndnth.html"},{"title":"indnth – orderpack","text":"public interface indnth Contents Module Procedures real64_indnth real32_indnth int32_indnth Module Procedures private function real64_indnth(XDONT, NORD) result(INDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer private function real32_indnth(XDONT, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer private function int32_indnth(XDONT, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer","tags":"","loc":"interface/indnth.html"},{"title":"ctrper – orderpack","text":"public interface ctrper Contents Module Procedures real64_ctrper real32_ctrper int32_ctrper Module Procedures private subroutine real64_ctrper(XDONT, PCLS) Permute array XDONT randomly, but leaving elements close to their\n   initial locations (nearbyness is controlled by PCLS). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT real, intent(in) :: PCLS private subroutine real32_ctrper(XDONT, PCLS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT real, intent(in) :: PCLS private subroutine int32_ctrper(XDONT, PCLS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT real, intent(in) :: PCLS","tags":"","loc":"interface/ctrper.html"},{"title":"uniinv – orderpack","text":"public interface uniinv Contents Module Procedures real64_uniinv real32_uniinv int32_uniinv f_char_uniinv Module Procedures private subroutine real64_uniinv(XDONT, IGOEST) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST private subroutine real32_uniinv(XDONT, IGOEST) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST private subroutine int32_uniinv(XDONT, IGOEST) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST private subroutine f_char_uniinv(XDONT, IGOEST) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST","tags":"","loc":"interface/uniinv.html"},{"title":"refsor – orderpack","text":"public interface refsor Contents Module Procedures real64_refsor real32_refsor int32_refsor f_char_refsor Module Procedures private subroutine real64_refsor(XDONT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT private subroutine real32_refsor(XDONT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT private subroutine int32_refsor(XDONT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT private subroutine f_char_refsor(XDONT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: XDONT","tags":"","loc":"interface/refsor.html"},{"title":"inspar – orderpack","text":"public interface inspar Contents Module Procedures real64_inspar real32_inspar int32_inspar Module Procedures private subroutine real64_inspar(XDONT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT integer, intent(in) :: NORD private subroutine real32_inspar(XDONT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT integer, intent(in) :: NORD private subroutine int32_inspar(XDONT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT integer, intent(in) :: NORD","tags":"","loc":"interface/inspar.html"},{"title":"refpar – orderpack","text":"public interface refpar Contents Module Procedures real64_refpar real32_refpar int32_refpar Module Procedures private subroutine real64_refpar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_refpar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_refpar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"interface/refpar.html"},{"title":"valnth – orderpack","text":"public interface valnth Contents Module Procedures real64_valnth real32_valnth int32_valnth Module Procedures private function real64_valnth(XDONT, NORD) result(valnth) Return NORDth value of XDONT, i.e fractile of order NORD/SIZE(XDONT). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real64) private function real32_valnth(XDONT, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real32) private function int32_valnth(XDONT, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer(kind=int32)","tags":"","loc":"interface/valnth.html"},{"title":"unista – orderpack","text":"public interface unista Contents Module Procedures real64_unista real32_unista int32_unista Module Procedures private subroutine real64_unista(XDONT, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT integer, intent(out) :: NUNI private subroutine real32_unista(XDONT, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT integer, intent(out) :: NUNI private subroutine int32_unista(XDONT, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT integer, intent(out) :: NUNI","tags":"","loc":"interface/unista.html"},{"title":"indmed – orderpack","text":"public interface indmed Contents Module Procedures real64_indmed real32_indmed int32_indmed f_char_indmed Module Procedures private subroutine real64_indmed(XDONT, INDM) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM private subroutine real32_indmed(XDONT, INDM) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM private subroutine int32_indmed(XDONT, INDM) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM private subroutine f_char_indmed(XDONT, INDM) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM","tags":"","loc":"interface/indmed.html"},{"title":"unirnk – orderpack","text":"public interface unirnk Contents Module Procedures real64_unirnk real32_unirnk int32_unirnk Module Procedures private subroutine real64_unirnk(XVALT, IRNGT, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine real32_unirnk(XVALT, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine int32_unirnk(XVALT, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI","tags":"","loc":"interface/unirnk.html"},{"title":"printme – orderpack","text":"subroutine printme(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Contents Variables ii Source Code printme Variables Type Visibility Attributes Name Initial integer, public :: ii Source Code subroutine printme ( n ) integer , intent ( in ) :: n integer :: ii ! ii = indnth ( iarr , n ) ! print sp , 'nord=' , n , ' index=' , ii , ' fractile=' , iarr ( ii ) end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"newsub7 – orderpack","text":"interface subroutine newsub7(xdont, xwrkt) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: xdont real, intent(out), Dimension (:) :: xwrkt","tags":"","loc":"interface/newsub7.html"},{"title":"oldsub7 – orderpack","text":"interface subroutine oldsub7(xdont, xwrkt) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: xdont real, intent(out), Dimension (:) :: xwrkt","tags":"","loc":"interface/oldsub7.html"},{"title":"printme – orderpack","text":"subroutine printme() Arguments None Contents Variables i igoest imx out Source Code printme Variables Type Visibility Attributes Name Initial integer, public :: i integer, public, allocatable :: igoest (:) integer, public :: imx integer, public, allocatable :: out (:) Source Code subroutine printme () integer , allocatable :: igoest (:) integer , allocatable :: out (:) integer :: imx integer :: i write ( * , g ) 'Original:                 ' , xdont write ( * , g ) 'Number of indices to sort:' , size ( xdont ) if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( xdont ))) call uniinv ( xdont , igoest ) imx = maxval ( igoest ) write ( * , g ) 'Returned Indices:         ' , igoest (:) write ( * , g ) 'Number of unique indices :' , imx if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( xdont ) out ( igoest ( i )) = xdont ( i ) enddo write ( * , g ) 'Sorted unique values:     ' , out write ( * , g ) end subroutine printme","tags":"","loc":"proc/printme~2.html"},{"title":"printme_char – orderpack","text":"subroutine printme_char() Arguments None Contents Variables i igoest imx isz out Source Code printme_char Variables Type Visibility Attributes Name Initial integer, public :: i integer, public, allocatable :: igoest (:) integer, public :: imx integer, public :: isz character(len=20), public, allocatable :: out (:) Source Code subroutine printme_char () integer , allocatable :: igoest (:) character ( len = 20 ), allocatable :: out (:) integer :: imx integer :: i integer :: isz isz = size ( strings ) write ( * , g ) 'Original:                 ' ,( trim ( strings ( i )), i = 1 , isz ) write ( * , g ) 'Number of indices to sort:' , isz if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( strings ))) call uniinv ( strings , igoest ) imx = maxval ( igoest ) write ( * , g ) 'Returned Indices:         ' , igoest (:) write ( * , g ) 'Number of unique indices :' , imx if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( strings ) out ( igoest ( i )) = strings ( i ) enddo write ( * , g ) 'Sorted unique values:     ' ,( trim ( out ( i )), i = 1 , size ( out )) write ( * , g ) end subroutine printme_char","tags":"","loc":"proc/printme_char.html"},{"title":"printme – orderpack","text":"subroutine printme() Arguments None Contents Variables irngt nuni Variables Type Visibility Attributes Name Initial integer, public, allocatable :: irngt (:) integer, public :: nuni","tags":"","loc":"proc/printme~3.html"},{"title":"printme – orderpack","text":"subroutine printme() Arguments None Contents None","tags":"","loc":"proc/printme~4.html"},{"title":"MRGRNK – orderpack","text":"subroutine MRGRNK(XVALT, IRNGT) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT Contents Variables IIND IINDA IINDB IRNG1 IRNG2 IWRK IWRKD IWRKF JINDA JWRKT LMTNA LMTNC NVAL XVALA XVALB Source Code MRGRNK Variables Type Visibility Attributes Name Initial integer, public :: IIND integer, public :: IINDA integer, public :: IINDB integer, public :: IRNG1 integer, public :: IRNG2 integer, public :: IWRK integer, public :: IWRKD integer, public :: IWRKF integer, public :: JINDA integer, public, Dimension (SIZE(IRNGT)) :: JWRKT integer, public :: LMTNA integer, public :: LMTNC integer, public :: NVAL real(kind=Kind(XVALT)), public :: XVALA real(kind=Kind(XVALT)), public :: XVALB Source Code Subroutine MRGRNK ( XVALT , IRNGT ) ! __________________________________________________________ !   MRGRNK = Merge-sort ranking of an array !   For performance reasons, the first 2 passes are taken !   out of the standard loop, and use dedicated coding. ! __________________________________________________________ Real , Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind ( XVALT )) :: XVALA , XVALB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) <= XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Mod ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG1 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XVALT(IRNGT(JINDA)) <= XVALT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XVALT ( JWRKT ( IINDA )) XVALB = XVALT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XVALT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XVALT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return End Subroutine MRGRNK","tags":"","loc":"proc/mrgrnk.html"},{"title":"printme – orderpack","text":"subroutine printme() Arguments None Contents Variables cindx csz i Source Code printme Variables Type Visibility Attributes Name Initial integer, public, allocatable :: cindx (:) integer, public :: csz integer, public :: i Source Code subroutine printme () integer , allocatable :: cindx (:) integer :: csz integer :: i csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call mulcnt ( strings , cindx ) write ( * , g )( trim ( strings ( i )), i = 1 , csz ) write ( * , g ) cindx end subroutine printme","tags":"","loc":"proc/printme~5.html"},{"title":"random_string – orderpack","text":"function random_string(chars, length) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(in) :: length Return Value character(len=:),allocatable Contents Variables i ilen which x Source Code random_string Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ilen integer, public :: which real, public :: x Source Code function random_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_string","tags":"","loc":"proc/random_string.html"},{"title":"test_gen – orderpack","text":"subroutine test_gen(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Contents Variables cc dd i ii indx isz rr Source Code test_gen Variables Type Visibility Attributes Name Initial character(len=10), public :: cc (isz) real(kind=dp), public :: dd (isz) integer, public :: i integer, public :: ii (isz) integer, public :: indx (isz) integer, public, parameter :: isz = 10000 real, public :: rr (isz) Source Code subroutine test_gen ( name ) character ( len =* ), intent ( in ) :: name integer , parameter :: isz = 10000 real :: rr ( isz ) real ( kind = dp ) :: dd ( isz ) integer :: ii ( isz ) character ( len = 10 ) :: cc ( isz ) integer :: indx ( isz ) integer :: i call unit_check_start ( name , '-library orderpack' ) ! start tests CALL RANDOM_NUMBER ( RR ) rr = rr * huge ( 0.0 ) select case ( name ) case ( 'inssor' ); call inssor ( rr ) case ( 'refsor' ); call refsor ( rr ) case ( 'mrgrnk' ); call mrgrnk ( rr , indx ); rr = rr ( indx ) case ( 'mrgref' ); call mrgref ( rr , indx ); rr = rr ( indx ) endselect call unit_check ( name , all ( rr ( 1 : isz - 1 ) . le . rr ( 2 : isz )), 'real test' , isz , 'values' ) CALL RANDOM_NUMBER ( RR ) ii = rr * huge ( 0 ) select case ( name ) case ( 'inssor' ); call inssor ( ii ) case ( 'refsor' ); call refsor ( ii ) case ( 'mrgrnk' ); call mrgrnk ( ii , indx ); ii = ii ( indx ) case ( 'mrgref' ); call mrgref ( ii , indx ); ii = ii ( indx ) endselect call unit_check ( name , all ( ii ( 1 : isz - 1 ) . le . ii ( 2 : isz )), 'integer test' , isz , 'values' ) CALL RANDOM_NUMBER ( DD ) dd = dd * huge ( 0.0_dp ) select case ( name ) case ( 'inssor' ); call inssor ( dd ) case ( 'refsor' ); call refsor ( dd ) case ( 'mrgrnk' ); call mrgrnk ( dd , indx ); dd = dd ( indx ) case ( 'mrgref' ); call mrgref ( dd , indx ); dd = dd ( indx ) endselect call unit_check ( name , all ( dd ( 1 : isz - 1 ) . le . dd ( 2 : isz )), 'double test' , isz , 'values' ) do i = 1 , isz cc ( i ) = random_string ( 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 10 ) enddo select case ( name ) case ( 'inssor' ); call inssor ( cc ) case ( 'refsor' ); call refsor ( cc ) case ( 'mrgrnk' ); call mrgrnk ( cc , indx ); cc = cc ( indx ) case ( 'mrgref' ); call mrgref ( cc , indx ); cc = cc ( indx ) endselect call unit_check ( name , all ( cc ( 1 : isz - 1 ) . le . cc ( 2 : isz )), 'string test, random' , isz , 'values' ) call unit_check_done ( name , msg = 'test completed' ) end subroutine test_gen","tags":"","loc":"proc/test_gen.html"},{"title":"M_mulcnt – orderpack","text":"Uses iso_fortran_env M_uniinv Contents Variables f_char Interfaces mulcnt Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface mulcnt private subroutine real64_mulcnt(XDONT, IMULT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT private subroutine real32_mulcnt(XDONT, IMULT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT private subroutine int32_mulcnt(XDONT, IMULT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT private subroutine f_char_mulcnt(XDONT, IMULT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IMULT","tags":"","loc":"module/m_mulcnt.html"},{"title":"M_unipar – orderpack","text":"Uses iso_fortran_env Contents Interfaces unipar Interfaces public interface unipar private subroutine real64_unipar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine real32_unipar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD private subroutine int32_unipar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(inout) :: NORD","tags":"","loc":"module/m_unipar.html"},{"title":"M_inssor – orderpack","text":"Uses iso_fortran_env Contents Variables f_char Interfaces inssor Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface inssor private subroutine real64_inssor(XDONT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT private subroutine real32_inssor(XDONT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT private subroutine int32_inssor(XDONT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT private subroutine f_char_inssor(XDONT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: XDONT","tags":"","loc":"module/m_inssor.html"},{"title":"M_mrgref – orderpack","text":"Uses iso_fortran_env Contents Interfaces mrgref Interfaces public interface mrgref private subroutine real64_mrgref(XVALT, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgref(XVALT, IRNGT) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgref(XVALT, IRNGT) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgref(XVALT, IRNGT) Read more… Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"module/m_mrgref.html"},{"title":"M_rinpar – orderpack","text":"Uses iso_fortran_env Contents Interfaces rinpar Interfaces public interface rinpar private subroutine real64_rinpar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rinpar(XDONT, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rinpar(XDONT, IRNGT, NORD) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_rinpar.html"},{"title":"M_mrgrnk – orderpack","text":"Uses iso_fortran_env Contents Interfaces mrgrnk Interfaces public interface mrgrnk private subroutine real64_mrgrnk(XDONT, IRNGT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT private subroutine real32_mrgrnk(XDONT, IRNGT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT private subroutine int32_mrgrnk(XDONT, IRNGT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT private subroutine f_char_mrgrnk(XDONT, IRNGT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT","tags":"","loc":"module/m_mrgrnk.html"},{"title":"M_median – orderpack","text":"Uses iso_fortran_env Contents Interfaces median Interfaces public interface median private function real64_median(XDONT) result(median) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT Return Value real(kind=real64) private function real32_median(XDONT) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT Return Value real(kind=real32) private function int32_median(XDONT) result(median) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT Return Value integer(kind=int32)","tags":"","loc":"module/m_median.html"},{"title":"M_rapknr – orderpack","text":"Uses iso_fortran_env Contents Interfaces rapknr Interfaces public interface rapknr private subroutine real64_rapknr(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rapknr(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rapknr(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_rapknr.html"},{"title":"M_rnkpar – orderpack","text":"Uses iso_fortran_env Contents Interfaces rnkpar Interfaces public interface rnkpar private subroutine real64_rnkpar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_rnkpar(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_rnkpar(XDONT, IRNGT, NORD) !!!           CASE DEFAULT\n!!!              write ( , ) “Assertion failed”\n!!!              STOP Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_rnkpar.html"},{"title":"M_valmed – orderpack","text":"Uses iso_fortran_env Contents Interfaces valmed Interfaces public interface valmed private recursive function real64_valmed(XDONT) result(res_med) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT Return Value real(kind=real64) private recursive function real32_valmed(XDONT) result(res_med) Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT Return Value real(kind=real32) private recursive function int32_valmed(XDONT) result(res_med) Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT Return Value integer(kind=int32)","tags":"","loc":"module/m_valmed.html"},{"title":"M_fndnth – orderpack","text":"Uses iso_fortran_env Contents Variables f_char Interfaces fndnth Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface fndnth private function real64_fndnth(XDONT, NORD) result(FNDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real64) private function real32_fndnth(XDONT, NORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real32) private function int32_fndnth(XDONT, NORD) result(FNDNTH) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer(kind=int32)","tags":"","loc":"module/m_fndnth.html"},{"title":"M_indnth – orderpack","text":"Uses iso_fortran_env Contents Variables f_char Interfaces indnth Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface indnth private function real64_indnth(XDONT, NORD) result(INDNTH) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer private function real32_indnth(XDONT, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer private function int32_indnth(XDONT, NORD) result(INDNTH) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer","tags":"","loc":"module/m_indnth.html"},{"title":"M_ctrper – orderpack","text":"Uses M_mrgrnk iso_fortran_env Contents Interfaces ctrper Interfaces public interface ctrper private subroutine real64_ctrper(XDONT, PCLS) Permute array XDONT randomly, but leaving elements close to their\n   initial locations (nearbyness is controlled by PCLS). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT real, intent(in) :: PCLS private subroutine real32_ctrper(XDONT, PCLS) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT real, intent(in) :: PCLS private subroutine int32_ctrper(XDONT, PCLS) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT real, intent(in) :: PCLS","tags":"","loc":"module/m_ctrper.html"},{"title":"M_uniinv – orderpack","text":"Uses iso_fortran_env Contents Variables f_char Interfaces uniinv Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface uniinv private subroutine real64_uniinv(XDONT, IGOEST) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST private subroutine real32_uniinv(XDONT, IGOEST) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST private subroutine int32_uniinv(XDONT, IGOEST) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST private subroutine f_char_uniinv(XDONT, IGOEST) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IGOEST","tags":"","loc":"module/m_uniinv.html"},{"title":"M_refsor – orderpack","text":"Uses iso_fortran_env Contents Variables f_char Interfaces refsor Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface refsor private subroutine real64_refsor(XDONT) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT private subroutine real32_refsor(XDONT) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT private subroutine int32_refsor(XDONT) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT private subroutine f_char_refsor(XDONT) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(inout), Dimension (:) :: XDONT","tags":"","loc":"module/m_refsor.html"},{"title":"M_inspar – orderpack","text":"Uses iso_fortran_env Contents Interfaces inspar Interfaces public interface inspar private subroutine real64_inspar(XDONT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT integer, intent(in) :: NORD private subroutine real32_inspar(XDONT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT integer, intent(in) :: NORD private subroutine int32_inspar(XDONT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT integer, intent(in) :: NORD","tags":"","loc":"module/m_inspar.html"},{"title":"M_refpar – orderpack","text":"Uses iso_fortran_env Contents Interfaces refpar Interfaces public interface refpar private subroutine real64_refpar(XDONT, IRNGT, NORD) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine real32_refpar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD private subroutine int32_refpar(XDONT, IRNGT, NORD) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out), Dimension (:) :: IRNGT integer, intent(in) :: NORD","tags":"","loc":"module/m_refpar.html"},{"title":"M_valnth – orderpack","text":"Uses iso_fortran_env Contents Variables f_char Interfaces valnth Variables Type Visibility Attributes Name Initial integer, public, parameter :: f_char = selected_char_kind(\"DEFAULT\") Interfaces public interface valnth private function real64_valnth(XDONT, NORD) result(valnth) Return NORDth value of XDONT, i.e fractile of order NORD/SIZE(XDONT). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real64) private function real32_valnth(XDONT, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value real(kind=real32) private function int32_valnth(XDONT, NORD) result(valnth) !!!           CASE DEFAULT\n!!!              write (unit= ,fmt= ) “Assertion failed”\n!!!              STOP Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(in) :: NORD Return Value integer(kind=int32)","tags":"","loc":"module/m_valnth.html"},{"title":"M_unista – orderpack","text":"Uses iso_fortran_env M_uniinv Contents Interfaces unista Interfaces public interface unista private subroutine real64_unista(XDONT, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), Dimension (:) :: XDONT integer, intent(out) :: NUNI private subroutine real32_unista(XDONT, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), Dimension (:) :: XDONT integer, intent(out) :: NUNI private subroutine int32_unista(XDONT, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), Dimension (:) :: XDONT integer, intent(out) :: NUNI","tags":"","loc":"module/m_unista.html"},{"title":"M_indmed – orderpack","text":"Uses iso_fortran_env Contents Interfaces indmed Interfaces public interface indmed private subroutine real64_indmed(XDONT, INDM) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM private subroutine real32_indmed(XDONT, INDM) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM private subroutine int32_indmed(XDONT, INDM) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM private subroutine f_char_indmed(XDONT, INDM) Arguments Type Intent Optional Attributes Name character(kind=f_char,len=*), intent(in), Dimension (:) :: XDONT integer, intent(out) :: INDM","tags":"","loc":"module/m_indmed.html"},{"title":"M_unirnk – orderpack","text":"Uses iso_fortran_env Contents Interfaces unirnk Interfaces public interface unirnk private subroutine real64_unirnk(XVALT, IRNGT, NUNI) Sample program: Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine real32_unirnk(XVALT, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI private subroutine int32_unirnk(XVALT, IRNGT, NUNI) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT integer, intent(out) :: NUNI","tags":"","loc":"module/m_unirnk.html"},{"title":"demo_rapknr – orderpack","text":"Uses M_rapknr Contents Variables g irngt nord xdont Source Code demo_rapknr Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: irngt (:) integer :: nord integer, allocatable :: xdont (:) Source Code program demo_rapknr use M_rapknr , only : rapknr implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , xdont call rapknr ( xdont , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'MAXIMUM VALUES:' , xdont ( irngt (: nord )) end program demo_rapknr","tags":"","loc":"program/demo_rapknr.html"},{"title":"demo_indnth – orderpack","text":"Uses M_indnth Contents Variables i iarr list sp Subroutines printme Source Code demo_indnth Variables Type Attributes Name Initial integer :: i integer, allocatable :: iarr (:) character(len=*), parameter :: list = '(*(g0:,\", \"))' character(len=*), parameter :: sp = '(*(g0,1x))' Subroutines subroutine printme (n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Source Code program demo_indnth ! find Nth lowest value in an array without sorting entire array use M_indnth , only : indnth implicit none integer , allocatable :: iarr (:) character ( len =* ), parameter :: list = '(*(g0:,\", \"))' , sp = '(*(g0,1x))' integer :: i iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 , 0 , - 100 ] print list , 'ORIGINAL:' , iarr ! like minloc() and maxloc() print sp , 'minloc' , indnth ( iarr , 1 ), minloc ( iarr ) print sp , 'maxloc' , indnth ( iarr , size ( iarr )), maxloc ( iarr ) ! but more general so can find location of the Nth lowest value ... call printme ( 3 ) ! find location of Nth lowest value call printme ( 1 ) call printme ( 7 ) ! sort the hard way, one value at a time do i = 1 , size ( iarr ) write ( * , sp , advance = 'no' ) iarr ( indnth ( iarr , i )) enddo print * contains subroutine printme ( n ) integer , intent ( in ) :: n integer :: ii ! ii = indnth ( iarr , n ) ! print sp , 'nord=' , n , ' index=' , ii , ' fractile=' , iarr ( ii ) end subroutine printme end program demo_indnth","tags":"","loc":"program/demo_indnth.html"},{"title":"demo_mrgref – orderpack","text":"Uses M_mrgref Contents Variables cindx dd dp g i indx isz j k pp strings Source Code demo_mrgref Variables Type Attributes Name Initial integer, allocatable :: cindx (:) real(kind=dp) :: dd (isz) integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: indx (isz) integer, parameter :: isz = 10000 integer :: j integer :: k real(kind=dp) :: pp character(len=:), allocatable :: strings (:) Source Code program demo_mrgref use M_mrgref , only : mrgref implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call mrgref ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ); allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call mrgref ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_mrgref","tags":"","loc":"program/demo_mrgref.html"},{"title":"demo_inssor – orderpack","text":"Uses iso_fortran_env M_inssor Contents Variables i valsd valsi valsr Source Code demo_inssor Variables Type Attributes Name Initial integer :: i real(kind=real64) :: valsd (2000) integer :: valsi (2000) real(kind=real32) :: valsr (2000) Source Code program demo_inssor use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_inssor , only : inssor implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real64 ) :: valsd ( 2000 ) integer :: valsi ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) call random_number ( valsd ) valsi = int ( valsr * 100000 0.0 ) valsr = valsr * 100000 0.0 - 50000 0.0 valsd = valsd * 100000 0.0 - 50000 0.0 call inssor ( valsi ) do i = 1 , size ( valsi ) - 1 if ( valsi ( i + 1 ). lt . valsi ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo call inssor ( valsr ) do i = 1 , size ( valsr ) - 1 if ( valsr ( i + 1 ). lt . valsr ( i )) then write ( * , * ) 'not sorted' stop 2 endif enddo call inssor ( valsd ) do i = 1 , size ( valsd ) - 1 if ( valsd ( i + 1 ). lt . valsd ( i )) then write ( * , * ) 'not sorted' stop 3 endif enddo write ( * , * ) 'random arrays are now sorted' end program demo_inssor","tags":"","loc":"program/demo_inssor.html"},{"title":"sort7 – orderpack","text":"Contents Variables i1 i2 i3 i4 i5 i6 ival x1 x2 x3 x4 x5 x6 x7 xval1t xval2t xval3t xval4t xval5t xval6t xval7t xvalt xwrkt Interfaces newsub7 oldsub7 Source Code sort7 Variables Type Attributes Name Initial integer :: i1 integer :: i2 integer :: i3 integer :: i4 integer :: i5 integer :: i6 integer :: ival real :: x1 real :: x2 real :: x3 real :: x4 real :: x5 real :: x6 real :: x7 real, Dimension (1) :: xval1t real, Dimension (2) :: xval2t real, Dimension (3) :: xval3t real, Dimension (4) :: xval4t real, Dimension (5) :: xval5t real, Dimension (6) :: xval6t real, Dimension (7) :: xval7t real, Dimension (35280) :: xvalt real, Dimension (35280) :: xwrkt Interfaces interface subroutine newsub7(xdont, xwrkt) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: xdont real, intent(out), Dimension (:) :: xwrkt interface subroutine oldsub7(xdont, xwrkt) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: xdont real, intent(out), Dimension (:) :: xwrkt Source Code Program sort7 ! ! This program is used to compare 2 algorithms for sorting ! every successive subset of 7 elements in an array. ! It shows how to call a subroutine with the correct interface ! block in the main program. Interfaces for ORDERPACK routines ! can be found in file interfaces.f90 ! Interface Subroutine oldsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt End Subroutine oldsub7 Subroutine newsub7 ( xdont , xwrkt ) Real , Dimension (:), Intent ( In ) :: xdont Real , Dimension (:), Intent ( Out ) :: xwrkt End Subroutine newsub7 End Interface ! Real , Dimension ( 35280 ) :: xvalt Real , Dimension ( 35280 ) :: xwrkt Real , Dimension ( 7 ) :: xval7t Real , Dimension ( 6 ) :: xval6t Real , Dimension ( 5 ) :: xval5t Real , Dimension ( 4 ) :: xval4t Real , Dimension ( 3 ) :: xval3t Real , Dimension ( 2 ) :: xval2t Real , Dimension ( 1 ) :: xval1t Real :: x1 , x2 , x3 , x4 , x5 , x6 , x7 Integer :: i1 , i2 , i3 , i4 , i5 , i6 , ival ! ! generate all 5040 possible permutations of elements 1,...,7 ! xval7t = ( / 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 / ) ival = 0 Do i1 = 1 , 7 x1 = xval7t ( i1 ) xval6t = pack ( xval7t , ( xval7t /= x1 )) Do i2 = 1 , 6 x2 = xval6t ( i2 ) xval5t = pack ( xval6t , ( xval6t /= x2 )) Do i3 = 1 , 5 x3 = xval5t ( i3 ) xval4t = pack ( xval5t , ( xval5t /= x3 )) Do i4 = 1 , 4 x4 = xval4t ( i4 ) xval3t = pack ( xval4t , ( xval4t /= x4 )) Do i5 = 1 , 3 x5 = xval3t ( i5 ) xval2t = pack ( xval3t , ( xval3t /= x5 )) Do i6 = 1 , 2 x6 = xval2t ( i6 ) xval1t = pack ( xval2t , ( xval2t /= x6 )) x7 = xval1t ( 1 ) xvalt ( ival + 1 : ival + 7 ) = ( / x1 , x2 , x3 , x4 , x5 , & & x6 , x7 / ) ival = ival + 7 End Do End Do End Do End Do End Do End Do Call newsub7 ( xvalt , xwrkt ) Do i1 = 1 , 35280 , 7 If ( any ( xwrkt ( i1 : i1 + 6 ) /= xval7t )) Then Write ( * , * ) \"newsub KO\" , i1 , xwrkt ( i1 : i1 + 6 ) Exit End If End Do Call oldsub7 ( xvalt , xwrkt ) Do i1 = 1 , 35280 , 7 If ( any ( xwrkt ( i1 : i1 + 6 ) /= xval7t )) Then Write ( * , * ) \"oldsub KO\" , i1 , xwrkt ( i1 : i1 + 6 ) End If End Do End Program sort7","tags":"","loc":"program/sort7.html"},{"title":"demo_fndnth – orderpack","text":"Uses M_fndnth Contents Variables iarr imiddle sp Source Code demo_fndnth Variables Type Attributes Name Initial integer, allocatable :: iarr (:) integer :: imiddle character(len=*), parameter :: sp = '(*(g0,1x))' Source Code program demo_fndnth use M_fndnth , only : fndnth implicit none character ( len =* ), parameter :: sp = '(*(g0,1x))' integer , allocatable :: iarr (:) integer :: imiddle iarr = [ 80 , 70 , 30 , 40 , 50 , 60 , 20 , 10 ] print sp , 'ORIGINAL:' , iarr ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , fndnth ( iarr , 1 ), minval ( iarr ) print sp , 'maxval' , fndnth ( iarr , size ( iarr )), maxval ( iarr ) ! but more generally it can return the Nth lowest value. print sp , 'nord=' , 4 , ' fractile=' , fndnth ( iarr , 4 ) ! so a value at the middle would be imiddle = ( size ( iarr ) + 1 ) / 2 print sp , 'median=' , fndnth ( iarr , imiddle ) end program demo_fndnth","tags":"","loc":"program/demo_fndnth.html"},{"title":"demo_valnth – orderpack","text":"Uses M_valnth Contents Variables i imiddle list sp xdont Source Code demo_valnth Variables Type Attributes Name Initial integer :: i integer :: imiddle character(len=*), parameter :: list = '(*(g0:,\", \"))' character(len=*), parameter :: sp = '(*(g0,1x))' real, parameter :: xdont (*) = [1.1, 20.20, 3.3, 10.10, 5.5, 4.4, 2.2] Source Code program demo_valnth use M_valnth , only : valnth implicit none character ( len =* ), parameter :: list = '(*(g0:,\", \"))' character ( len =* ), parameter :: sp = '(*(g0,1x))' real , parameter :: xdont ( * ) = [ 1.1 , 2 0.20 , 3.3 , 1 0.10 , 5.5 , 4.4 , 2.2 ] integer :: i integer :: imiddle write ( * , list ) 'ORIGINAL:' , xdont ! can return the same values as intrinsics minval() and maxval() print sp , 'minval' , valnth ( xdont , 1 ), minval ( xdont ) print sp , 'maxval' , valnth ( xdont , size ( xdont )), maxval ( xdont ) ! but more generally it can return the Nth lowest value. print sp , 'nord=' , 4 , ' fractile=' , valnth ( xdont , 4 ) ! so a value at the middle would be imiddle = ( size ( xdont ) + 1 ) / 2 print sp , 'median=' , valnth ( xdont , imiddle ) ! sorting the hard way do i = 1 , size ( xdont ) write ( * , list ) i , valnth ( xdont , i ) enddo end program demo_valnth","tags":"","loc":"program/demo_valnth.html"},{"title":"demo_median – orderpack","text":"Uses M_median Contents Variables ii xdont Source Code demo_median Variables Type Attributes Name Initial integer :: ii real, allocatable :: xdont (:) Source Code program demo_median use M_median , only : median implicit none real , allocatable :: xdont (:) integer :: ii xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] write ( * , * ) median ( xdont ) ! xdont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] write ( * , * ) median ( xdont ) ! xdont = [ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ] write ( * , * ) median ( xdont ) ! end program demo_median","tags":"","loc":"program/demo_median.html"},{"title":"demo_rinpar – orderpack","text":"Uses M_rinpar Contents Variables g irngt nord xdont Source Code demo_rinpar Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: irngt (:) integer :: nord integer, allocatable :: xdont (:) Source Code program demo_rinpar use M_rinpar , only : rinpar implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) write ( * , g ) 'ORIGINAL:' , xdont call rinpar ( xdont , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES TO RETURN:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt write ( * , g ) nord , 'SMALLEST VALUES:' , xdont ( irngt (: nord )) end program demo_rinpar","tags":"","loc":"program/demo_rinpar.html"},{"title":"demo_ctrper – orderpack","text":"Uses M_ctrper Contents Variables i isz j pcls xdont xout Source Code demo_ctrper Variables Type Attributes Name Initial integer :: i integer :: isz integer :: j real :: pcls integer, allocatable :: xdont (:) integer, allocatable :: xout (:,:) Source Code program demo_ctrper use M_ctrper , only : ctrper implicit none integer , allocatable :: xdont (:) integer , allocatable :: xout (:,:) real :: pcls integer :: isz , i , j isz = 200 if ( allocated ( xout )) deallocate ( xout ) allocate ( xout ( 3 , isz )) xdont = [( i , i = 1 , isz )] * 10 call ctrper ( xdont , 0.0 ) xout ( 1 ,:) = xdont xdont = [( i , i = 1 , isz )] * 10 call ctrper ( xdont , 0.1 ) xout ( 2 ,:) = xdont xdont = [( i , i = 1 , isz )] * 10 call ctrper ( xdont , 1.0 ) xout ( 3 ,:) = xdont write ( * , '(a)' ) 'count    unchanged  perturbed  random' do i = 1 , size ( xdont ) write ( * , '(*(i8,1x))' ) i , xout (:, i ) enddo end program demo_ctrper","tags":"","loc":"program/demo_ctrper.html"},{"title":"demo_uniinv – orderpack","text":"Uses M_uniinv Contents Variables cindx g strings xdont Subroutines printme printme_char Source Code demo_uniinv Variables Type Attributes Name Initial integer, allocatable :: cindx (:) character(len=*), parameter :: g = '(*(g0,1x))' character(len=20), allocatable :: strings (:) integer, allocatable :: xdont (:) Subroutines subroutine printme () Arguments None subroutine printme_char () Arguments None Source Code program demo_uniinv use M_uniinv , only : uniinv implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) character ( len = 20 ), allocatable :: strings (:) integer , allocatable :: cindx (:) ! all values unique xdont = [ 0 , 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 , 99 ] xdont = xdont ( size ( xdont ): 1 : - 1 ) ! reverse it call printme () ! duplicate values xdont = [ - 1.0 , 0.0 , - 1.0 , 0.0 , - 1.0 , 0.0 , - 1.0 ] call printme () xdont = [ 1 0.0 , 5.0 , 7.0 , 1.0 , 4.0 , 5.0 , 6.0 , 8.0 , 9.0 , 1 0.0 , 1.0 ] call printme () xdont = [ 1 0.0 , 2 0.0 , 3 0.0 , 1 0.0 , 2 0.0 , 3 0.0 , 1 0.0 , 2 0.0 , 3 0.0 ] call printme () strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' ] call printme_char () strings = [ character ( len = 20 ) :: & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'brown' , 'brown' , 'gray' , 'green' , 'magenta' ] call printme_char () strings = [ 'purple' , 'purple' , 'purple' , 'purple' ] call printme_char () contains subroutine printme_char () integer , allocatable :: igoest (:) character ( len = 20 ), allocatable :: out (:) integer :: imx integer :: i integer :: isz isz = size ( strings ) write ( * , g ) 'Original:                 ' ,( trim ( strings ( i )), i = 1 , isz ) write ( * , g ) 'Number of indices to sort:' , isz if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( strings ))) call uniinv ( strings , igoest ) imx = maxval ( igoest ) write ( * , g ) 'Returned Indices:         ' , igoest (:) write ( * , g ) 'Number of unique indices :' , imx if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( strings ) out ( igoest ( i )) = strings ( i ) enddo write ( * , g ) 'Sorted unique values:     ' ,( trim ( out ( i )), i = 1 , size ( out )) write ( * , g ) end subroutine printme_char subroutine printme () integer , allocatable :: igoest (:) integer , allocatable :: out (:) integer :: imx integer :: i write ( * , g ) 'Original:                 ' , xdont write ( * , g ) 'Number of indices to sort:' , size ( xdont ) if ( allocated ( igoest )) deallocate ( igoest ) allocate ( igoest ( size ( xdont ))) call uniinv ( xdont , igoest ) imx = maxval ( igoest ) write ( * , g ) 'Returned Indices:         ' , igoest (:) write ( * , g ) 'Number of unique indices :' , imx if ( allocated ( out )) deallocate ( out ) allocate ( out ( imx )) do i = 1 , size ( xdont ) out ( igoest ( i )) = xdont ( i ) enddo write ( * , g ) 'Sorted unique values:     ' , out write ( * , g ) end subroutine printme end program demo_uniinv","tags":"","loc":"program/demo_uniinv.html"},{"title":"demo_unista – orderpack","text":"Uses M_unista Contents Variables list nuni xdont Source Code demo_unista Variables Type Attributes Name Initial character(len=*), parameter :: list = '(*(g0:,\",\"))' integer :: nuni real, allocatable :: xdont (:) Source Code program demo_unista use M_unista , only : unista implicit none character ( len =* ), parameter :: list = '(*(g0:,\",\"))' real , allocatable :: xdont (:) integer :: nuni xdont = [ 4.4 , 3.3 , 3.3 , 3.3 , 2.2 , 1.1 , 3.3 , 4.4 , 5.5 , 3.3 ] print list , 'ORIGINAL:' , xdont print * call unista ( xdont , nuni ) xdont = xdont (: nuni ) print list , 'UNIQUE:' , xdont end program demo_unista","tags":"","loc":"program/demo_unista.html"},{"title":"demo_rnkpar – orderpack","text":"Uses M_rnkpar iso_fortran_env Contents Variables i indx ivals out valsr Source Code demo_rnkpar Variables Type Attributes Name Initial integer :: i integer :: indx (2000) integer, parameter :: ivals = 300 real(kind=real32) :: out (ivals) real(kind=real32) :: valsr (2000) Source Code program demo_rnkpar use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_rnkpar , only : rnkpar implicit none integer , parameter :: ivals = 300 real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real32 ) :: out ( ivals ) integer :: indx ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call rnkpar ( valsr , indx , ivals ) out = valsr ( indx (: ivals )) do i = 1 , ivals - 1 if ( out ( i + 1 ). lt . out ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_rnkpar","tags":"","loc":"program/demo_rnkpar.html"},{"title":"demo_refsor – orderpack","text":"Uses M_refsor iso_fortran_env Contents Variables i valsd valsi valsr Source Code demo_refsor Variables Type Attributes Name Initial integer :: i real(kind=real64) :: valsd (2000) integer :: valsi (2000) real(kind=real32) :: valsr (2000) Source Code program demo_refsor use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_refsor , only : refsor implicit none ! an insertion sort is very efficient for very small arrays ! but generally slower than methods like quicksort and mergesort. real ( kind = real32 ) :: valsr ( 2000 ) real ( kind = real64 ) :: valsd ( 2000 ) integer :: valsi ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) call random_number ( valsd ) valsi = int ( valsr * 100000 0.0 ) valsr = valsr * 100000 0.0 - 50000 0.0 valsd = valsd * 100000 0.0 - 50000 0.0 call refsor ( valsi ) do i = 1 , size ( valsi ) - 1 if ( valsi ( i + 1 ). lt . valsi ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo call refsor ( valsr ) do i = 1 , size ( valsr ) - 1 if ( valsr ( i + 1 ). lt . valsr ( i )) then write ( * , * ) 'not sorted' stop 2 endif enddo call refsor ( valsd ) do i = 1 , size ( valsd ) - 1 if ( valsd ( i + 1 ). lt . valsd ( i )) then write ( * , * ) 'not sorted' stop 3 endif enddo write ( * , * ) 'random arrays are now sorted' end program demo_refsor","tags":"","loc":"program/demo_refsor.html"},{"title":"chrono – orderpack","text":"Uses M_mrgrnk M_valnth Contents Variables dres dvalt ibcl jres jrnkt jseet jvalt kdp lrnk nbcl nsee nth tdep1 tdep2 tfin1 tfin2 xres xvalt Source Code chrono Variables Type Attributes Name Initial real(kind=kdp) :: dres real(kind=kdp), Dimension (5001) :: dvalt integer :: ibcl integer :: jres integer, Dimension (5001) :: jrnkt integer, Dimension (:), Allocatable :: jseet integer, Dimension (5001) :: jvalt integer, parameter :: kdp = selected_real_kind(15) integer :: lrnk integer, parameter :: nbcl = 10000 integer :: nsee integer, parameter :: nth = 31 real :: tdep1 real :: tdep2 real :: tfin1 real :: tfin2 real :: xres real, Dimension (5001) :: xvalt Source Code program chrono use M_valnth use M_mrgrnk Integer , Parameter :: nbcl = 10000 Integer , Parameter :: nth = 31 Integer , Parameter :: kdp = selected_real_kind ( 15 ) Real ( kind = kdp ), Dimension ( 5001 ) :: dvalt Real , Dimension ( 5001 ) :: xvalt Integer , Dimension ( 5001 ) :: jvalt Integer , Dimension ( 5001 ) :: jrnkt Integer , Dimension (:), Allocatable :: jseet Integer :: nsee , ibcl , lrnk , jres Real :: tdep1 , tdep2 , tfin1 , tfin2 Real :: xres Real ( kind = kdp ) :: dres ! Call random_seed ( size = nsee ) Allocate ( jseet ( 1 : nsee )) ! Call random_seed ( get = jseet ) !      write (unit=*, fmt=*) jseet ! Call cpu_time ( tdep1 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) jvalt = Nint ( 100 0.0 * xvalt ) End Do Call cpu_time ( tfin1 ) Call random_seed ( put = jseet ) Call cpu_time ( tdep2 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) jvalt = Nint ( 100 0.0 * xvalt ) lrnk = 10 + modulo ( ibcl , 10 ) jres = valnth ( jvalt , lrnk ) End Do Call cpu_time ( tfin2 ) write ( unit =* , fmt =* ) \"Integer: \" ,(( tfin2 - tdep2 ) - ( tfin1 - tdep1 )) * 100 0.0 / real ( nbcl ), \" ms\" Call random_seed ( put = jseet ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) jvalt = Nint ( 100 0.0 * xvalt ) lrnk = 10 + modulo ( ibcl , 10 ) jres = valnth ( jvalt , lrnk ) Call mrgrnk ( jvalt , jrnkt ) If ( jvalt ( jrnkt ( lrnk )) /= jres ) then write ( unit =* , fmt =* ) \"*** Check Failed\" write ( unit =* , fmt =* ) jvalt ( jrnkt ( lrnk )) write ( unit =* , fmt =* ) jres write ( unit =* , fmt =* ) ibcl , \"seed \" , jseet stop End If End Do ! Call random_seed ( put = jseet ) Call cpu_time ( tdep1 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) End Do Call cpu_time ( tfin1 ) Call random_seed ( put = jseet ) Call cpu_time ( tdep2 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) lrnk = 10 + modulo ( ibcl , 10 ) xres = valnth ( xvalt , lrnk ) End Do Call cpu_time ( tfin2 ) write ( unit =* , fmt =* ) \"Real:    \" ,(( tfin2 - tdep2 ) - ( tfin1 - tdep1 )) * 100 0.0 / real ( nbcl ), \" ms\" Call random_seed ( put = jseet ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) lrnk = 10 + modulo ( ibcl , 10 ) xres = valnth ( xvalt , lrnk ) Call mrgrnk ( xvalt , jrnkt ) If ( xvalt ( jrnkt ( lrnk )) /= xres ) then write ( unit =* , fmt =* ) \"*** Check Failed\" write ( unit =* , fmt =* ) xvalt ( jrnkt ( lrnk )) write ( unit =* , fmt =* ) xres write ( unit =* , fmt =* ) ibcl , \"seed \" , jseet stop End If End Do ! Call random_seed ( put = jseet ) Call cpu_time ( tdep1 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) dvalt = xvalt End Do Call cpu_time ( tfin1 ) Call random_seed ( put = jseet ) Call cpu_time ( tdep2 ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) dvalt = xvalt lrnk = 10 + modulo ( ibcl , 10 ) dres = valnth ( dvalt , lrnk ) End Do Call cpu_time ( tfin2 ) write ( unit =* , fmt =* ) \"Double:  \" ,(( tfin2 - tdep2 ) - ( tfin1 - tdep1 )) * 100 0.0 / real ( nbcl ), \" ms\" Call random_seed ( put = jseet ) Do ibcl = 1 , nbcl Call random_number ( xvalt (:)) dvalt = xvalt lrnk = 10 + modulo ( ibcl , 10 ) dres = valnth ( dvalt , lrnk ) Call mrgrnk ( dvalt , jrnkt ) If ( dvalt ( jrnkt ( lrnk )) /= dres ) then write ( unit =* , fmt =* ) \"*** Check Failed\" write ( unit =* , fmt =* ) dvalt ( jrnkt ( lrnk )) write ( unit =* , fmt =* ) dres write ( unit =* , fmt =* ) ibcl , \"seed \" , jseet stop End If End Do ! end program chrono","tags":"","loc":"program/chrono.html"},{"title":"demo_mrgrnk – orderpack","text":"Uses M_mrgrnk Contents Variables cindx dd dp g i indx isz j k pp strings Source Code demo_mrgrnk Variables Type Attributes Name Initial integer, allocatable :: cindx (:) real(kind=dp) :: dd (isz) integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: indx (isz) integer, parameter :: isz = 10000 integer :: j integer :: k real(kind=dp) :: pp character(len=:), allocatable :: strings (:) Source Code program demo_mrgrnk use M_mrgrnk , only : mrgrnk implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 10000 real ( kind = dp ) :: dd ( isz ) real ( kind = dp ) :: pp integer :: indx ( isz ) integer :: i , j , k character ( len = :), allocatable :: strings (:) integer , allocatable :: cindx (:) ! make some random numbers call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! rank the numeric data call mrgrnk ( dd , indx ) ! check order do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , g ) 'ERROR: data not sorted i=' , i , 'index=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) stop 1 endif enddo ! sort data using rank values dd = dd ( indx ) write ( * , g ) 'sorted ' , isz , 'values' write ( * , g ) 'from' , dd ( 1 ), 'to' , dd ( isz ) write ( * , * ) minval ( dd ). eq . dd ( 1 ) write ( * , * ) maxval ( dd ). eq . dd ( isz ) write ( * , * ) minloc ( dd ). eq . 1 write ( * , * ) maxloc ( dd ). eq . isz ! do a character sort strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' , & & 'white' , 'brown' , 'gray' , 'cyan' , 'magenta' , & & 'purple' ] if ( allocated ( cindx )) deallocate ( cindx ); allocate ( cindx ( size ( strings ))) write ( * , '(a,8(a:,\",\"))' ) 'BEFORE ' ,& & ( trim ( strings ( i )), i = 1 , size ( strings )) call mrgrnk ( strings , cindx ) write ( * , '(a,8(a:,\",\"))' ) 'SORTED ' ,& & ( trim ( strings ( cindx ( i ))), i = 1 , size ( strings )) strings = strings ( cindx ) ! sort the array using the rank index do i = 1 , size ( strings ) - 1 if ( strings ( i ). gt . strings ( i + 1 )) then write ( * , * ) 'Error in sorting strings a-z' endif enddo end program demo_mrgrnk","tags":"","loc":"program/demo_mrgrnk.html"},{"title":"givcor – orderpack","text":"Uses M_ctrper M_refsor Contents Variables dmoyc dmoyp dref dsigc dsigp dsum dtar dtarw ibcl jsavt jseet kdp ndim nsee xchit xdec xnewt xpart xper Source Code givcor Variables Type Attributes Name Initial real(kind=kdp) :: dmoyc real(kind=kdp) :: dmoyp real(kind=kdp) :: dref real(kind=kdp) :: dsigc real(kind=kdp) :: dsigp real(kind=kdp) :: dsum real(kind=kdp), parameter :: dtar = 0.1654_kdp real(kind=kdp) :: dtarw integer :: ibcl integer, Dimension (:), Allocatable :: jsavt integer, Dimension (:), Allocatable :: jseet integer, parameter :: kdp = selected_real_kind(15) integer, parameter :: ndim = 21571 integer :: nsee real(kind=kdp), Dimension (ndim) :: xchit real :: xdec = 0.997 real(kind=kdp), Dimension (ndim) :: xnewt real(kind=kdp), Dimension (ndim) :: xpart real :: xper = 0.25 Source Code program givcor !   Given two arrays of equal length of unordered values, find a !   \"matching value\" in the second array for each value in the !   first so that the global correlation coefficient reaches !   exactly a given target. ! _________________________________________________________________ !   The routine first sorts the two arrays, so as to get the !   match of maximum correlation. !   It then will iterate, applying the random permutation algorithm !   of controlled disorder ctrper to the second array. When the !   resulting correlation goes beyond (lower than) the target !   correlation, one steps back and reduces the disorder parameter !   of the permutation. When the resulting correlation lies between !   the current one and the target, one replaces the array with !   the newly permuted one. When the resulting correlation increases !   from the current value, one increases the disorder parameter. !   That way, the target correlation is approached from above, by !   a controlled increase in randomness. !   The example is two arrays representing parents' incomes and !   children's incomes, but where it is not known which parents !   correspond to which children. The output is a list of pairs !   {parents' income, children's income} such that the target !   correlation is approached. !   Michel Olagnon - December 2001. !   Corrected August 2007 (dot_product (xnewt, xpart) line 87, !             and negative correlation targets). ! _________________________________________________________________ use M_ctrper use M_refsor ! Integer , Parameter :: ndim = 21571 ! Number of pairs Integer , Parameter :: kdp = selected_real_kind ( 15 ) Real ( kind = kdp ), Parameter :: dtar = 0.1654_kdp ! Target correlation Real ( kind = kdp ) :: dsum , dref , dmoyp , dsigp , dmoyc , dsigc , dtarw Real ( kind = kdp ), Dimension ( ndim ) :: xpart , xchit , xnewt Real :: xper = 0.25 Real :: xdec = 0.997 Integer , Dimension (:), Allocatable :: jseet , jsavt Integer :: nsee , ibcl ! Call random_seed ( size = nsee ) Allocate ( jseet ( 1 : nsee ), jsavt ( 1 : nsee )) ! !   Read parent's incomes ! Open ( unit = 11 , file = \"parents.dat\" , form = \"formatted\" , status = \"old\" , action = \"read\" ) Do ibcl = 1 , ndim read ( unit = 11 , fmt =* ) xpart ( ibcl ) End Do Close ( unit = 11 ) ! !   Sort, and normalize to make further correlation computations faster ! call refsor ( xpart ) dmoyp = sum ( xpart ) / real ( ndim , kind = kdp ) xpart = xpart - dmoyp dsigp = sqrt ( dot_product ( xpart , xpart )) xpart = xpart * ( 1.0_kdp / dsigp ) ! !   Read children's incomes ! Open ( unit = 12 , file = \"children.dat\" , form = \"formatted\" , status = \"old\" , action = \"read\" ) Do ibcl = 1 , ndim read ( unit = 12 , fmt =* ) xchit ( ibcl ) End Do Close ( unit = 12 ) ! !   Sort, and normalize ! call refsor ( xchit ) dmoyc = sum ( xchit ) / real ( ndim , kind = kdp ) xchit = xchit - dmoyc dsigc = sqrt ( dot_product ( xchit , xchit )) if ( dtar < 0.0_kdp ) then xchit = - xchit * ( 1.0_kdp / dsigc ) else xchit = xchit * ( 1.0_kdp / dsigc ) endif dtarw = abs ( dtar ) ! !   Compute starting value, maximum correlation ! dref = dot_product ( xpart , xchit ) !      write (unit=*, fmt=\"(f8.6)\") dref ! !   Iterate ! Do ibcl = 1 , 100000 xnewt = xchit ! !   Add some randomness to the current order ! Call ctrper ( xnewt , xper ) dsum = dot_product ( xnewt , xpart ) !    if (modulo (ibcl,100) == 1) write (unit=*, fmt=*) ibcl, dref, dsum, xper ! !   Check for hit of target ! if ( abs ( dsum - dtarw ) < 0.00001_kdp ) then dref = dsum xchit = xnewt exit End If ! !   Better, but not yet reached target: take new set as current one ! if ( dsum < dref . and . dsum > dtarw ) then dref = dsum xchit = xnewt ! !   We went too far, beyond the target: try to be a little less random ! elseif ( dsum < dtarw ) then xper = max ( xper * xdec , 0.5 / Real ( ndim )) ! !   We are going in the ordered direction: try to be a little more random ! elseif ( dsum > dref ) then xper = min ( xper / xdec , 0.25 ) endif End Do ! !   Unnormalize and output pairs ! write ( unit =* , fmt = \"(a,f10.8,a,i8)\" ) \"Reached \" , dref , & \"after iteration \" , ibcl xpart = dmoyp + dsigp * xpart if ( dtar < 0.0_kdp ) then xchit = dmoyc - dsigc * xchit else xchit = dmoyc + dsigc * xchit endif Open ( unit = 13 , file = \"corchild.dat\" , form = \"formatted\" , status = \"unknown\" ,& action = \"write\" ) Do ibcl = 1 , ndim write ( unit = 13 , fmt =* ) nint ( xpart ( ibcl )), nint ( xchit ( ibcl )) End Do Close ( unit = 13 ) ! end program givcor","tags":"","loc":"program/givcor.html"},{"title":"demo_unirnk – orderpack","text":"Uses M_unirnk Contents Variables g xvalt Subroutines printme Source Code demo_unirnk Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: xvalt (:) Subroutines subroutine printme () Arguments None Source Code program demo_unirnk use M_unirnk , only : unirnk implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xvalt (:) ! xvalt = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] call printme () xvalt = [ - 1 , 0 , - 2 , 0 , - 3 , 0 , - 4 ] call printme () contains subroutine printme () integer , allocatable :: irngt (:) integer :: nuni if ( allocated ( irngt )) deallocate ( irngt ) allocate ( irngt ( size ( xvalt ))) write ( * , g ) 'ORIGINAL:' , xvalt call unirnk ( xvalt , irngt , nuni ) write ( * , g ) 'NUMBER OF UNIQUE INDICES:' , nuni write ( * , g ) 'RETURNED INDICES:' , irngt (: nuni ) write ( * , g ) 'SORTED DATA:' , xvalt ( irngt (: nuni )) end subroutine end program demo_unirnk","tags":"","loc":"program/demo_unirnk.html"},{"title":"demo_unipar – orderpack","text":"Uses M_unipar Contents Variables g irngt nord xdont Subroutines printme Source Code demo_unipar Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer, allocatable :: irngt (:) integer :: nord integer, allocatable :: xdont (:) Subroutines subroutine printme () Arguments None Source Code program demo_unipar use M_unipar , only : unipar implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: xdont (:) integer , allocatable :: irngt (:) integer :: nord ! write ( * , g ) 'If enough values are unique, will return NORD indices' if ( allocated ( irngt )) deallocate ( irngt ) xdont = [ 10 , 5 , 7 , 1 , 4 , 5 , 6 , 8 , 9 , 10 , 1 ] nord = 5 allocate ( irngt ( nord )) call printme () ! !BUG!write(*,g)'If not enough values are unique, will change NORD' !BUG!xdont=[-1,0,-1,0,-1,0,-1] !BUG!nord=5 !BUG!if(allocated(irngt))deallocate(irngt) !BUG!allocate(irngt(nord)) !BUG!call printme() contains subroutine printme () write ( * , g ) 'ORIGINAL:' , xdont write ( * , g ) 'NUMBER OF INDICES TO SORT:' , nord call unipar ( xdont , irngt , nord ) write ( * , g ) 'NUMBER OF INDICES RETURNED:' , nord write ( * , g ) 'RETURNED INDICES:' , irngt (: nord ) write ( * , g ) nord , 'SMALLEST UNIQUE VALUES:' , xdont ( irngt (: nord )) end subroutine end program demo_unipar","tags":"","loc":"program/demo_unipar.html"},{"title":"demo_indmed – orderpack","text":"Uses M_indmed Contents Variables cdont ii xdont Source Code demo_indmed Variables Type Attributes Name Initial character(len=:), allocatable :: cdont (:) integer :: ii real, allocatable :: xdont (:) Source Code program demo_indmed use M_indmed , only : indmed implicit none real , allocatable :: xdont (:) character ( len = :), allocatable :: cdont (:) integer :: ii xdont = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] call indmed ( xdont , ii ) write ( * , * ) ii , xdont ( ii ) ! xdont = [ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ] call indmed ( xdont , ii ) write ( * , * ) ii , xdont ( ii ) ! xdont = [ 1 1.0d0 , 7 7.0d0 , 2 2.0d0 , 6 6.0d0 , 3 3.0d0 , 8 8.0d0 ] call indmed ( xdont , ii ) write ( * , * ) ii , xdont ( ii ) ! cdont = [ character ( len = 20 ) :: 'apple' , 'bee' , 'cherry' , 'duck' , 'elephant' , 'finger' , 'goose' , 'h' , 'insect' , 'j' ] call indmed ( cdont , ii ) write ( * , * ) ii , cdont ( ii ) ! end program demo_indmed","tags":"","loc":"program/demo_indmed.html"},{"title":"demo_refpar – orderpack","text":"Uses M_refpar iso_fortran_env Contents Variables i indx valsr Source Code demo_refpar Variables Type Attributes Name Initial integer :: i integer :: indx (2000) real(kind=real32) :: valsr (2000) Source Code program demo_refpar use , intrinsic :: iso_fortran_env , only : int32 , real32 , real64 use M_refpar , only : refpar implicit none real ( kind = real32 ) :: valsr ( 2000 ) integer :: indx ( 2000 ) integer :: i call random_seed () call random_number ( valsr ) valsr = valsr * 100000 0.0 - 50000 0.0 call refpar ( valsr , indx , 300 ) valsr (: 300 ) = valsr ( indx (: 300 )) do i = 1 , 300 - 1 if ( valsr ( i + 1 ). lt . valsr ( i )) then write ( * , * ) 'not sorted' stop 1 endif enddo write ( * , * ) 'random array now sorted' end program demo_refpar","tags":"","loc":"program/demo_refpar.html"},{"title":"demo_valmed – orderpack","text":"Uses M_valmed Contents Variables res_med xdont Source Code demo_valmed Variables Type Attributes Name Initial real :: res_med real, parameter :: xdont (*) = [80.0, 70.0, 20.0, 10.0, 1000.0] Source Code program demo_valmed use M_valmed , only : valmed implicit none real , parameter :: xdont ( * ) = [ 8 0.0 , 7 0.0 , 2 0.0 , 1 0.0 , 100 0.0 ] real res_med write ( * , * ) valmed ( xdont ) write ( * , * ) valmed ([ 11 , 22 , 33 , 44 , 55 , 66 , 77 , 88 ]) write ( * , * ) valmed ([ 1 1.0d0 , 2 2.0d0 , 3 3.0d0 , 6 6.0d0 , 7 7.0d0 , 8 8.0d0 ]) end program demo_valmed","tags":"","loc":"program/demo_valmed.html"},{"title":"follow – orderpack","text":"Contents Variables imax imin inxt ipnt irndt itst nmax t wdst wdst0 xang xlen xori xptst xrndt xtmp xtmpt xunt xunt1 xvec yori yptst ytmp ytmpt yunt yunt1 yvec Subroutines MRGRNK Source Code follow Variables Type Attributes Name Initial integer :: imax integer :: imin integer :: inxt integer :: ipnt integer, dimension (nmax) :: irndt integer :: itst integer, parameter :: nmax = 200 real :: t real :: wdst real :: wdst0 real :: xang real :: xlen real :: xori real, dimension (nmax) :: xptst real, dimension (nmax) :: xrndt real :: xtmp real, dimension (nmax) :: xtmpt real :: xunt real :: xunt1 real :: xvec real :: yori real, dimension (nmax) :: yptst real :: ytmp real, dimension (nmax) :: ytmpt real :: yunt real :: yunt1 real :: yvec Subroutines subroutine MRGRNK (XVALT, IRNGT) Arguments Type Intent Optional Attributes Name real, intent(in), Dimension (:) :: XVALT integer, intent(out), Dimension (:) :: IRNGT Source Code Program follow !  Question From Colin Thefleau: ! ! I have a small problem that my cloudy brain can't solve: ! Say I have a bunch of coordinates (realx(i), realy(i)) that form a circle ! (or any closed form) if every point is plotted. I have to sort them so that ! they \"ride\" the circle in one direction. For example beginning at one point ! (the highest point for example), and go in the clock drive direction. ! Has someone an idea how this is to be done?  Or where can I find a sample ! code for inspiration? I am really new to fortran and really can't find a ! solution. ! -------------------------------------------------------------------------- ! The following program is an attempt to answer that question for a ! \"reasonable\" profile. From the current point, it finds the \"nearest\" ! point in the set of remaining ones according to some weighted distance, ! weights penalizing the direction that one is coming from. ! integer , parameter :: nmax = 200 real , dimension ( nmax ) :: xptst , yptst , xtmpt , ytmpt , xrndt integer , dimension ( nmax ) :: irndt real :: t , xtmp , ytmp , xunt , yunt , xori , yori , xvec , yvec , wdst , wdst0 , & xlen , xang , xunt1 , yunt1 integer :: imin , imax , ipnt , inxt , itst ! !  take a continuous curve and make the order random ! call random_number ( xrndt ) call mrgrnk ( xrndt , irndt ) ! do ipnt = 1 , nmax t = 6.28318 * real ( ipnt ) / real ( nmax ) xtmpt ( ipnt ) = ( 5. + 2 * cos ( 4. * t )) * cos ( t ) ytmpt ( ipnt ) = - ( 5. + 2 * cos ( 4. * t )) * sin ( t ) enddo xptst = xtmpt ( irndt ) yptst = ytmpt ( irndt ) ! ! Bring starting point (Northmost) to first position ! imin = sum ( maxloc ( yptst )) xtmp = xptst ( 1 ) ytmp = yptst ( 1 ) xptst ( 1 ) = xptst ( imin ) yptst ( 1 ) = yptst ( imin ) xptst ( imin ) = xtmp yptst ( imin ) = ytmp ! ! unit vector in the current direction (east) ! xunt = 1. yunt = 0. ! ! Find next point in line ! nextpoint : do inxt = 2 , nmax - 1 xori = xptst ( inxt - 1 ) yori = yptst ( inxt - 1 ) wdst0 = huge ( wdst ) do itst = inxt , nmax xvec = xptst ( itst ) - xori yvec = yptst ( itst ) - yori xlen = sqrt ( xvec * xvec + yvec * yvec ) if ( xlen < epsilon ( 1.0 )) then imin = itst xunt1 = xunt yunt1 = xunt exit endif ! !  Compute distance, weighted by a cosine function of the angle !  with the last segment. Weight is 1 when straight ahead, !  3 when going backwards, 2 if transverse. By using some !  power of the cosine, one may increase or decrease the pressure !  to go straight ahead with respect to transverse directions. ! xang = acos ( 0.9999 * ( xvec * xunt + yvec * yunt ) / xlen ) wdst = xlen * ( 3.0 - 2.0 * cos ( 0.5 * xang )) ! !  Retain minimum distance ! if ( wdst <= wdst0 ) then wdst0 = wdst imin = itst xunt1 = xvec / xlen yunt1 = yvec / xlen endif enddo ! !  Exchange retained point with current one ! xtmp = xptst ( inxt ) ytmp = yptst ( inxt ) xptst ( inxt ) = xptst ( imin ) yptst ( inxt ) = yptst ( imin ) xptst ( imin ) = xtmp yptst ( imin ) = ytmp xunt = xunt1 yunt = yunt1 enddo nextpoint ! ! Output ! imax = sum ( maxloc ( ytmpt )) do ipnt = 1 , nmax write ( * , * ) ipnt , xptst ( ipnt ), yptst ( ipnt ), xtmpt ( imax ), ytmpt ( imax ) imax = mod ( imax , nmax ) + 1 enddo contains Subroutine MRGRNK ( XVALT , IRNGT ) ! __________________________________________________________ !   MRGRNK = Merge-sort ranking of an array !   For performance reasons, the first 2 passes are taken !   out of the standard loop, and use dedicated coding. ! __________________________________________________________ Real , Dimension (:), Intent ( In ) :: XVALT Integer , Dimension (:), Intent ( Out ) :: IRNGT ! __________________________________________________________ Integer , Dimension ( SIZE ( IRNGT )) :: JWRKT Integer :: LMTNA , LMTNC , IRNG1 , IRNG2 Integer :: NVAL , IIND , IWRKD , IWRK , IWRKF , JINDA , IINDA , IINDB Real ( Kind ( XVALT )) :: XVALA , XVALB ! NVAL = Min ( SIZE ( XVALT ), SIZE ( IRNGT )) Select Case ( NVAL ) Case (: 0 ) Return Case ( 1 ) IRNGT ( 1 ) = 1 Return Case Default Continue End Select ! !  Fill-in the index array, creating ordered couples ! Do IIND = 2 , NVAL , 2 If ( XVALT ( IIND - 1 ) <= XVALT ( IIND )) Then IRNGT ( IIND - 1 ) = IIND - 1 IRNGT ( IIND ) = IIND Else IRNGT ( IIND - 1 ) = IIND IRNGT ( IIND ) = IIND - 1 End If End Do If ( Mod ( NVAL , 2 ) /= 0 ) Then IRNGT ( NVAL ) = NVAL End If ! !  We will now have ordered subsets A - B - A - B - ... !  and merge A and B couples into     C   -   C   - ... ! LMTNA = 2 LMTNC = 4 ! !  First iteration. The length of the ordered subsets goes from 2 to 4 ! Do If ( NVAL <= 2 ) Exit ! !   Loop on merges of A and B into C ! Do IWRKD = 0 , NVAL - 1 , 4 If (( IWRKD + 4 ) > NVAL ) Then If (( IWRKD + 2 ) >= NVAL ) Exit ! !   1 2 3 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Exit ! !   1 3 2 ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNG2 ! !   3 1 2 ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNG1 End If Exit End If ! !   1 2 3 4 ! If ( XVALT ( IRNGT ( IWRKD + 2 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Cycle ! !   1 3 x x ! If ( XVALT ( IRNGT ( IWRKD + 1 )) <= XVALT ( IRNGT ( IWRKD + 3 ))) Then IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   1 3 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   1 3 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If ! !   3 x x x ! Else IRNG1 = IRNGT ( IWRKD + 1 ) IRNG2 = IRNGT ( IWRKD + 2 ) IRNGT ( IWRKD + 1 ) = IRNGT ( IWRKD + 3 ) If ( XVALT ( IRNG1 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then IRNGT ( IWRKD + 2 ) = IRNG1 If ( XVALT ( IRNG2 ) <= XVALT ( IRNGT ( IWRKD + 4 ))) Then !   3 1 2 4 IRNGT ( IWRKD + 3 ) = IRNG2 Else !   3 1 4 2 IRNGT ( IWRKD + 3 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 4 ) = IRNG2 End If Else !   3 4 1 2 IRNGT ( IWRKD + 2 ) = IRNGT ( IWRKD + 4 ) IRNGT ( IWRKD + 3 ) = IRNG1 IRNGT ( IWRKD + 4 ) = IRNG2 End If End If End Do ! !  The Cs become As and Bs ! LMTNA = 4 Exit End Do ! !  Iteration loop. Each time, the length of the ordered subsets !  is doubled. ! Do If ( LMTNA >= NVAL ) Exit IWRKF = 0 LMTNC = 2 * LMTNC ! !   Loop on merges of A and B into C ! Do IWRK = IWRKF IWRKD = IWRKF + 1 JINDA = IWRKF + LMTNA IWRKF = IWRKF + LMTNC If ( IWRKF >= NVAL ) Then If ( JINDA >= NVAL ) Exit IWRKF = NVAL End If IINDA = 1 IINDB = JINDA + 1 ! !   Shortcut for the case when the max of A is smaller !   than the min of B. This line may be activated when the !   initial set is already close to sorted. ! !          IF (XVALT(IRNGT(JINDA)) <= XVALT(IRNGT(IINDB))) CYCLE ! !  One steps in the C subset, that we build in the final rank array ! !  Make a copy of the rank array for the merge iteration ! JWRKT ( 1 : LMTNA ) = IRNGT ( IWRKD : JINDA ) ! XVALA = XVALT ( JWRKT ( IINDA )) XVALB = XVALT ( IRNGT ( IINDB )) ! Do IWRK = IWRK + 1 ! !  We still have unprocessed values in both A and B ! If ( XVALA > XVALB ) Then IRNGT ( IWRK ) = IRNGT ( IINDB ) IINDB = IINDB + 1 If ( IINDB > IWRKF ) Then !  Only A still with unprocessed values IRNGT ( IWRK + 1 : IWRKF ) = JWRKT ( IINDA : LMTNA ) Exit End If XVALB = XVALT ( IRNGT ( IINDB )) Else IRNGT ( IWRK ) = JWRKT ( IINDA ) IINDA = IINDA + 1 If ( IINDA > LMTNA ) Exit ! Only B still with unprocessed values XVALA = XVALT ( JWRKT ( IINDA )) End If ! End Do End Do ! !  The Cs become As and Bs ! LMTNA = 2 * LMTNA End Do ! Return End Subroutine MRGRNK end Program follow","tags":"","loc":"program/follow.html"},{"title":"demo_mulcnt – orderpack","text":"Uses M_mulcnt Contents Variables g imult strings xdont Subroutines printme Source Code demo_mulcnt Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer, dimension(size(xdont)) :: imult character(len=20), allocatable :: strings (:) real, parameter :: xdont (*) = [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 6, 2] Subroutines subroutine printme () Arguments None Source Code program demo_mulcnt use M_mulcnt , only : mulcnt implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' real , parameter :: xdont ( * ) = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 4 , 5 , 6 , 6 , 2 ] integer , dimension ( size ( xdont )) :: imult character ( len = 20 ), allocatable :: strings (:) ! call mulcnt ( xdont , imult ) write ( * , * ) xdont write ( * , g ) imult ! strings = [ character ( len = 20 ) :: & & 'red' , 'green' , 'blue' , 'yellow' , 'orange' , 'black' ] call printme () ! strings = [ character ( len = 20 ) :: & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'two  ' , 'four ' , 'three' , 'five' , 'five' , & & 'four ' , 'four ' , 'three' , 'one  ' , 'five' ] call printme () ! strings = [ 'purple' , 'purple' , 'purple' , 'purple' ] call printme () contains subroutine printme () integer , allocatable :: cindx (:) integer :: csz integer :: i csz = size ( strings ) if ( allocated ( cindx )) deallocate ( cindx ) allocate ( cindx ( csz )) call mulcnt ( strings , cindx ) write ( * , g )( trim ( strings ( i )), i = 1 , csz ) write ( * , g ) cindx end subroutine printme end program demo_mulcnt","tags":"","loc":"program/demo_mulcnt.html"},{"title":"runtest – orderpack","text":"Uses M_refpar M_refsor M_mulcnt M_valmed M_uniinv M_valnth M_inspar M_unista M_rnkpar M_verify M_ctrper M_fndnth M_rapknr M_rinpar M_median M_mrgrnk M_unipar M_msg M_indmed M_inssor M_unirnk M_mrgref M_indnth Contents Variables dp Functions random_string Subroutines test_gen Source Code runtest Variables Type Attributes Name Initial integer, parameter :: dp = kind(0.0d0) Functions function random_string (chars, length) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(in) :: length Return Value character(len=:),allocatable Subroutines subroutine test_gen (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Source Code program runtest use M_msg use M_msg , only : str use M_verify use M_verify , only : unit_check_level use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_stop ! full ranking use M_mrgref , only : mrgref use M_mrgrnk , only : mrgrnk ! full sorting use M_inssor , only : inssor use M_refsor , only : refsor use M_ctrper use M_fndnth use M_indmed use M_indnth use M_inspar use M_median use M_mulcnt use M_rapknr use M_refpar use M_rinpar use M_rnkpar use M_uniinv use M_unipar use M_unirnk use M_unista use M_valmed use M_valnth implicit none integer , parameter :: dp = kind ( 0.0d0 ) unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_gen ( 'mrgref' ) call test_gen ( 'mrgrnk' ) call test_gen ( 'inssor' ) call test_gen ( 'refsor' ) call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_gen ( name ) character ( len =* ), intent ( in ) :: name integer , parameter :: isz = 10000 real :: rr ( isz ) real ( kind = dp ) :: dd ( isz ) integer :: ii ( isz ) character ( len = 10 ) :: cc ( isz ) integer :: indx ( isz ) integer :: i call unit_check_start ( name , '-library orderpack' ) ! start tests CALL RANDOM_NUMBER ( RR ) rr = rr * huge ( 0.0 ) select case ( name ) case ( 'inssor' ); call inssor ( rr ) case ( 'refsor' ); call refsor ( rr ) case ( 'mrgrnk' ); call mrgrnk ( rr , indx ); rr = rr ( indx ) case ( 'mrgref' ); call mrgref ( rr , indx ); rr = rr ( indx ) endselect call unit_check ( name , all ( rr ( 1 : isz - 1 ) . le . rr ( 2 : isz )), 'real test' , isz , 'values' ) CALL RANDOM_NUMBER ( RR ) ii = rr * huge ( 0 ) select case ( name ) case ( 'inssor' ); call inssor ( ii ) case ( 'refsor' ); call refsor ( ii ) case ( 'mrgrnk' ); call mrgrnk ( ii , indx ); ii = ii ( indx ) case ( 'mrgref' ); call mrgref ( ii , indx ); ii = ii ( indx ) endselect call unit_check ( name , all ( ii ( 1 : isz - 1 ) . le . ii ( 2 : isz )), 'integer test' , isz , 'values' ) CALL RANDOM_NUMBER ( DD ) dd = dd * huge ( 0.0_dp ) select case ( name ) case ( 'inssor' ); call inssor ( dd ) case ( 'refsor' ); call refsor ( dd ) case ( 'mrgrnk' ); call mrgrnk ( dd , indx ); dd = dd ( indx ) case ( 'mrgref' ); call mrgref ( dd , indx ); dd = dd ( indx ) endselect call unit_check ( name , all ( dd ( 1 : isz - 1 ) . le . dd ( 2 : isz )), 'double test' , isz , 'values' ) do i = 1 , isz cc ( i ) = random_string ( 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 10 ) enddo select case ( name ) case ( 'inssor' ); call inssor ( cc ) case ( 'refsor' ); call refsor ( cc ) case ( 'mrgrnk' ); call mrgrnk ( cc , indx ); cc = cc ( indx ) case ( 'mrgref' ); call mrgref ( cc , indx ); cc = cc ( indx ) endselect call unit_check ( name , all ( cc ( 1 : isz - 1 ) . le . cc ( 2 : isz )), 'string test, random' , isz , 'values' ) call unit_check_done ( name , msg = 'test completed' ) end subroutine test_gen !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT function random_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","loc":"program/runtest.html"},{"title":"test_mrgrnk – orderpack","text":"Uses M_mrgrnk Contents Variables dd dp i indx isz j k m pp Source Code test_mrgrnk Variables Type Attributes Name Initial real(kind=dp), allocatable :: dd (:) integer, parameter :: dp = kind(0.0d0) integer :: i integer, allocatable :: indx (:) integer, parameter :: isz = 1000000 integer :: j integer :: k integer :: m real(kind=dp) :: pp Source Code program test_mrgrnk use M_mrgrnk , only : mrgrnk implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: isz = 1000000 real ( kind = dp ), allocatable :: dd (:) real ( kind = dp ) :: pp integer , allocatable :: indx (:) integer :: i , j , k , m ! ! set up storage ! if ( allocated ( indx )) deallocate ( indx ) allocate ( indx ( isz )) if ( allocated ( dd )) deallocate ( dd ) allocate ( dd ( isz )) ! ! make some random numbers ! call random_seed () call random_number ( dd ) dd = dd - 0.50_dp k = int ( log ( huge ( 0.0_dp )) / log ( 2.0_dp )) - 1 do i = 1 , isz call random_number ( pp ) j = floor (( k + 1 ) * pp ) dd ( i ) = dd ( i ) * ( 2.0_dp ** j ) enddo ! ! sort data ! call mrgrnk ( dd , indx ) ! ! do some checks ! m = 0 do i = 1 , isz - 1 if ( dd ( indx ( i )). gt . dd ( indx ( i + 1 ))) then write ( * , * ) 'ERROR: data not sorted i=' , i , 'indx=' , indx ( i ), & & 'values ' , dd ( indx ( i )), dd ( indx ( i + 1 )) m = m + 1 endif enddo !do i=1,isz !   write(*,*)i,indx(i),dd(indx(i)) !enddo write ( * , * ) 'lowest                  ' , dd ( indx ( 1 )), minval ( dd ),& & dd ( indx ( 1 )). eq . minval ( dd ) write ( * , * ) 'highest                 ' , dd ( indx ( size ( indx ))), maxval ( dd ),& & dd ( indx ( size ( indx ))). eq . maxval ( dd ) write ( * , * ) 'smallest absolute value ' , minval ( abs ( dd )) write ( * , * ) 'huge                    ' , huge ( 0.0_dp ) write ( * , * ) 'tiny                    ' , tiny ( 0.0_dp ) if ( m . eq . 0 ) then write ( * , * ) 'sort passed' else write ( * , * ) 'sort failed, bad=' , m endif end program test_mrgrnk","tags":"","loc":"program/test_mrgrnk.html"}]}